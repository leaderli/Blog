[{"title":"Spring_Autowired源码分析","url":"%2F2019%2F11%2F14%2FSpring-Autowired%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F"},{"title":"spring_initMethod执行过程","url":"%2F2019%2F11%2F13%2Fspring-initMethod%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%2F","content":"\n## 准备\n\n`pom`依赖，`jdk`版本为`1.8`\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n<modelVersion>4.0.0</modelVersion>\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.2.1.RELEASE</version>\n    <relativePath/> <!-- lookup parent from repository -->\n</parent>\n<groupId>com.leaderli</groupId>\n<artifactId>demo</artifactId>\n<version>0.0.1-SNAPSHOT</version>\n<name>demo</name>\n<description>Demo project for Spring Boot</description>\n\n<properties>\n    <java.version>1.8</java.version>\n</properties>\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n        <exclusions>\n            <exclusion>\n                <groupId>org.junit.vintage</groupId>\n                <artifactId>junit-vintage-engine</artifactId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n</dependencies>\n\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n\n</project>\n\n```\n\n为了方便分析`Spring`中`bean`的生命周期，我们使用`@Lazy`来注解`bean`\n\n```java\n@Component\npublic class BeAutowired {\n    static {\n        System.out.println(\"-------BeAutowired--------\");\n    }\n}\n\n@Component\n@Lazy\npublic class Person {\n    @Autowired\n    BeAutowired beAutowired;\n    @PostConstruct\n    public void begin(){\n        System.out.println(\" beAutowired= \" + beAutowired);\n    }\n}\n```\n\n我们使用测试程序来分析`person`的加载过程\n\n```java\npublic static void main(String[] args) {\n    String packageName = Person.class.getPackage().getName();\n    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(packageName);\n    Person person = context.getBean(Person.class);\n    System.out.println(\"person = \" + person);\n}\n```\n\n## 分析\n\n### `doGetBean`\n\n因为使用了`@Lazy`,所以`Person`在执行`context.getBean(Person.class)`时才加载，我们`debug`进去大致了解一下关键的加载过程\n\n```java\n//交由BeanFactory去加载\n@Override\npublic <T> T getBean(Class<T> requiredType) throws BeansException {\n    assertBeanFactoryActive();\n    return getBeanFactory().getBean(requiredType);\n}\n```\n\n省略中间过程，最终会调用`BeanFactory`的`doGetBean`方法\n\n```java\npublic <T> T getBean(String name, @Nullable Class<T> requiredType, @Nullable Object... args)\n        throws BeansException {\n\n    return doGetBean(name, requiredType, args, false);\n}\n```\n\n`doGetBean`大致流程如下：\n\n1. \b 如果是单例模式的，则尝试从缓存中获取`bean`\n2. 尝试从父类`BeanFactory`中加载`bean`\n3. 加载依赖`bean`， `@DependsOn`注解的`bean`\n4. 使用方法`createBean(beanName, mbd, args)`,加载单例 bean\n\n`doGetBean`源码，无视其他代码，只关心我们需要了解的\n\n```java\nprotected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,\n        @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {\n\n    final String beanName = transformedBeanName(name);\n    Object bean;\n\n    // 1. \b如果是单例模式的，则尝试从缓存中获取bean\n    Object sharedInstance = getSingleton(beanName);\n    if (sharedInstance != null && args == null) {\n        if (logger.isTraceEnabled()) {\n            if (isSingletonCurrentlyInCreation(beanName)) {\n                logger.trace(\"Returning eagerly cached instance of singleton bean '\" + beanName +\n                        \"' that is not fully initialized yet - a consequence of a circular reference\");\n            }\n            else {\n                logger.trace(\"Returning cached instance of singleton bean '\" + beanName + \"'\");\n            }\n        }\n        bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n    }\n\n    else {\n        // Fail if we're already creating this bean instance:\n        // We're assumably within a circular reference.\n        if (isPrototypeCurrentlyInCreation(beanName)) {\n            throw new BeanCurrentlyInCreationException(beanName);\n        }\n\n        // 2. 尝试从父类BeanFactory中加载bean\n        BeanFactory parentBeanFactory = getParentBeanFactory();\n        if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n            // Not found -> check parent.\n            String nameToLookup = originalBeanName(name);\n            if (parentBeanFactory instanceof AbstractBeanFactory) {\n                return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                        nameToLookup, requiredType, args, typeCheckOnly);\n            }\n            else if (args != null) {\n                // Delegation to parent with explicit args.\n                return (T) parentBeanFactory.getBean(nameToLookup, args);\n            }\n            else if (requiredType != null) {\n                // No args -> delegate to standard getBean method.\n                return parentBeanFactory.getBean(nameToLookup, requiredType);\n            }\n            else {\n                return (T) parentBeanFactory.getBean(nameToLookup);\n            }\n        }\n\n        if (!typeCheckOnly) {\n            markBeanAsCreated(beanName);\n        }\n\n        try {\n            final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n            checkMergedBeanDefinition(mbd, beanName, args);\n\n            // 3. 加载依赖bean， @DependsOn注解的bean\n            String[] dependsOn = mbd.getDependsOn();\n            if (dependsOn != null) {\n                for (String dep : dependsOn) {\n                    if (isDependent(beanName, dep)) {\n                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                                \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\");\n                    }\n                    registerDependentBean(dep, beanName);\n                    try {\n                        getBean(dep);\n                    }\n                    catch (NoSuchBeanDefinitionException ex) {\n                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                                \"'\" + beanName + \"' depends on missing bean '\" + dep + \"'\", ex);\n                    }\n                }\n            }\n\n            // 4. 加载单例bean\n            if (mbd.isSingleton()) {\n                sharedInstance = getSingleton(beanName, () -> {\n                    try {\n                        return createBean(beanName, mbd, args);\n                    }\n                    catch (BeansException ex) {\n                        // Explicitly remove instance from singleton cache: It might have been put there\n                        // eagerly by the creation process, to allow for circular reference resolution.\n                        // Also remove any beans that received a temporary reference to the bean.\n                        destroySingleton(beanName);\n                        throw ex;\n                    }\n                });\n                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n            }\n\n            else if (mbd.isPrototype()) {\n                // It's a prototype -> create a new instance.\n                Object prototypeInstance = null;\n                try {\n                    beforePrototypeCreation(beanName);\n                    prototypeInstance = createBean(beanName, mbd, args);\n                }\n                finally {\n                    afterPrototypeCreation(beanName);\n                }\n                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n            }\n\n            else {\n                String scopeName = mbd.getScope();\n                final Scope scope = this.scopes.get(scopeName);\n                if (scope == null) {\n                    throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\");\n                }\n                try {\n                    Object scopedInstance = scope.get(beanName, () -> {\n                        beforePrototypeCreation(beanName);\n                        try {\n                            return createBean(beanName, mbd, args);\n                        }\n                        finally {\n                            afterPrototypeCreation(beanName);\n                        }\n                    });\n                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n                }\n                catch (IllegalStateException ex) {\n                    throw new BeanCreationException(beanName,\n                            \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" +\n                            \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\",\n                            ex);\n                }\n            }\n        }\n        catch (BeansException ex) {\n            cleanupAfterBeanCreationFailure(beanName);\n            throw ex;\n        }\n    }\n\n    // Check if required type matches the type of the actual bean instance.\n    if (requiredType != null && !requiredType.isInstance(bean)) {\n        try {\n            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);\n            if (convertedBean == null) {\n                throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n            }\n            return convertedBean;\n        }\n        catch (TypeMismatchException ex) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Failed to convert bean '\" + name + \"' to required type '\" +\n                        ClassUtils.getQualifiedName(requiredType) + \"'\", ex);\n            }\n            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n        }\n    }\n    return (T) bean;\n}\n```\n\n### `createBean`\n\n`createBean`大致流程如下：\n\n1. _`createBeanInstance`_,使用构造器或者工厂方法实例化`bean`\n2. _`populateBean`_,对`bean`进行数据的初始化操作，比如加载`@autowire`的`bean`，`@value`的属性赋值，`@PostConstruct`方法执行等\n3. _`initializeBean`_,执行`BeanDefinition`中定义的`initMethod`，一般在`xml` 配置中(`<bean class=\"Person\" init-method=\"initMethod\"/>`)，或者`@Bean(initMethod = \"initMethod\")`中定义的方法名\n\n`createBean`源码，无视其他代码，只关心我们需要了解的\n\n```java\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)\n        throws BeanCreationException {\n\n    // 1. 使用构造器实例化`bean`\n    BeanWrapper instanceWrapper = null;\n    if (mbd.isSingleton()) {\n        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n    }\n    if (instanceWrapper == null) {\n        instanceWrapper = createBeanInstance(beanName, mbd, args);\n    }\n    final Object bean = instanceWrapper.getWrappedInstance();\n    Class<?> beanType = instanceWrapper.getWrappedClass();\n    if (beanType != NullBean.class) {\n        mbd.resolvedTargetType = beanType;\n    }\n\n    // Allow post-processors to modify the merged bean definition.\n    synchronized (mbd.postProcessingLock) {\n        if (!mbd.postProcessed) {\n            try {\n                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n            }\n            catch (Throwable ex) {\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"Post-processing of merged bean definition failed\", ex);\n            }\n            mbd.postProcessed = true;\n        }\n    }\n\n    //这里主要解决循环依赖的问题，这里不做深入讨论\n    boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n            isSingletonCurrentlyInCreation(beanName));\n    if (earlySingletonExposure) {\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Eagerly caching bean '\" + beanName +\n                    \"' to allow for resolving potential circular references\");\n        }\n        addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n    }\n\n    // Initialize the bean instance.\n    Object exposedObject = bean;\n    try {\n        //2. 对bean进行数据的初始化操作，比如加载@autowire的bean，@value的属性赋值，@PostConstruct方法执行等\n        populateBean(beanName, mbd, instanceWrapper);\n        //3. 执行BeanDefinition中定义的initMethod，一般在xml配置中，或者@Bean(initMethod = \"initMethod\")中定义的方法名\n        exposedObject = initializeBean(beanName, exposedObject, mbd);\n    }\n    catch (Throwable ex) {\n        if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {\n            throw (BeanCreationException) ex;\n        }\n        else {\n            throw new BeanCreationException(\n                    mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex);\n        }\n    }\n\n    if (earlySingletonExposure) {\n        Object earlySingletonReference = getSingleton(beanName, false);\n        if (earlySingletonReference != null) {\n            if (exposedObject == bean) {\n                exposedObject = earlySingletonReference;\n            }\n            else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {\n                String[] dependentBeans = getDependentBeans(beanName);\n                Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);\n                for (String dependentBean : dependentBeans) {\n                    if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n                        actualDependentBeans.add(dependentBean);\n                    }\n                }\n                if (!actualDependentBeans.isEmpty()) {\n                    throw new BeanCurrentlyInCreationException(beanName,\n                            \"Bean with name '\" + beanName + \"' has been injected into other beans [\" +\n                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\n                            \"] in its raw version as part of a circular reference, but has eventually been \" +\n                            \"wrapped. This means that said other beans do not use the final version of the \" +\n                            \"bean. This is often the result of over-eager type matching - consider using \" +\n                            \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\");\n                }\n            }\n        }\n    }\n\n    // Register bean as disposable.\n    try {\n        registerDisposableBeanIfNecessary(beanName, bean, mbd);\n    }\n    catch (BeanDefinitionValidationException ex) {\n        throw new BeanCreationException(\n                mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex);\n    }\n\n    return exposedObject;\n}\n```\n\n### `populateBean`\n\n这里我们简单介绍一下`@Autowired`是何时被加载的。我们通过打断点，并设置`evaluate`语句，在断点处输出日志的方式查看  \n![spring-initMethod执行过程_2019-11-14-01-27-39.png](/images/spring-initMethod执行过程_2019-11-14-01-27-39.png)\n\n断点调试最后输出的日志如下  \n![spring-initMethod执行过程_2019-11-14-01-29-22.png](/images/spring-initMethod执行过程_2019-11-14-01-29-22.png)\n我们可以得知被`@Autowired`的属性或方法是否处理器`AutowiredAnnotationBeanPostProcessor`去实现的，具体加载过程参考 {% post_link Spring_Autowired源码分析 %}\n\n```java\nprotected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {\n    if (bw == null) {\n        if (mbd.hasPropertyValues()) {\n            throw new BeanCreationException(\n                    mbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\");\n        }\n        else {\n            // Skip property population phase for null instance.\n            return;\n        }\n    }\n\n    // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the\n    // state of the bean before properties are set. This can be used, for example,\n    // to support styles of field injection.\n    boolean continueWithPropertyPopulation = true;\n\n    if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n        for (BeanPostProcessor bp : getBeanPostProcessors()) {\n            if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n                if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n                    continueWithPropertyPopulation = false;\n                    break;\n                }\n            }\n        }\n    }\n\n    if (!continueWithPropertyPopulation) {\n        return;\n    }\n\n    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);\n\n    int resolvedAutowireMode = mbd.getResolvedAutowireMode();\n    if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {\n        MutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n        // Add property values based on autowire by name if applicable.\n        if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {\n            autowireByName(beanName, mbd, bw, newPvs);\n        }\n        // Add property values based on autowire by type if applicable.\n        if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {\n            autowireByType(beanName, mbd, bw, newPvs);\n        }\n        pvs = newPvs;\n    }\n\n    boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n    boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n    PropertyDescriptor[] filteredPds = null;\n    if (hasInstAwareBpps) {\n        if (pvs == null) {\n            pvs = mbd.getPropertyValues();\n        }\n        //对满足条件的BeanPostProcessor，执行postProcessProperties方法，对bean的属性进行赋值操作\n        for (BeanPostProcessor bp : getBeanPostProcessors()) {\n            if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n                PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);\n                if (pvsToUse == null) {\n                    if (filteredPds == null) {\n                        filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n                    }\n                    pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n                    if (pvsToUse == null) {\n                        return;\n                    }\n                }\n                pvs = pvsToUse;\n            }\n        }\n    }\n    if (needsDepCheck) {\n        if (filteredPds == null) {\n            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n        }\n        checkDependencies(beanName, mbd, filteredPds, pvs);\n    }\n\n    if (pvs != null) {\n        applyPropertyValues(beanName, mbd, bw, pvs);\n    }\n}\n```\n\n### `initializeBean`\n\n`initializeBean`大致执行步骤如下：\n\n1. 若接口实现了`Aware`，则执行对应的方法\n2. 执行所有`BeanPostProcessor`的`postProcessBeforeInitialization`方法\n3. 执行`BeanDefinition`中定义的`init-method`\n4. 执行所有`BeanPostProcessor`的`postProcessAfterInitialization`方法\n\n```java\nprotected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {\n    if (System.getSecurityManager() != null) {\n        AccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n            invokeAwareMethods(beanName, bean);\n            return null;\n        }, getAccessControlContext());\n    }\n    else {\n        //1. 若接口实现了`Aware`，则执行对应的方法\n        invokeAwareMethods(beanName, bean);\n    }\n\n    Object wrappedBean = bean;\n    if (mbd == null || !mbd.isSynthetic()) {\n        2. 执行所有`BeanPostProcessor`的`postProcessBeforeInitialization`方法\n        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n    }\n\n    try {\n        3. 执行`BeanDefinition`中定义的`init-method`\n        invokeInitMethods(beanName, wrappedBean, mbd);\n    }\n    catch (Throwable ex) {\n        throw new BeanCreationException(\n                (mbd != null ? mbd.getResourceDescription() : null),\n                beanName, \"Invocation of init method failed\", ex);\n    }\n    if (mbd == null || !mbd.isSynthetic()) {\n        4. 执行所有`BeanPostProcessor`的`postProcessAfterInitialization`方法\n        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n    }\n\n    return wrappedBean;\n}\n```\n\n我们对上述`initializeBean`的第三步骤不做过多介绍，其大致执行过程为在初始化`BeanDefinition`时，将`initMethod`的值通过下述方法加载\n\n```java\nvoid setInitMethodName(@Nullable String initMethodName);\n```\n\n然后`initializeBean`通过`invokeInitMethods`来执行`initMethod`\n\n#### applyBeanPostProcessorsBeforeInitialization\n\n我们同样通过断点调试的方式来观察，`@PostConstruct`方法是何时被执行的  \n![spring-initMethod执行过程_2019-11-14-01-45-47.png](/images/spring-initMethod执行过程_2019-11-14-01-45-47.png)\n我们可以得知是在`CommonAnnotationBeanPostProcessor`中被处理的\n\n我们查看其源码\n\n```java\n@Override\npublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n    //查找是否有@PostConstruct注解的方法\n    LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());\n    try {\n        //执行所有被注解了@PostConstruct的方法\n        metadata.invokeInitMethods(bean, beanName);\n    }\n    catch (InvocationTargetException ex) {\n        throw new BeanCreationException(beanName, \"Invocation of init method failed\", ex.getTargetException());\n    }\n    catch (Throwable ex) {\n        throw new BeanCreationException(beanName, \"Failed to invoke init method\", ex);\n    }\n    return bean;\n}\n```\n\n查看`findLifecycleMetadata`-->`buildLifecycleMetadata`细节  \n我们只需要了解`this.initAnnotationType`, `this.destroyAnnotationType`的赋值情况即可\n\n```java\nprivate LifecycleMetadata buildLifecycleMetadata(final Class<?> clazz) {\n    //是否有指定注解的方法存在\n    if (!AnnotationUtils.isCandidateClass(clazz, Arrays.asList(this.initAnnotationType, this.destroyAnnotationType))) {\n        return this.emptyLifecycleMetadata;\n    }\n\n    List<LifecycleElement> initMethods = new ArrayList<>();\n    List<LifecycleElement> destroyMethods = new ArrayList<>();\n    Class<?> targetClass = clazz;\n\n    do {\n        final List<LifecycleElement> currInitMethods = new ArrayList<>();\n        final List<LifecycleElement> currDestroyMethods = new ArrayList<>();\n\n        ReflectionUtils.doWithLocalMethods(targetClass, method -> {\n            if (this.initAnnotationType != null && method.isAnnotationPresent(this.initAnnotationType)) {\n                LifecycleElement element = new LifecycleElement(method);\n                currInitMethods.add(element);\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Found init method on class [\" + clazz.getName() + \"]: \" + method);\n                }\n            }\n            if (this.destroyAnnotationType != null && method.isAnnotationPresent(this.destroyAnnotationType)) {\n                currDestroyMethods.add(new LifecycleElement(method));\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Found destroy method on class [\" + clazz.getName() + \"]: \" + method);\n                }\n            }\n        });\n        //将扫描到的init,destroy方法放入LifecycleMetadata\n        initMethods.addAll(0, currInitMethods);\n        destroyMethods.addAll(currDestroyMethods);\n        targetClass = targetClass.getSuperclass();\n    }\n    while (targetClass != null && targetClass != Object.class);\n\n    return (initMethods.isEmpty() && destroyMethods.isEmpty() ? this.emptyLifecycleMetadata :\n            new LifecycleMetadata(clazz, initMethods, destroyMethods));\n}\n\n```\n\n我们通过查看`CommonAnnotationBeanPostProcessor`的构造器发现了`@PostConstruct`的赋值过程。\n\n```java\npublic CommonAnnotationBeanPostProcessor() {\n    setOrder(Ordered.LOWEST_PRECEDENCE - 3);\n    setInitAnnotationType(PostConstruct.class);\n    setDestroyAnnotationType(PreDestroy.class);\n    ignoreResourceType(\"javax.xml.ws.WebServiceContext\");\n}\n```\n","tags":["Spring加载过程"],"categories":["spring"]},{"title":"java面试题_1","url":"%2F2019%2F11%2F12%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98-1%2F","content":"\n### `HashMap`,`HashTable`,`CocurrentHashMap`的共同点和区别\n\n共同点：\n\n1. 底层使用拉链式数组\n2. 为了避免`hash`冲突，当当数组元素已用槽数量超过(容量\\*容载因子)就会扩容\n3. `\bput`时，对`key`进行`hash`计算槽，若槽没有元素则赋值，否则插入链表的结尾\n4. `get`时，对`key`进行`hash`计算槽，若槽没有元素或者仅有一个元素，则直接返回，\n   否则，通过`equals`方法比较`key`，返回指定的元素\n\n不同点：\n\n1. `HashTable`的`key`和`value`不允许`null`\n2. `hash`方法不同，`HashTable`直接对`hashcode`进行取模运算，`HashMap`首先对`hashcode`进行扰动计算，尽量避免 hash 碰撞。然后因其数组长度恒定为$2^n$,所以直接通过与运算进行取模，\n3. `HashMap`线程不安全，`HashTable`通过`synchronized`修改关键方法确保线程安全，`CoccurentHashMap`通过分段锁的方式实现\n\n### 说出几种幂等的实现方式\n\n幂等操作指任意多次执行的结果和执行一次的结果一样。通俗来说，就是同一用户的对同一操作的多次请求的结果是一致的。\n\n保证幂等性主要是三点：\n\n1. 对于同一操作的请求必须有唯一标识，例如订单支付系统，肯定包含订单`ID`，确保一个订单仅支付一次。\n2. 处理请求时需要有标识记录操作的状态，如正在处理中，已经处理完成等。\n3. 每次接受请求时，需要判断是否已经处理过该请求或者正在处理该请求。\n\n实现方式：\n\n1. 分布式锁\n2. 数据库锁\n3. 事务\n\n### `Spring`的`init-method`，`destroy-metdho`的实现方式\n\n根据{% post_link spring-initMethod执行过程 %}的分析，我们可以知道`Spring`在扫描`bean`的配置信息时，将\n`init-method`，`destroy-metdhod`的信息存储在`BeanDefinition`中，在`bean`的生命周期的一开始即实例化`bean`，以及对`bean`的属性进行初始化赋值后，会查找当前`BeanDefinition`,是否有`init-method`方法，有则通过反射去执行。在`bean`的生命周期的最后，会查找当前`BeanDefinition`,是否有`destroy-metdhod`方法，有则通过反射去执行。\n","tags":["面试题"],"categories":["面试题"]},{"title":"java数组","url":"%2F2019%2F11%2F12%2Fjava%E6%95%B0%E7%BB%84%2F","content":"\n## java 在堆中的内存分为三个部分\n\n1. 对象头 `Object header`\n2. 值 `value`\n3. 对齐 `padding`(不一定存在，java 内存需要对齐 8byte，不足部分填充)\n\n### java 对象头\n\n```java\n|--------------------------------------------------------------|\n|                     Object Header (64 bits)                  |\n|------------------------------------|-------------------------|\n|        Mark Word (32 bits)         |    Klass Word (32 bits) |\n|------------------------------------|-------------------------|\n```\n\njava 数组头\n\n```java\n|---------------------------------------------------------------------------------|\n|                                 Object Header (96 bits)                         |\n|--------------------------------|-----------------------|------------------------|\n|        Mark Word(32bits)       |    Klass Word(32bits) |  array length(32bits)  |\n|--------------------------------|-----------------------|------------------------|\n```\n\n其中`Mark Word`\n\n```java\n|-------------------------------------------------------|--------------------|\n|                  Mark Word (32 bits)                  |       State        |\n|-------------------------------------------------------|--------------------|\n| identity_hashcode:25 | age:4 | biased_lock:1 | lock:2 |       Normal       |\n|-------------------------------------------------------|--------------------|\n|  thread:23 | epoch:2 | age:4 | biased_lock:1 | lock:2 |       Biased       |\n|-------------------------------------------------------|--------------------|\n|               ptr_to_lock_record:30          | lock:2 | Lightweight Locked |\n|-------------------------------------------------------|--------------------|\n|               ptr_to_heavyweight_monitor:30  | lock:2 | Heavyweight Locked |\n|-------------------------------------------------------|--------------------|\n|                                              | lock:2 |    Marked for GC   |\n|-------------------------------------------------------|--------------------|\n```\n\n```java\n|------------------------------------------------------------------------------|--------------------|\n|                                  Mark Word (64 bits)                         |       State        |\n|------------------------------------------------------------------------------|--------------------|\n| unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 |       Normal       |\n|------------------------------------------------------------------------------|--------------------|\n| thread:54 |       epoch:2        | unused:1 | age:4 | biased_lock:1 | lock:2 |       Biased       |\n|------------------------------------------------------------------------------|--------------------|\n|                       ptr_to_lock_record:62                         | lock:2 | Lightweight Locked |\n|------------------------------------------------------------------------------|--------------------|\n|                     ptr_to_heavyweight_monitor:62                   | lock:2 | Heavyweight Locked |\n|------------------------------------------------------------------------------|--------------------|\n|                                                                     | lock:2 |    Marked for GC   |\n|------------------------------------------------------------------------------|--------------------|\n```\n\nlock:2 位的锁状态标记位，由于希望用尽可能少的二进制位表示尽可能多的信息，所以设置了 lock 标记。该标记的值不同，整个 mark word 表示的含义不同。\n\n| biased_lock | Tlock |     状态 |\n| :---------- | :---: | -------: |\n| 0           |  01   |     无锁 |\n| 1           |  01   |   偏向锁 |\n| 0           |  00   | 轻量级锁 |\n| 0           |  10   | 重量级锁 |\n| 0           |  11   |  GC 标记 |\n\n1. biased_lock`：对象是否启用偏向锁标记，只占 1 个二进制位。为 1 时表示对象启用偏向锁，为 0 时表示对象没有偏向锁。\n\n2. `age`：4 位的 `Java` 对象年龄。在 `GC` 中，如果对象在 `Survivor` 区复制一次，年龄增加 1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行 `GC` 的年龄阈值为 15，并发 `GC` 的年龄阈值为 6。由于 `age` 只有 4 位，所以最大值为 15，这就是`-XX:MaxTenuringThreshold` 选项最大值为 15 的原因。\n\n3. `identity_hashcode`：25 位的对象标识 `Hash` 码，采用延迟加载技术。调用方法 `System.identityHashCode()`计算，并会将结果写到该对象头中。当对象被锁定时，该值会移动到管程 `Monitor` 中。\n\n4. `thread`：持有偏向锁的线程 `ID`。\n\n5. `epoch`：偏向时间戳。\n\n6. `ptr_to_lock_record`：指向栈中锁记录的指针。\n\n7. `ptr_to_heavyweight_monitor`：指向管程 `Monitor` 的指针。\n\n### class pointer\n\n这一部分用于存储对象的类型指针，该指针指向它的类元数据，`JVM` 通过这个指针确定对象是哪个类的实例。该指针的位长度为 `JVM` 的一个字大小，即 32 位的 `JVM` 为 32 位，64 位的 `JVM` 为 64 位。\n\n### array length\n\n如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度，这部分数据的长度也随着 `JVM` 架构的不同而不同：32 位的 `JVM` 上，长度为 32 位；64 位 `JVM` 则为 64 位。64 位 `JVM` 如果开启`+UseCompressedOops` 选项，该区域长度也将由 64 位压缩至 32 位。\n\n## 数组下标寻址\n\n1. 首先根据栈上的指针找到该数组对象在内存中的位置`p`\n\n2. 判断`index`是否越界，即与数组对象头中存储的`array length`做比较\n\n3. 根据数组对象头的`class pointer`确定数组元素的内存占用长度`n`\n\n4. 根据数组对象头长度`base`和下标计算出访问的元素的内存位置，即`p+base+n*index`\n","tags":["array"],"categories":["java基础"]},{"title":"bitOperation","url":"%2F2019%2F10%2F19%2FbitOperation%2F","content":"\n在 Java 中，位运算符有很多，例如与`&`、非`~`、或`|`、异或`^`、移位`<<`和`>>`等。这些运算符在日常编码中很少会用到。\n\n在下面的一个例子中，会用到位掩码`BitMask`，其中包含大量的位运算。不只是在`Java`中，其他编写语言中也是可以使用的。\n\n例如，在一个系统中，用户一般有查询`Select`、新增`Insert`、修改`Update`、删除`Delete`四种权限，四种权限有多种组合方式，也就是有`16`中不同的权限状态（2 的 4 次方）。\n\n## `Permission`\n\n一般情况下会想到用四个`boolean`类型变量来保存：\n\n```java\npublic class Permission {\n    // 是否允许查询\n    private boolean allowSelect;\n    // 是否允许新增\n    private boolean allowInsert;\n    // 是否允许删除\n    private boolean allowDelete;\n    // 是否允许更新\n    private boolean allowUpdate;\n}\n```\n\n上面用四个 boolean 类型变量来保存每种权限状态。\n\n## `NewPermission`\n\n下面是另外一种方式，使用位掩码的话，用一个二进制数即可，每一位来表示一种权限，`0`表示无权限，`1`表示有权限。\n\n```java\npublic class NewPermission {\n    // 是否允许查询，二进制第1位，0表示否，1表示是\n    public static final int ALLOW_SELECT = 1 << 0; // 0001\n    // 是否允许新增，二进制第2位，0表示否，1表示是\n    public static final int ALLOW_INSERT = 1 << 1; // 0010\n    // 是否允许修改，二进制第3位，0表示否，1表示是\n    public static final int ALLOW_UPDATE = 1 << 2; // 0100\n    // 是否允许删除，二进制第4位，0表示否，1表示是\n    public static final int ALLOW_DELETE = 1 << 3; // 1000\n    // 存储目前的权限状态\n    private int flag；\n    /**\n        *  重新设置权限\n        */\n    public void setPermission(int permission) {\n        flag = permission;\n    }\n    /**\n        *  添加一项或多项权限\n        */\n    public void enable(int permission) {\n        flag |= permission;\n    }\n    /**\n        *  删除一项或多项权限\n        */\n    public void disable(int permission) {\n        flag &= ~permission;\n    }\n    /**\n        *  是否拥某些权限\n        */\n    public boolean isAllow(int permission) {\n        return (flag & permission) == permission;\n    }\n    /**\n        *  是否禁用了某些权限\n        */\n    public boolean isNotAllow(int permission) {\n        return (flag & permission) == 0;\n    }\n    /**\n        *  是否仅仅拥有某些权限\n        */\n    public boolean isOnlyAllow(int permission) {\n        return flag == permission;\n    }\n}\n\n```\n\n以上代码中，用四个常量表示了每个二进制位代码的权限项。\n\n例如：\n\n`ALLOW_SELECT = 1 << 0` 转成二进制就是`0001`，二进制第一位表示`Select`权限。\n`ALLOW_INSERT = 1 << 1` 转成二进制就是`0010`，二进制第二位表示`Insert`权限。\n\n`private int flag`存储了各种权限的启用和停用状态，相当于代替了`Permission`中的四个`boolean`类型的变量。\n\n用`flag`的四个二进制位来表示四种权限的状态，每一位的 0 和 1 代表一项权限的启用和停用，下面列举了部分状态表示的权限：\n\n| flag     | 删除 | 修改 | 新增 | 查询 |                                   |\n| -------- | ---- | ---- | ---- | ---- | --------------------------------- |\n| 1(0001)  | 0    | 0    | 0    | 1    | 只允许查询（即等于 ALLOW_SELECT） |\n| 2(0010)  | 0    | 0    | 1    | 0    | 只允许新增（即等于 ALLOW_INSERT） |\n| 4(0100)  | 0    | 1    | 0    | 0    | 只允许修改（即等于 ALLOW_UPDATE） |\n| 8(1000)  | 1    | 0    | 0    | 0    | 只允许删除（即等于 ALLOW_DELETE） |\n| 3(0011)  | 0    | 0    | 1    | 1    | 只允许查询和新增                  |\n| 0        | 0    | 0    | 0    | 0    | 四项权限都不允许                  |\n| 15(1111) | 1    | 1    | 1    | 1    | 四项权限都允许                    |\n\n使用位掩码的方式，只需要用一个大于或等于`0`且小于`16`的整数即可表示所有的 16 种权限的状态。\n\n此外，还有很多设置权限和判断权限的方法，需要用到位运算，例如：\n\n```java\npublic void enable(int permission) {\n    flag |= permission; // 相当于flag = flag | permission;\n}\n```\n\n调用这个方法可以在现有的权限基础上添加一项或多项权限。\n\n添加一项`Update`权限：\n\n```java\npermission.enable(NewPermission.ALLOW_UPDATE);\n```\n\n假设现有权限只有`Select`，也就是`flag`是`0001`。执行以上代码，`flag = 0001 | 0100`，也就是`0101`，便拥有了`Select`和`Update`两项权限。\n\n添加`Insert`、`Update`、`Delete`三项权限：\n\n```java\npermission.enable(NewPermission.ALLOW_INSERT\n    | NewPermission.ALLOW_UPDATE | NewPermission.ALLOW_DELETE);\n\n```\n\n`NewPermission.ALLOW_INSERT | NewPermission.ALLOW_UPDATE | NewPermission.ALLOW_DELETE`运算结果是`1110`。假设现有权限只有`Select`，也就是`flag`是`0001`。`flag = 0001 | 1110，也就是1111`，便拥有了这四项权限，相当于添加了三项权限。\n\n上面的设置如果使用最初的`Permission`类的话，就需要下面三行代码：\n\n```java\npermission.setAllowInsert(true);\npermission.setAllowUpdate(true);\npermission.setAllowDelete(true);\n```\n\n## 二者对比\n\n### 设置仅允许 Select 和 Insert 权限\n\nPermission\n\n```java\npermission.setAllowSelect(true);\npermission.setAllowInsert(true);\npermission.setAllowUpdate(false);\npermission.setAllowDelete(false);\n```\n\nNewPermission\n\n```java\npermission.setPermission(NewPermission.ALLOW_SELECT | NewPermission.ALLOW_INSERT);\n```\n\n### 判断是否允许 Select 和 Insert、Update 权限\n\n`Permission`\n\n```java\nif (permission.isAllowSelect() && permission.isAllowInsert() && permission.isAllowUpdate())\n```\n\n`NewPermission`\n\n```java\nif (permission. isAllow (NewPermission.ALLOW_SELECT\n    | NewPermission.ALLOW_INSERT | NewPermission.ALLOW_UPDATE))\n```\n\n### 判断是只否允许 Select 和 Insert 权限\n\n`Permission`\n\n```java\nif (permission.isAllowSelect() && permission.isAllowInsert()\n    && !permission.isAllowUpdate() && !permission.isAllowDelete())\n```\n\n`NewPermission`\n\n```java\nif (permission. isOnlyAllow (NewPermission.ALLOW_SELECT | NewPermission.ALLOW_INSERT))\n```\n\n二者对比可以感受到`MyPermission`位掩码方式相对于`Permission`的优势，可以节省很多代码量，位运算是底层运算，效率也非常高，而且理解起来也很简单。\n","tags":["bit"],"categories":["java"]},{"title":"genericsAndReflect","url":"%2F2019%2F10%2F19%2FgenericsAndReflect%2F","content":"\n## `void`类型的范型方法\n\n```java\nprivate <T> void set(T t) {\n  System.out.println(t);\n}\n```\n\n## `java`运行时无法捕获`ClassCastException`的解决办法\n\n```java\n private static <T> T get(Object o, T def) {\n   try {\n     return (T) def.getClass().cast(o);\n   } catch (Throwable e) {\n     return (T) def;\n   }\n }\n```\n\n通过查看字节码就可以了解,直接 `return (T) value` 是在方法外检测`cast`\n\n## 可变参数方法的反射\n\n```java\npublic static void me(Object ... objects){\n    for (Object object : objects) {\n        System.out.println(object);\n    }\n}\n@Test\npublic void  test() throws Exception {\n    Class clazz = this.getClass();\n    //Method method = clazz.getMethod(\"me\",(new Object[0]).getClass());\n    //Method method = clazz.getMethod(\"me\",Array.newInstance(Object.class,0).getClass());\n    Method method = clazz.getMethod(\"me\",Class.forName(\"[Ljava.lang.Object;\"));\n    //1\n    Object objs = Array.newInstance(object.class,2);\n    Array.set(objs,0,1);\n    Array.set(objs,1,\"test\");\n    method.invoke(clazz,objs);\n    //2\n    Object[] obj = {1,\"test\"}\n    method.invoke(clazz,new Object[]{obj});\n}\n```\n\n可变参数不可直接显式使用null作为参数\n\n```java\npublic class TestStatic {\n    public static void main(String[] args) {\n        String s = null;\n        m1(s);\n        Util.log(\"begin null\");\n        m1(null);\n    }\n\n    private static void m1(String... strs) {\n        System.out.println(strs.length);\n    }\n\n}\n```\n\n```java\n0: aconst_null          //将null压入操作栈\n1: astore_1             //弹出栈顶(null)存储到本地变量1\n2: iconst_1             //压栈1此时已经到方法m1了，在初始化参数，此值作为数组长度\n3: anewarray     #2     //新建数组            // class java/lang/String\n6: dup                  //复制数组指针引用\n7: iconst_0             //压栈0，作为数组0角标\n8: aload_1              //取本地变量1值压栈，作为数组0的值\n9: aastore              //根据栈顶的引用型数值（value）、数组下标（index）、数组引用（arrayref）出栈，将数值存入对应的数组元素中\n10: invokestatic  #3    //此时实际传递的是一个数组，只是0位置为null的元素 Method m1:([Ljava/lang/String;)V\n13: iconst_1\n14: anewarray     #4    //class java/lang/Object\n17: dup\n18: iconst_0\n19: ldc           #5    //String begin null\n1: aastore\n22: invokestatic  #6    //Method li/Util.log:([Ljava/lang/Object;)V\n25: aconst_null         //此处并没有新建数组操作，直接压栈null\n26: invokestatic  #3    //此处一定会抛出空指针  Method m1:([Ljava/lang/String;)V\n29: return\n```\n\n## 泛型 `extends super`\n\n```java\n//不管是extends或是super，只能使用在变量声明上，实际赋值的时候，一定是指定具体实现类的。\n\n//那么对于<? extends T>来说，具体的实现类的泛型A只是变量声明的泛型T的子类，如果以T进行插入时，是无法保证插入的class类型，一定是A，所以extends禁用插入动作\nList<Apple> apples = new ArrayList<Apple>();\nList<? extends Fruit> fruits = apples;\n// 对于<? super T>来说，具体的实现类的泛型A一定是变量声明的泛型T的父类，如果以T类型进入取值操作，无法保证取出的值一定是T类型，因为A一定是T的父类，所以插入的所有实例一定也是A的多态\n\nList<Fruit> fruits = new ArrayList<Fruit>();\nList<? super Apple> = fruits;\n```\n\n## 如何修改final修饰符的值\n\n```java\nString str = \"fuck\";\n\nField value = String.class.getDeclaredField(\"value\");\n//Field中包含当前属性的修饰符，通过改变修饰符的final属性，达到重新赋值的功能\nField modifier = Field.class.getDeclaredField(\"modifiers\");\nmodifier.setAccessible(true);\nmodifier.set(value, value.getModifiers() & ~Modifier.FINAL);\n\nvalue.setAccessible(true);\nvalue.set(str, \"notfuck\".toCharArray());\n//修改成功后重新加上final修饰符\nmodifier.set(value, value.getModifiers() | Modifier.FINAL);}\n```","tags":["泛型"],"categories":["java"]},{"title":"annotation","url":"%2F2019%2F10%2F19%2Fannotation%2F","content":"\n## 注解的原理\n\n注解本质是一个继承了`Annotation`的特殊接口，其具体实现类是`Java`运行时生成的动态代理类。而我们通过反射获取注解时，返回的是`Java`运行时生成的动态代理对象`$Proxy1`。通过代理对象调用自定义注解（接口）的方法，会最终调用`AnnotationInvocationHandler`的`invoke`方法。该方法会从`memberValues`这个`Map`中索引出对应的值。而`memberValues`的来源是`Java`常量池。\n\n## 元注解\n\n`java.lang.annotation`提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：\n\n### `Retention` 定义该注解的生命周期\n\n1. `RetentionPolicy.SOURCE` : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。`@Override`, `@SuppressWarnings`都属于这类注解。\n2. `RetentionPolicy.CLASS` : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式\n3. `RetentionPolicy.RUNTIME` : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。\n\n### `Target` 表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的`ElementType`参数包括\n\n1. `ElementType.CONSTRUCTOR`:用于描述构造器\n2. `ElementType.FIELD`:成员变量、对象、属性（包括`enum`实例）​​\n3. `ElementType.LOCAL_VARIABLE`:用于描述局部变量\n4. `ElementType.METHOD`:用于描述方法\n5. `ElementType.PACKAGE`:用于描述包\n6. `ElementType.PARAMETER`:用于描述参数\n7. `ElementType.TYPE`:用于描述类、接口(包括注解类型) 或`enum`声明\n\n### `Documented` 一个简单的`Annotations`标记注解，表示是否将注解信息添加在`java`文档中\n\n### `Inherited`  元注解是一个标记注解，`@Inherited`阐述了某个被标注的类型是被继承的。如果一个使用了`@Inherited`修饰的`annotation`类型被用于一个`class`，则这个`annotation`将被用于该`class`的子类\n\n## 自定义注解\n\n自定义注解类编写的一些规则:\n`Annotation`型定义为`@interface`, 所有的`Annotation`会自动继承`java.lang.Annotation`这一接口,并且不能再去继承别的类或是接口.\n参数成员只能用`public`或默认(`default`)这两个访问权修饰\n参数成员只能用基本类型`byte`,`short`,`char`,`int`,`long`,`float`,`double`,`boolean`八种基本数据类型和`String`、`Enum`、`Class`、`annotations`等数据类型,以及这一些类型的数组.\n要获取类方法和字段的注解信息，必须通过`Java`的反射技术来获取 `Annotation`对象,因为你除此之外没有别的获取注解对象的方法\n注解也可以没有定义成员, 不过这样注解就没啥用了PS:自定义注解需要使用到元注解\n\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.PARAMETER, ElementType.TYPE})\npublic @interface NotNull {\n}\n```\n","tags":["反射"],"categories":["java"]},{"title":"mac","url":"%2F2019%2F10%2F17%2Fmac%2F","content":"\nmac无法直接输入汉字,杀进程就行了\n\n`safari`连接不上网络,`sudo killall -9 networkd`\n\n## 命令\n\n`more 1.txt|pbcopy`  \n将文件内容复制到剪切板  \n`pbpaste >> 1.txt`  \n将剪切板内容复制到文件  \n`pandoc`  \nmarkdown转换为doc，pdf等  \n`ncdu`  \n查看当前目录文件大小  \n`mdfind`  \nspotlight搜索  \n`fzf`  \n模糊搜索工具,进入fzf模式  \n`enca`  \n字符集转码  \n`bwm-ng`  \n实时网速显示  \n`ag`  \n文本搜索工具  \n\n## 合并PDF\n\n```shell\n\"/System/Library/Automator/Combine PDF Pages.action/Contents/Resources/join.py\" -o  ~/Downloads/1.pdf    ~/*.pdf\n\n\"/System/Library/Automator/Combine PDF Pages.action/Contents/Resources/join.py\" -o  ~/Downloads/1.pdf    ~/1.pdf ~/2.pdf\n\n```\n\n## 打开`class`文件\n\n```shell\nvim -b XXX.class\n:%!xxd\n```\n","tags":["mac"],"categories":["mac"]},{"title":"sicp","url":"%2F2019%2F10%2F16%2Fsicp%2F","content":"\n## 如何学习一门新的编程语言\n\n1. 基本类型  \n\n2. 如何定义组合类型  \n\n3. 如何表示抽象  \n","tags":["lisp"],"categories":["sicp"]},{"title":"bash.md","url":"%2F2019%2F10%2F15%2Fbash-md%2F","content":"\n## 重定向符\n\n在`shell`中，每个进程都和三个系统文件 相关联：标准输入`stdin`，标准输出`stdout`、标准错误`stderr`，三个系统文件的文件描述符分别为`0，1、2`。所以这里`2>&1` 的意思就是将标准错误也输出到标准输出当中。\n\n`shell`中可能经常能看到：`echo log > /dev/null 2>&1`,命令的结果可以通过`%>`的形式来定义输出,`/dev/null` ：代表空设备文件\n\n_`1 > /dev/null 2>&1` 语句含义,_\n\n1. `1 > /dev/null` ： 首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。\n2. 2>&1 ：接着，标准错误输出重定向（等同于）标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。\n\n_`cmd >a 2>a` 和 `cmd >a 2>&1` 为什么不同？_\n\n1. `cmd >a 2>a` ：`stdout`和`stderr`都直接送往文件 `a` ，`a`文件会被打开两遍，由此导致`stdout`和`stderr`互相覆盖。`cmd >a 2>a` 相当于使用了`FD1`、`FD2`两个互相竞争使用文件 `a` 的管道；\n2. `cmd >a 2>&1` ：`stdout`直接送往文件`a`，`stderr`是继承了`FD1`的管道之后，再被送往文件`a` 。`a`文件只被打开一遍，就是`FD1`将其打开。`cmd >a 2>&1` 只使用了一个管道`FD1`，但已经包括了`stdout`和`stderr`。从`IO`效率上来讲，`cmd >a 2>&1`的效率更高。\n\n## 组合命令\n\n可通过`&&`,让多个命令顺序执行，也可以通过`;`,不同的地方为`&&`当前一个命令执行成功后，才会执行后一个命令\n例如\n\n```shell\ncd ~/Downloads/ && rm -rf temp`\n```\n\n## `rm`\n\n在使用`cd dir && rm -rf file`时需要注意，当`dir`不存在时，`rm`会直接删除当前目录的文件，因此`rm`后跟文件绝对路径\n\n## `ssh免密及执行远程命令`\n\n操作机上生成秘钥`ssh-keygen -t rsa`,将会生成一对秘钥，将公钥内容追加到服务器的`~/.ssh/authorized_keys`中，\n可通过**远程命令**`ssh user@example.com 'cat id_rsa.pub >> ~/.ssh/authorized_keys'`去执行,可以简单的使用`ssh-copy-id user@example.com`,这种方式\n采用的是默认的`22`端口，拷贝的公钥是默认的`id_rsa.pub`\n\n确保服务器的文件及目录权限\n\n1. 设置 authorized_keys 权限  \n   `chmod 600 authorized_keys`\n2. 设置.ssh 目录权限  \n   `chmod 700 -R .ssh`\n3. 设置用户目录权限  \n   `chomd go-w ~`\n\n后续再执行`ssh`操作，或者`scp`等操作，则不需要再输入密码\n\n通过系统日志文件我们可以查看无法登陆远程服务器的原因  \n`tail /var/log/secure -n 20`\n\n## 参数\n\n命令可以作为参数传入 shell 脚本中\n\n```shell\necho $1\necho $2\n$1 $2\n```\n\n## `CURL`\n\n```shell\nresponse=$(curl --write-out %{http_code} --silent --output /dev/null servername)\necho $response\n\n```\n\n## 搜索\n\n使用`**/`来递归搜索\n\n```shell\nls -a **/*.log\n```\n\n全局搜索`locate`\n\n递归查找指定文件的制定内容，显示文件名行号内容\n\n```shell\ngrep -rn 'stream' . --include='*.cpp'\n```\n\n## `XARGS`\n\n传递参数\n\n```shell\nls *.jar|xargs -I {} jadx {} -d src\n```\n\n## `svn`\n\n通过 `svn info`判断服务器和本地的版本号是否相同，可使用`grep`和`awk`组合\n\n## 用`wget`递归下载\n\n`wget -r -np --reject=html www.download.example`\n或者可以把`reject`换做 `--accept`=`iso,c,h`，表示只接受以此结尾的文件，分隔符为逗号`（comma-separated）`\n\n## `AWK`\n\n默认情况下`awk`以空格进行分割字符串，`-F`，可以指定分割符  \n`‘{print $1}’`，输出第几个分割字符\n\n截取除第一位之后的所有元素\n\n```shell\necho  1 2 3 4 5|awk '{first = $1; $1 = \"\"; print $0 }'\n```\n\n示例：\n\n```shell\nmore 1.txt|awk -F ',' '{print $2}'\n```\n\n## 其他\n\n命令查看当前目录下所有文件夹的大小 `-d` 指深度，后面加一个数值\n\n```shell\ndu -d 1 -h\n```\n\n将输出的每一行加上行号。例如：`'cat 1.txt | nl'`，输出`1.txt`的文件并加上行号\n\n排序`sort`\n\n去重`uniq`,`uniq`默认仅会比较相邻的字符串\n\n按文件大小顺序显示`ls -LS`\n\n快速删除大文件\n\n```shell\ncat /dev/null > access.log\n```\n","tags":["shell"],"categories":["linux"]},{"title":"python入门","url":"%2F2019%2F10%2F10%2Fpython%E5%85%A5%E9%97%A8%2F","content":"## class实例的方法，第一个参数自动转换为实例的索引\n\n第一个参数不一定非要是`self`\n\n## 类方法\n\n直接使用`Class.method(instance)`，参数需要显式的传递实例对象\n\n## python对重载运算符\n\n## 父类构造器\n\n`python`不会自动调用父类构造器,需要显式的调用\n\n```python\nclass SongBird(Bird):\n\n    def __init__(self):\n\n        Bird.__init__(self)\n\n        self.sound = 'Squawk'\n\n    def sing(self):\n\n        print self.sound\n\n```\n\n## class属性\n\n定义在`class`方法外的属性,`method`本身也属于`class`属性\n\n## 断言\n\n断言自定义提示信息\n\n```python\nassert x >= 0, 'x is less than zero'\n```\n\n## 更新`PIP`\n\n`python -m pip install -U pip`\n\n## `XML`解析\n\n```python\nimport xml.etree.ElementTree as ET\n\ntree = ET.parse(\"country.xml\")\nroot = tree.getroot()\nroot.tag\nroot.attrlib\n\nfind(match)    # 查找第一个匹配的子元素， match可以时tag或是xpaht路径\nfindall(match  # 返回所有匹配的子元素列表\nfindtext(match, default=None)\niter(tag=None) # 以当前元素为根节点 创建树迭代器,如果tag不为None,则以tag进行过滤\niterfind(match)\n\n```\n\n## 调用其他py文件方法\n\n```python\nimport other\n\nother.m()\n\n```\n\n## 动态调用方法\n\n在`py`文件中，可以使用\n\n```python\ndef func(arg1,arg2):\n    pass\n\nglobals()['func'](1,2)\n```\n\n调用`class`方法，可以使用\n\n```python\nclass Data:\n    def func(self,arg1,arg2):\n        pass\n\ndata = Data()\nfunc = getattr(data,'func')\nfunc(1,2)\n\n```\n\n## 字符串格式化\n\n`python`可以使用`''' str '''`,来进行纯字符串赋值，而不需要考虑转译字符。\n`python`字符串可定义占位符，通过`format`函数进行格式化\n\n```python\nprint('{}1{}'.format(0,3))\nprint('{a}1{b}'.format(** {\"a\":1,\"b\":3,}))\n\n```\n\n`json`格式化输出\n\n```python\nimport json\nstr = '{\"foo\":\"bar\",\"name\":\"he\"}'\nparsed = json.loads(str)\nprint(json.dumps(parsed,indent=4,sort_keys=True))\n```\n\n## 常用函数\n\n### `zip`将多个数组打包成元组\n\n```python\na = [1,2,3]\nb = [4,5,6,7,8]\nzipped =zip(a,b)       # 元素个数与最短的列表一致\nzip(*zipped)           # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式\n```\n\n### `enumerate`函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标\n\n```python\nenumerate(sequence, [start=0])\n\nseasons = ['Spring', 'Summer', 'Fall', 'Winter']\nlist(enumerate(seasons))\n#[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]\n```\n\n## 返回多个值\n\n```python\ndef multi():\n    return 1,2\n\nx,y = multi()\n\n```\n\n实际上python返回的是一个`tulpe`，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便.\n","tags":["python"],"categories":["python"]},{"title":"jquery相关","url":"%2F2019%2F09%2F10%2Fjquery%E7%9B%B8%E5%85%B3%2F","content":"\n## 引入公共页面\n\n```html\n<div id=\"header\"></div>\n```\n\n```js\n$(\"#header\").load(\"header.html\")\n```\n","tags":["html"],"categories":["html"]},{"title":"vue入门","url":"%2F2019%2F09%2F08%2Fvue%E5%85%A5%E9%97%A8%2F","content":"\n## `npm`\n\n1. `nodejs`的包管理器，用于node插件管理，包括安装，卸载，管理依赖等\n2. `-g` 全局安装,可通过`npm root -g`查看全局安装的包目录\n3. `-S` `-s` `--save` 将安装包信息加入到`dependencies`\n4. `-D` `-d` `--save --dev` 将安装包信息加入`devDependencies`\n5. `i` `install`\n6. `npm init -f` 初始化，生成`package.json`  \n\n## 安装`vue-cli`\n\n`npm i -gD vue-cli`\n\n## 创建项目\n\n`vue init webpack projectname`,`webpack`表示模板，项目名必须全部小写,安装过程中注意`vue-router`选择`Y`\n项目安装失败，尝试重新安装`vue-cli`\n\n## 启动项目\n\n`npm run dev`\n\n## `package.json`\n\n模块描述文件，类似`maven`的`pom.xml`文件\n\n`name` - 包名.\n`version` - 包的版本号。\n`description` - 包的描述。\n`homepage` - 包的官网URL。\n`author` - 包的作者。\n`contributors` - 包的其他贡献者。\n`dependencies` / devDependencies - 生产/开发环境依赖包列表。它们将会被安装在 node_module 目录下。\n`repository` - 包代码的Repo信息，包括type和URL，type可以是git或svn，URL则是包的Repo地址。\n`main - main` 字段指定了程序的主入口文件，require('moduleName') 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。\n`keywords` - 关键字\n\n## 路由\n\n`<router-view>`挂载路由，默认挂载`/`  \n`<router-link on='/xxx'>`路由跳转，渲染后既是`<a>`  \n`mode: 'history'`使用历史模式，即`url`不以`#`跳转页面\n\n### 配置路由\n\n模块`A.vue`\n\n```html\n<router-link to=\"/b\">xxx</router-link>\n<router-view></router-view>\n```\n\n路由配置\n\n```javascript\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport A from './components/A.vue'\nimport B from './components/B.vue'\n\nVue.use(Router)\n\nexport default new Router({\n  mode: 'history',\n  base: process.env.BASE_URL,\n  routes: [\n    {\n      path: '/',\n      component: A,\n      children:[\n        {\n          path: '/b',\n          component: B,\n        }\n      ]\n    }\n  ]\n})\n```\n\n在模块中使用`<router-view>`,同时在关于模块中的路由配置需要配置`children`实现挂载页面，效果既是在跳转`b`时，`A`模块会作为公共模块依然存在\n\n## 手动创建`vue`项目\n\n1. `npm install`会生成`package-lock.json`文件  \n2. `npm init -f`会生成`package.json`文件  \n3. 安装`vue`需要的依赖，`npm i vue-router -D`\n\n## `vue3`\n\n安装 `npm i -g @vue/cli`\n图像界面`vue ui`\n创建项目 `vue create projectname`  \n启动项目 `npm run serve`  \n\n> safari浏览器缓存的问题，页面刷新不及时，使用chrome去调试\n\n## 引入`css`\n\n在需要加入的模块引入\n\n```css\n<style>\n@import url(../../public/vue.css);\n</style>\n```\n\n在`index.html`首页添加，全局有效  \n","tags":["npm"],"categories":["vue"]},{"title":"log4j日志问题","url":"%2F2019%2F09%2F05%2Flog4j%E6%97%A5%E5%BF%97%E9%97%AE%E9%A2%98%2F","content":"\n## 问题描述\n\n应用中需要将多个`logger`的日志输出到同一个文件中，且需要根据时间每天自动分割文件。我们使用`DailyRollingFileAppender`\n配置如下\n\n```properties\n# 开启log4j的日志\nlog4j.debug=true\nlog4j.rootLogger=error, stdout\nlog4j.logger.l1=DEBUG, fuck1\nlog4j.logger.l2=DEBUG, fuck2\n\n#l1\nlog4j.appender.fuck1=org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.fuck1.DatePattern='.'-yyyy-MM-dd-HH-mm\nlog4j.appender.fuck1.layout=org.apache.log4j.PatternLayout\nlog4j.appender.fuck1.File=/Users/li/Downloads/log4j/log4j.log\nlog4j.appender.fuck1.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n\n\n#l2\nlog4j.appender.fuck2=org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.fuck2.DatePattern='.'-yyyy-MM-dd-HH-mm\nlog4j.appender.fuck2.layout=org.apache.log4j.PatternLayout\nlog4j.appender.fuck2.File=/Users/li/Downloads/log4j/log4j.log\nlog4j.appender.fuck2.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n\n\n```\n\n测试代码我使用`Spring`的`Scheduled`\n\n```java\npackage com.li.springboot.util;\n\nimport org.apache.log4j.Logger;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class ScheduledTask {\n\n    Logger logger = Logger.getLogger(\"l1\");\n    Logger logger2 = Logger.getLogger(\"l2\");\n    private int index = 0;\n\n    @Scheduled(cron = \"*/1 * * * * *\")\n    public void log() {\n        logger.info(\"--------------------\" + index++);\n        logger2.debug(\"--------------------\" + index++);\n    }\n\n}\n\n```\n\n`*/1 * * * * *`表示每秒执行一次  \n\n`log4j.appender.fuck1.DatePattern='.'-yyyy-MM-dd-HH-mm`表示每分钟分割一次文件  \n\n在执行定时任务到底切割点时，我们可以观察到日志输出\n\n`log4j`自身的日志一定输出在`System.out`中\n\n```log\n2019-09-05 21:16:59 DEBUG l2:22 - --------------------44\nlog4j: /Users/li/Downloads/log4j/log4j.log -> /Users/li/Downloads/log4j/log4j.log.-2019-09-05-21-16\nlog4j: setFile called: /Users/li/Downloads/log4j/log4j.log, true\nlog4j: setFile ended\n2019-09-05 21:17:00 INFO  l1:21 - --------------------45\nlog4j: /Users/li/Downloads/log4j/log4j.log -> /Users/li/Downloads/log4j/log4j.log.-2019-09-05-21-16\nlog4j: setFile called: /Users/li/Downloads/log4j/log4j.log, true\nlog4j: setFile ended\n2019-09-05 21:17:00 DEBUG l2:22 - --------------------46\n```\n\n我们观察下源码分析下这个过程\n\n```java\n  protected void subAppend(LoggingEvent event) {\n    long n = System.currentTimeMillis();\n    //检测当前时间点是否需要分割文件\n    if (n >= nextCheck) {\n      now.setTime(n);\n      nextCheck = rc.getNextCheckMillis(now);\n      try {\n        rollOver();\n      }\n      catch(IOException ioe) {\n          if (ioe instanceof InterruptedIOException) {\n              Thread.currentThread().interrupt();\n          }\n        LogLog.error(\"rollOver() failed.\", ioe);\n      }\n    }\n    super.subAppend(event);\n   }\n}\n\nvoid rollOver() throws IOException {\n\n    /* Compute filename, but only if datePattern is specified */\n    if (datePattern == null) {\n      errorHandler.error(\"Missing DatePattern option in rollOver().\");\n      return;\n    }\n\n    String datedFilename = fileName+sdf.format(now);\n    // It is too early to roll over because we are still within the\n    // bounds of the current interval. Rollover will occur once the\n    // next interval is reached.\n    if (scheduledFilename.equals(datedFilename)) {\n      return;\n    }\n\n    // close current file, and rename it to datedFilename\n    this.closeFile();\n    //如果存在其他分割后的文件，则删除\n    File target  = new File(scheduledFilename);\n    if (target.exists()) {\n      target.delete();\n    }\n\n    File file = new File(fileName);\n    //将当前日志文件改名为代日期的文件\n    boolean result = file.renameTo(target);\n    if(result) {\n      LogLog.debug(fileName +\" -> \"+ scheduledFilename);\n    } else {\n      LogLog.error(\"Failed to rename [\"+fileName+\"] to [\"+scheduledFilename+\"].\");\n    }\n\n    try {\n      // This will also close the file. This is OK since multiple\n      // close operations are safe.\n      //将log4j日志的输出重定向为不带日期的文件\n      this.setFile(fileName, true, this.bufferedIO, this.bufferSize);\n    }\n    catch(IOException e) {\n      errorHandler.error(\"setFile(\"+fileName+\", true) call failed.\");\n    }\n    scheduledFilename = datedFilename;\n  }\n\n```\n\n1. `logger`的日志在`logger2`之前，因此先触发`rollOver`,此时没有文件`log4j.log.-2019-09-05-21-16`,将`log4j.log`重命名为`log4j.log.-2019-09-05-21-16`,并将`logger`的日志流重定向为`log4j.log`\n\n2. 紧接着`logger2`的日志流触发`rollOver`,此时会将`log4j.log.-2019-09-05-21-16`删除，同时将`log4j.log`重命名为`log4j.log.-2019-09-05-21-16`，并将`logger2`的日志流重定向为`log4j.log`。此时`logger`的日志流就的文件名被改名了。\n\n3. 我们可以看出第一轮的日志被`logger2`触发的`rollOver`删除了，而`logger`的日志流输出到`上一轮`\n\n## 解决方案\n\n根据分析，我们确保`target.delete()`和`ile.renameTo(target)`只被执行一次，且其他`logger`在指定时间重新将日志流指向到最新的`log4j.log`即可。\n\n比如说简单的重写`DailyRollingFileAppender`,在`rollOver`代码处稍作修改\n\n```java\nFile target = new File(scheduledFilename);\n//当目标文件已经存在时，就说明已经被切割过了，则简单重定向即可\nif (!target.exists()) {\n    File file = new File(fileName);\n    boolean result = file.renameTo(target);\n    if (result) {\n        LogLog.debug(fileName + \" -> \" + scheduledFilename);\n    } else {\n        LogLog.error(\"Failed to rename [\" + fileName + \"] to [\" + scheduledFilename + \"].\");\n    }\n}\ntry {\n        this.setFile(fileName, true, this.bufferedIO, this.bufferSize);\n    } catch (IOException e) {\n        errorHandler.error(\"setFile(\" + fileName + \", true) call failed.\");\n}\n    scheduledFilename = datedFilename;\n```\n","tags":["log4j"],"categories":["log4j"]},{"title":"aop概念","url":"%2F2019%2F09%2F04%2Faop%E6%A6%82%E5%BF%B5%2F","content":"\n## 术语\n\n1. 连接点 `Join Point` java运行过程中的位置，对于`Spring`来说，表示允许使用切面的位置，它一般是指方法运行的过程，比如运行前，运行后，抛出异常等。\n2. 通知 `Advice` 在某连接点上执行的特殊操作\n3. 切入点 `PointCut` 切入点通过表达式来连接通知和连接点，确定连接点是否符合切入点表达式\n4. 目标类 `Target` 被切面切入的类\n5. 代理类 `AOP proxy` 实现切面的方式即实现目标类的代理类对象，对于`Spring`来说，通过`JDK`动态代理和`CGLIB`字节码代理\n6. 织入 `Weaving` 把切面应用到目标对象来创建新的代理对象的过程\n\n## `JDK`动态代理\n\n`JDK`动态代理仅支持代理接口(因为代理类继承`Proxy`，而`java`不支持多继承)。\b由`JDK`动态生成继承接口的子类，子类的所有方法调用都由创建代理类时使用的参数`java.lang.reflect.InvocationHandler`的`invoke`方法去完成。\n\n```java\npackage com.li.springboot.aop;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.function.Supplier;\n\npublic class DJKProxy<T> implements InvocationHandler {\n\n    private T t;\n\n    public DJKProxy(T t) {\n        this.t = t;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"method = \" + method);\n        return method.invoke(t, args);\n    }\n\n    public static void main(String[] args) {\n        //设置为true时，将会在项目跟目录生成代理类的源码\n        System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\");\n        Supplier supplier = () -> 1;\n        DJKProxy<Supplier> proxy = new DJKProxy<>(supplier);\n        Supplier proxyInstance = (Supplier) Proxy.newProxyInstance(DJKProxy.class.getClassLoader(), supplier.getClass().getInterfaces(), proxy);\n        Object result = proxyInstance.get();\n        System.out.println(\"proxyInstance = \" + proxyInstance);\n        System.out.println(\"result = \" + result);\n    }\n}\n\n```\n\n下面是自动生成的代理类反编译的源码\n\n```java\n//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by Fernflower decompiler)\n//\n\npackage com.sun.proxy;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.UndeclaredThrowableException;\nimport java.util.function.Supplier;\n\npublic final class $Proxy0 extends Proxy implements Supplier {\n    private static Method m1;\n    private static Method m2;\n    private static Method m3;\n    private static Method m0;\n\n    public $Proxy0(InvocationHandler var1) throws  {\n        super(var1);\n    }\n\n    public final boolean equals(Object var1) throws  {\n        try {\n            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});\n        } catch (RuntimeException | Error var3) {\n            throw var3;\n        } catch (Throwable var4) {\n            throw new UndeclaredThrowableException(var4);\n        }\n    }\n\n    public final String toString() throws  {\n        try {\n            return (String)super.h.invoke(this, m2, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final Object get() throws  {\n        try {\n            return (Object)super.h.invoke(this, m3, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final int hashCode() throws  {\n        try {\n            return (Integer)super.h.invoke(this, m0, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    static {\n        try {\n            m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\"));\n            m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\");\n            m3 = Class.forName(\"java.util.function.Supplier\").getMethod(\"get\");\n            m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\");\n        } catch (NoSuchMethodException var2) {\n            throw new NoSuchMethodError(var2.getMessage());\n        } catch (ClassNotFoundException var3) {\n            throw new NoClassDefFoundError(var3.getMessage());\n        }\n    }\n}\n```\n\n我们可以看到实际所有方法的调用都由`InvocationHandler`去调用，我们查看下`Proxy.newProxyInstance`的细节\n\n```java\n public static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n        throws IllegalArgumentException\n    {\n        Objects.requireNonNull(h);\n\n        final Class<?>[] intfs = interfaces.clone();\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);\n        }\n\n        /*\n         *  获取代理类class类型，也就是动态生成代理类的过程\n         */\n        Class<?> cl = getProxyClass0(loader, intfs);\n\n        /*\n         * Invoke its constructor with the designated invocation handler.\n         */\n        try {\n            if (sm != null) {\n                checkNewProxyPermission(Reflection.getCallerClass(), cl);\n            }\n            /**\n             * 获取使用InvocationHandler作为参数的构造器，并且实例化\n             */\n            final Constructor<?> cons = cl.getConstructor(constructorParams);\n            final InvocationHandler ih = h;\n            if (!Modifier.isPublic(cl.getModifiers())) {\n                AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        cons.setAccessible(true);\n                        return null;\n                    }\n                });\n            }\n            return cons.newInstance(new Object[]{h});\n        } catch (IllegalAccessException|InstantiationException e) {\n            throw new InternalError(e.toString(), e);\n        } catch (InvocationTargetException e) {\n            Throwable t = e.getCause();\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            } else {\n                throw new InternalError(t.toString(), t);\n            }\n        } catch (NoSuchMethodException e) {\n            throw new InternalError(e.toString(), e);\n        }\n    }\n\n```\n\n```java\n private static final WeakCache<ClassLoader, Class<?>[], Class<?>>\n        proxyClassCache = new WeakCache<>(new KeyFactory(), new ProxyClassFactory());\n\nprivate static Class<?> getProxyClass0(ClassLoader loader,\n                                        Class<?>... interfaces) {\n    if (interfaces.length > 65535) {\n        throw new IllegalArgumentException(\"interface limit exceeded\");\n    }\n    //根据接口返回代理类，当前classloader已经存在则直接返回缓存\n    return proxyClassCache.get(loader, interfaces);\n}\n```\n\n```java\npublic V get(K key, P parameter) {\n    Objects.requireNonNull(parameter);\n\n    expungeStaleEntries();\n\n    Object cacheKey = CacheKey.valueOf(key, refQueue);\n\n    ConcurrentMap<Object, Supplier<V>> valuesMap = map.get(cacheKey);\n    if (valuesMap == null) {\n        ConcurrentMap<Object, Supplier<V>> oldValuesMap\n            = map.putIfAbsent(cacheKey,\n                                valuesMap = new ConcurrentHashMap<>());\n        if (oldValuesMap != null) {\n            valuesMap = oldValuesMap;\n        }\n    }\n\n    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));\n    Supplier<V> supplier = valuesMap.get(subKey);\n    Factory factory = null;\n\n    while (true) {\n        if (supplier != null) {\n            V value = supplier.get();\n            if (value != null) {\n                return value;\n            }\n        }\n        if (factory == null) {\n            factory = new Factory(key, parameter, subKey, valuesMap);\n        }\n\n        if (supplier == null) {\n            supplier = valuesMap.putIfAbsent(subKey, factory);\n            if (supplier == null) {\n                supplier = factory;\n            }\n        } else {\n            if (valuesMap.replace(subKey, supplier, factory)) {\n                supplier = factory;\n            } else {\n                supplier = valuesMap.get(subKey);\n            }\n        }\n    }\n}\n\n```\n\n通过断点`debug`，我们可以得出`supplier`的类为`class java.lang.reflect.WeakCache$Factory`,查看其`get`方法，\n\n```java\npublic synchronized V get() { // serialize access\n    // re-check\n    Supplier<V> supplier = valuesMap.get(subKey);\n    if (supplier != this) {\n        // the loop\n        return null;\n    }\n    V value = null;\n    try {\n        //根据上面的代码可知valueFactory为ProxyClassFactory\n        value = Objects.requireNonNull(valueFactory.apply(key, parameter));\n    } finally {\n        if (value == null) { // remove us on failure\n            valuesMap.remove(subKey, this);\n        }\n    }\n    assert value != null;\n\n    CacheValue<V> cacheValue = new CacheValue<>(value);\n\n    if (valuesMap.replace(subKey, this, cacheValue)) {\n        reverseMap.put(cacheValue, Boolean.TRUE);\n    } else {\n        throw new AssertionError(\"Should not reach here\");\n    }\n    return value;\n}\n```\n\n查看`ProxyClassFactory`的`apply`方法，\n\n```java\n@Override\npublic Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {\n\n    Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);\n    for (Class<?> intf : interfaces) {\n        Class<?> interfaceClass = null;\n        try {\n            interfaceClass = Class.forName(intf.getName(), false, loader);\n        } catch (ClassNotFoundException e) {\n        }\n        if (interfaceClass != intf) {\n            throw new IllegalArgumentException(\n                intf + \" is not visible from class loader\");\n        }\n        if (!interfaceClass.isInterface()) {\n            throw new IllegalArgumentException(\n                interfaceClass.getName() + \" is not an interface\");\n        }\n        if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {\n            throw new IllegalArgumentException(\n                \"repeated interface: \" + interfaceClass.getName());\n        }\n    }\n\n    String proxyPkg = null;     // package to define proxy class in\n    int accessFlags = Modifier.PUBLIC | Modifier.FINAL;\n\n    for (Class<?> intf : interfaces) {\n        int flags = intf.getModifiers();\n        if (!Modifier.isPublic(flags)) {\n            accessFlags = Modifier.FINAL;\n            String name = intf.getName();\n            int n = name.lastIndexOf('.');\n            String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1));\n            if (proxyPkg == null) {\n                proxyPkg = pkg;\n            } else if (!pkg.equals(proxyPkg)) {\n                throw new IllegalArgumentException(\n                    \"non-public interfaces from different packages\");\n            }\n        }\n    }\n\n    if (proxyPkg == null) {\n        proxyPkg = ReflectUtil.PROXY_PACKAGE + \".\";\n    }\n\n    long num = nextUniqueNumber.getAndIncrement();\n    //代理类的类名 com.sun.proxy. + $Proxy + 1\n    String proxyName = proxyPkg + proxyClassNamePrefix + num;\n\n    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n        proxyName, interfaces, accessFlags);\n    try {\n        //加载类\n        return defineClass0(loader, proxyName,\n                            proxyClassFile, 0, proxyClassFile.length);\n    } catch (ClassFormatError e) {\n        throw new IllegalArgumentException(e.toString());\n    }\n}\n```\n\n```java\n private final static boolean saveGeneratedFiles =java.security.AccessController.doPrivileged(new GetBooleanAction(\"sun.misc.ProxyGenerator.saveGeneratedFiles\")).booleanValue();\npublic static byte[] generateProxyClass(final String name, Class<?>[] interfaces,int accessFlags){\n    ProxyGenerator gen = new ProxyGenerator(name, interfaces, accessFlags);\n    //生成类\n    final byte[] classFile = gen.generateClassFile();\n\n    if (saveGeneratedFiles) {//根据sun.misc.ProxyGenerator.saveGeneratedFiles决定是否输出代理类的文件\n        java.security.AccessController.doPrivileged(\n        new java.security.PrivilegedAction<Void>() {\n            public Void run() {\n                try {\n                    int i = name.lastIndexOf('.');\n                    Path path;\n                    if (i > 0) {\n                        Path dir = Paths.get(name.substring(0, i).replace('.', File.separatorChar));\n                        Files.createDirectories(dir);\n                        path = dir.resolve(name.substring(i+1, name.length()) + \".class\");\n                    } else {\n                        path = Paths.get(name + \".class\");\n                    }\n                    Files.write(path, classFile);\n                    return null;\n                } catch (IOException e) {\n                    throw new InternalError(\n                        \"I/O exception saving generated file: \" + e);\n                }\n            }\n        });\n    }\n\n    return classFile;\n}\n\n```\n\n```java\nprivate byte[] generateClassFile() {\n\n    /*\n     * 注册Object方法的代理方法\n     */\n    addProxyMethod(hashCodeMethod, Object.class);\n    addProxyMethod(equalsMethod, Object.class);\n    addProxyMethod(toStringMethod, Object.class);\n\n    /*\n     * 注解接口方法的代理方法\n     */\n    for (Class<?> intf : interfaces) {\n        for (Method m : intf.getMethods()) {\n            addProxyMethod(m, intf);\n        }\n    }\n\n    for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n        checkReturnTypes(sigmethods);\n    }\n\n    try {\n        // 生成默认构造器\n        methods.add(generateConstructor());\n\n        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n            for (ProxyMethod pm : sigmethods) {\n\n                // 生成静态变量target方法\n                fields.add(new FieldInfo(pm.methodFieldName,\n                    \"Ljava/lang/reflect/Method;\",\n                        ACC_PRIVATE | ACC_STATIC));\n\n                // 生成代理方法细节，即交由InvocationHandler调用，参数使用了静态属性target方法\n                methods.add(pm.generateMethod());\n            }\n        }\n\n        methods.add(generateStaticInitializer());\n\n    } catch (IOException e) {\n        throw new InternalError(\"unexpected I/O Exception\", e);\n    }\n\n    if (methods.size() > 65535) {\n        throw new IllegalArgumentException(\"method limit exceeded\");\n    }\n    if (fields.size() > 65535) {\n        throw new IllegalArgumentException(\"field limit exceeded\");\n    }\n\n    cp.getClass(dotToSlash(className));\n    cp.getClass(superclassName);\n    for (Class<?> intf: interfaces) {\n        cp.getClass(dotToSlash(intf.getName()));\n    }\n    cp.setReadOnly();\n    ByteArrayOutputStream bout = new ByteArrayOutputStream();\n    DataOutputStream dout = new DataOutputStream(bout);\n\n    try {\n                                    // u4 magic;\n        dout.writeInt(0xCAFEBABE);\n                                    // u2 minor_version;\n        dout.writeShort(CLASSFILE_MINOR_VERSION);\n                                    // u2 major_version;\n        dout.writeShort(CLASSFILE_MAJOR_VERSION);\n\n        cp.write(dout);             // (write constant pool)\n\n                                    // u2 access_flags;\n        dout.writeShort(accessFlags);\n                                    // u2 this_class;\n        dout.writeShort(cp.getClass(dotToSlash(className)));\n                                    // u2 super_class;\n        dout.writeShort(cp.getClass(superclassName));\n\n                                    // u2 interfaces_count;\n        dout.writeShort(interfaces.length);\n                                    // u2 interfaces[interfaces_count];\n        for (Class<?> intf : interfaces) {\n            dout.writeShort(cp.getClass(\n                dotToSlash(intf.getName())));\n        }\n\n                                    // u2 fields_count;\n        dout.writeShort(fields.size());\n                                    // field_info fields[fields_count];\n        for (FieldInfo f : fields) {\n            f.write(dout);\n        }\n\n                                    // u2 methods_count;\n        dout.writeShort(methods.size());\n                                    // method_info methods[methods_count];\n        for (MethodInfo m : methods) {\n            m.write(dout);\n        }\n\n                                        // u2 attributes_count;\n        dout.writeShort(0); // (no ClassFile attributes for proxy classes)\n\n    } catch (IOException e) {\n        throw new InternalError(\"unexpected I/O Exception\", e);\n    }\n\n    return bout.toByteArray();\n}\n\n```\n\n```java\n/**\n * 根据方法名，方法参数类型，方法返回类型，抛出异常来给fromClass增加方法\n */\nprivate void addProxyMethod(Method m, Class<?> fromClass) {\n    String name = m.getName();\n    Class<?>[] parameterTypes = m.getParameterTypes();\n    Class<?> returnType = m.getReturnType();\n    Class<?>[] exceptionTypes = m.getExceptionTypes();\n\n    String sig = name + getParameterDescriptors(parameterTypes);\n    List<ProxyMethod> sigmethods = proxyMethods.get(sig);\n    if (sigmethods != null) {\n        for (ProxyMethod pm : sigmethods) {\n            if (returnType == pm.returnType) {\n                List<Class<?>> legalExceptions = new ArrayList<>();\n                collectCompatibleTypes( exceptionTypes, pm.exceptionTypes, legalExceptions);\n                collectCompatibleTypes( pm.exceptionTypes, exceptionTypes, legalExceptions);\n                pm.exceptionTypes = new Class<?>[legalExceptions.size()];\n                pm.exceptionTypes = legalExceptions.toArray(pm.exceptionTypes);\n                return;\n            }\n        }\n    } else {\n        sigmethods = new ArrayList<>(3);\n        proxyMethods.put(sig, sigmethods);\n    }\n    sigmethods.add(new ProxyMethod(name, parameterTypes, returnType, exceptionTypes, fromClass));\n}\n```\n\n## `CGLIB`字节码代理\n\n示例\n\n```java\nimport org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.MethodInterceptor;\n\npublic class CGlibProxy {\n    public static void main(String[] args) {\n        //在指定目录下生成代理类的class文件\n        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, \"/Users/li/Downloads\");\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(Target.class);\n        enhancer.setCallback((MethodInterceptor) (target, method, objects, methodProxy) -> {\n            System.out.println(\"method : \" + method);\n            return methodProxy.invokeSuper(target, args);\n        });\n        Target target = (Target) enhancer.create();\n        target.log();\n    }\n\n}\n\npublic class Target {\n    public void log() {\n        System.out.println(\"target\");\n    }\n}\n```\n\n反编译生成的字节码\n\n```java\n//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by Fernflower decompiler)\n//\n\npackage com.li.springboot.aop;\n\nimport java.lang.reflect.Method;\nimport net.sf.cglib.core.ReflectUtils;\nimport net.sf.cglib.core.Signature;\nimport net.sf.cglib.proxy.Callback;\nimport net.sf.cglib.proxy.Factory;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\npublic class Target$$EnhancerByCGLIB$$1d0dbdbc extends Target implements Factory {\n    private boolean CGLIB$BOUND;\n    public static Object CGLIB$FACTORY_DATA;\n    private static final ThreadLocal CGLIB$THREAD_CALLBACKS;\n    private static final Callback[] CGLIB$STATIC_CALLBACKS;\n    private MethodInterceptor CGLIB$CALLBACK_0;\n    private static Object CGLIB$CALLBACK_FILTER;\n    private static final Method CGLIB$log$0$Method;\n    private static final MethodProxy CGLIB$log$0$Proxy;\n    private static final Object[] CGLIB$emptyArgs;\n    private static final Method CGLIB$equals$1$Method;\n    private static final MethodProxy CGLIB$equals$1$Proxy;\n    private static final Method CGLIB$toString$2$Method;\n    private static final MethodProxy CGLIB$toString$2$Proxy;\n    private static final Method CGLIB$hashCode$3$Method;\n    private static final MethodProxy CGLIB$hashCode$3$Proxy;\n    private static final Method CGLIB$clone$4$Method;\n    private static final MethodProxy CGLIB$clone$4$Proxy;\n\n    static void CGLIB$STATICHOOK1() {\n        CGLIB$THREAD_CALLBACKS = new ThreadLocal();\n        CGLIB$emptyArgs = new Object[0];\n        Class var0 = Class.forName(\"com.li.springboot.aop.Target$$EnhancerByCGLIB$$1d0dbdbc\");\n        Class var1;\n        Method[] var10000 = ReflectUtils.findMethods(new String[]{\"equals\", \"(Ljava/lang/Object;)Z\", \"toString\", \"()Ljava/lang/String;\", \"hashCode\", \"()I\", \"clone\", \"()Ljava/lang/Object;\"}, (var1 = Class.forName(\"java.lang.Object\")).getDeclaredMethods());\n        CGLIB$equals$1$Method = var10000[0];\n        CGLIB$equals$1$Proxy = MethodProxy.create(var1, var0, \"(Ljava/lang/Object;)Z\", \"equals\", \"CGLIB$equals$1\");\n        CGLIB$toString$2$Method = var10000[1];\n        CGLIB$toString$2$Proxy = MethodProxy.create(var1, var0, \"()Ljava/lang/String;\", \"toString\", \"CGLIB$toString$2\");\n        CGLIB$hashCode$3$Method = var10000[2];\n        CGLIB$hashCode$3$Proxy = MethodProxy.create(var1, var0, \"()I\", \"hashCode\", \"CGLIB$hashCode$3\");\n        CGLIB$clone$4$Method = var10000[3];\n        CGLIB$clone$4$Proxy = MethodProxy.create(var1, var0, \"()Ljava/lang/Object;\", \"clone\", \"CGLIB$clone$4\");\n        CGLIB$log$0$Method = ReflectUtils.findMethods(new String[]{\"log\", \"()V\"}, (var1 = Class.forName(\"com.li.springboot.aop.Target\")).getDeclaredMethods())[0];\n        CGLIB$log$0$Proxy = MethodProxy.create(var1, var0, \"()V\", \"log\", \"CGLIB$log$0\");\n    }\n\n    final void CGLIB$log$0() {\n        super.log();\n    }\n\n    public final void log() {\n        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;\n        if (var10000 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        if (var10000 != null) {\n            var10000.intercept(this, CGLIB$log$0$Method, CGLIB$emptyArgs, CGLIB$log$0$Proxy);\n        } else {\n            super.log();\n        }\n    }\n\n    final boolean CGLIB$equals$1(Object var1) {\n        return super.equals(var1);\n    }\n\n    public final boolean equals(Object var1) {\n        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;\n        if (var10000 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        if (var10000 != null) {\n            Object var2 = var10000.intercept(this, CGLIB$equals$1$Method, new Object[]{var1}, CGLIB$equals$1$Proxy);\n            return var2 == null ? false : (Boolean)var2;\n        } else {\n            return super.equals(var1);\n        }\n    }\n\n    final String CGLIB$toString$2() {\n        return super.toString();\n    }\n\n    public final String toString() {\n        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;\n        if (var10000 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        return var10000 != null ? (String)var10000.intercept(this, CGLIB$toString$2$Method, CGLIB$emptyArgs, CGLIB$toString$2$Proxy) : super.toString();\n    }\n\n    final int CGLIB$hashCode$3() {\n        return super.hashCode();\n    }\n\n    public final int hashCode() {\n        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;\n        if (var10000 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        if (var10000 != null) {\n            Object var1 = var10000.intercept(this, CGLIB$hashCode$3$Method, CGLIB$emptyArgs, CGLIB$hashCode$3$Proxy);\n            return var1 == null ? 0 : ((Number)var1).intValue();\n        } else {\n            return super.hashCode();\n        }\n    }\n\n    final Object CGLIB$clone$4() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    protected final Object clone() throws CloneNotSupportedException {\n        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;\n        if (var10000 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        return var10000 != null ? var10000.intercept(this, CGLIB$clone$4$Method, CGLIB$emptyArgs, CGLIB$clone$4$Proxy) : super.clone();\n    }\n\n    public static MethodProxy CGLIB$findMethodProxy(Signature var0) {\n        String var10000 = var0.toString();\n        switch(var10000.hashCode()) {\n        case -1097399887:\n            if (var10000.equals(\"log()V\")) {\n                return CGLIB$log$0$Proxy;\n            }\n            break;\n        case -508378822:\n            if (var10000.equals(\"clone()Ljava/lang/Object;\")) {\n                return CGLIB$clone$4$Proxy;\n            }\n            break;\n        case 1826985398:\n            if (var10000.equals(\"equals(Ljava/lang/Object;)Z\")) {\n                return CGLIB$equals$1$Proxy;\n            }\n            break;\n        case 1913648695:\n            if (var10000.equals(\"toString()Ljava/lang/String;\")) {\n                return CGLIB$toString$2$Proxy;\n            }\n            break;\n        case 1984935277:\n            if (var10000.equals(\"hashCode()I\")) {\n                return CGLIB$hashCode$3$Proxy;\n            }\n        }\n\n        return null;\n    }\n\n    public Target$$EnhancerByCGLIB$$1d0dbdbc() {\n        CGLIB$BIND_CALLBACKS(this);\n    }\n\n    public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) {\n        CGLIB$THREAD_CALLBACKS.set(var0);\n    }\n\n    public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) {\n        CGLIB$STATIC_CALLBACKS = var0;\n    }\n\n    private static final void CGLIB$BIND_CALLBACKS(Object var0) {\n        Target$$EnhancerByCGLIB$$1d0dbdbc var1 = (Target$$EnhancerByCGLIB$$1d0dbdbc)var0;\n        if (!var1.CGLIB$BOUND) {\n            var1.CGLIB$BOUND = true;\n            Object var10000 = CGLIB$THREAD_CALLBACKS.get();\n            if (var10000 == null) {\n                var10000 = CGLIB$STATIC_CALLBACKS;\n                if (var10000 == null) {\n                    return;\n                }\n            }\n\n            var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0];\n        }\n\n    }\n\n    public Object newInstance(Callback[] var1) {\n        CGLIB$SET_THREAD_CALLBACKS(var1);\n        Target$$EnhancerByCGLIB$$1d0dbdbc var10000 = new Target$$EnhancerByCGLIB$$1d0dbdbc();\n        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n        return var10000;\n    }\n\n    public Object newInstance(Callback var1) {\n        CGLIB$SET_THREAD_CALLBACKS(new Callback[]{var1});\n        Target$$EnhancerByCGLIB$$1d0dbdbc var10000 = new Target$$EnhancerByCGLIB$$1d0dbdbc();\n        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n        return var10000;\n    }\n\n    public Object newInstance(Class[] var1, Object[] var2, Callback[] var3) {\n        CGLIB$SET_THREAD_CALLBACKS(var3);\n        Target$$EnhancerByCGLIB$$1d0dbdbc var10000 = new Target$$EnhancerByCGLIB$$1d0dbdbc;\n        switch(var1.length) {\n        case 0:\n            var10000.<init>();\n            CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n            return var10000;\n        default:\n            throw new IllegalArgumentException(\"Constructor not found\");\n        }\n    }\n\n    public Callback getCallback(int var1) {\n        CGLIB$BIND_CALLBACKS(this);\n        MethodInterceptor var10000;\n        switch(var1) {\n        case 0:\n            var10000 = this.CGLIB$CALLBACK_0;\n            break;\n        default:\n            var10000 = null;\n        }\n\n        return var10000;\n    }\n\n    public void setCallback(int var1, Callback var2) {\n        switch(var1) {\n        case 0:\n            this.CGLIB$CALLBACK_0 = (MethodInterceptor)var2;\n        default:\n        }\n    }\n\n    public Callback[] getCallbacks() {\n        CGLIB$BIND_CALLBACKS(this);\n        return new Callback[]{this.CGLIB$CALLBACK_0};\n    }\n\n    public void setCallbacks(Callback[] var1) {\n        this.CGLIB$CALLBACK_0 = (MethodInterceptor)var1[0];\n    }\n\n    static {\n        CGLIB$STATICHOOK1();\n    }\n}\n\n```\n\n具体实现细节类似`JDK`动态代理，通过某种方式生成字节码文件。\n\n## `Spring`使用`AOP`\n\n通过`BeanPostProcessor`返回动态代理的`bean`,\n\n```java\n@Component\npublic class Target {\n    public void log() {\n        System.out.println(\"target\");\n    }\n}\n```\n\n```java\n@Component\npublic class AOPBeanPostProcessor implements BeanPostProcessor {\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        System.out.println(\"bean = \" + bean);\n        if(bean instanceof  Target){\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(bean.getClass());\n        enhancer.setCallback((MethodInterceptor) (target, method, args, methodProxy) -> {\n            System.out.println(\"BeanPostProcessor\");\n            return methodProxy.invokeSuper(target, args);\n        });\n        return enhancer.create();\n        }\n        return bean;\n    }\n}\n```\n","tags":["aop"],"categories":["java"]},{"title":"redis","url":"%2F2019%2F09%2F02%2Fredis%2F","content":"\nredis的备份文件dump.db在启动redis-server的目录下直接生成\n","tags":["redis"],"categories":["db"]},{"title":"log4j相关","url":"%2F2019%2F08%2F27%2Flog4j%E7%9B%B8%E5%85%B3%2F","content":"\n## DEBUG模式运行\n\n `log4j`的配置文件中配置`log4j.debug=true`即可开启\n\n## 概述\n\n`log4j`的`looger`是层级结构的，例如`com.li`是`com.li.springboot`的父类`logger`  \n可使用如下方式取出`logger`\n\n```java\npackage com.li.springboot.advice.log4j;\n\n\nimport org.apache.log4j.Logger;\n\npublic class LevelTest {\n    Logger logger= Logger.getLogger(LevelTest.class);\n    Logger logger= Logger.getLogger(\"com.li.springboot.advice.log4j.LevelTest\");\n}\n\n```\n\n`getLogger`根据参数`name`，在任意处取出的`logger`都是同一个\n`root logger`是所有`logger`的父类，一定存在但是它不能直接使用`getLogger`通过`name`取出。可使用如下方式取出\n\n```java\nLogger.getRootLogger()\n```\n\n可使用的日志级别`org.apache.log4j.Level`\n>`TRACE`,`DEBUG`,`INFO`,`WARN`,`ERROR` and `FATAL`\n\n当指定`name`的`logger`日志请求时，同时会将该请求转发至父类`logger`\n当`logger`没有对应的配置时，会找最近的父类配置，默认情况下`logger`配置会继承父类的配置，可通过设置`log4j.additivity.xxx=false`使其不继承(xxx是logger的name)\n\n## 配置\n\n1. 初始化Logger容器Hierarchy,设置根节点为RootLogger  \n\n2. 初始LoggerRepositorySelector(容器选择器)为默认的DefaultRepositorySelector,容器为Hierarchy  \n\n3. 读取系统属性log4j.defaultInitOverride,如果没有设置或者为false进行初始化,否则跳过初始化  \n\n4. 读取系统属性log4j.configuration(log4j文件路径配置),如果存在对应的文件,则得到URL.如果没有对应的文件,首先检查是否存在log4j.xml文件,如果存在,得到Log4j配置文件URL,如果不存在log4j.xml,继续检查是否存在log4j.properties文件,如果存在该文件,得到log4j配置文件的URL,否则提示没有发现配置文件。  \n\n5. 读取系统属性log4j.configuratorClass(自定义Configurator配置类全路径,一般不自定义)  \n\n6. 调用OptionConverter.selectAndConfigure(url, configuratorClassName,LogManager.getLoggerRepository()),初始化logger容器  \n\n### 扩展配置\n\n可使用`BasicConfigurator.resetConfiguration()`重置配置\n可使用`PropertyConfigurator.configure`指定其他配置文件\n\n### `tomcat`下的`log4j`\n\n当`log4j`的`jar`包在`tomcat`目录下的时候，使用`BasicConfigurator.resetConfiguration()`重置配置时，会修改`tomcat`下所有应用的日志打印，一般情况下\n我们在主应用里做配置，忽略其他应用的配置即可。但是当你发布其他应用时，触发`log4j`的初始化配置，则会影响到主应用，可能造成主应用日志不打印。这个时候我们通过`HierarchyEventListener`来监听`log4j`的配置是否被修改，来在其他应用重置配置时，重新触发主应用的配置加载过程即可。\n\n```java\nstatic {\n    Logger.getRootLogger().getLoggerRepository().addHierarchyEventListener(new HierarchyEventListener() {\n        @Override\n        public void addAppenderEvent(Category cat, Appender appender) {\n            LogLog.debug(\"add \" + cat.getName() + \"  \" + appender);\n            flag = false;\n        }\n        @Override\n        public void removeAppenderEvent(Category cat, Appender appender) {\n            //log4j配置被移除前的回调，此时配置还是生效的，所以这里重新加载是无效的，回调后就\n            //被重置了，所以需要在外面去重新加载，这里仅打一个标记\n            LogLog.debug(\"remove \" + cat.getName() + \"  \" + appender);\n            flag = true;\n        }\n    });\n}\n\npublic static void initLog4j() {\n    BasicConfigurator.resetConfiguration();\n    Properties properties = new Properties();\n    try {\n        properties.load(ClassLoader.getSystemResourceAsStream(\"mylog4j.properties\"));\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    PropertyConfigurator.configure(properties);\n}\n\nfor (int i = 0; i < cycle; i++) {\n    Thread.sleep(RandomUtils.nextInt(500, 1500));\n        if (flag) {\n            initLog4j();\n        }\n    logger.debug(\"123\");\n}\n```\n\n### `MDC`\n\n打造日志链路，`MDC`类似`ThreadLocal`类，根据线程存入一些数据，以供打印日志的时候输出(`%X{name}`)\n\n```java\nMDC.clear();\nMDC.put(\"session\", \"xxxx\");\n\n```\n\n```properties\nlog4j.appender.consoleAppender.layout.ConversionPattern=%X{session}}%m%n\n```\n","tags":["log4j"],"categories":["log"]},{"title":"spring循环依赖","url":"%2F2019%2F08%2F26%2Fspring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%2F","content":"\n## 概述\n\n一般只应用于单例模式\n示例代码\n\n```java\n@Component\n@Order(Ordered.HIGHEST_PRECEDENCE)\npublic class A {\n\n    @Autowired\n    B b;\n\n    public A() {\n        System.out.println(\"-------------A------------------\");\n    }\n    @PostConstruct\n    public void log(){\n\n        System.out.println(\"-------------B PostConstruct------------------\");\n    }\n}\n\n@Component\npublic class B {\n\n    @Autowired\n    A a;\n    public B() {\n        System.out.println(\"-------------A------------------\");\n    }\n    @PostConstruct\n    public void log(){\n\n        System.out.println(\"-------------B PostConstruct------------------\");\n    }\n}\n\n```\n\n`getBean(A)`->`instance(A)`->`autowired(B)`->`getBean(B)`->`instance(B)`->`autowired(A)`->循环依赖\n\n解决方案：\n    1.`A`首先调用构造函数`newInstance`，此时`A`的引用值已确定  \n    2. 将`A`的引用缓存，创建`B`时直接使用缓存的`A`的引用  \n\n则实际实例化过程大致如下：\n\n`getBean(A)`->`instance(A)`->`cache reference(A)`->`autowired(B)`->`getBean(B)`->`instance(B)`->`autowired(A)`->`get reference(A)`->`postConstruct(B)`->`postConstruct(A)`\n\n## 源码分析\n\n以`AnnotationConfigApplicationContext`的加载来举例\n\n`AppConfig`为配置类，不重要\n\n```java\nAnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n```\n\n省略其他过程直接看刷新\n\n```java\npublic AnnotationConfigApplicationContext(Class<?>... annotatedClasses) {\n    this();\n    register(annotatedClasses);\n    refresh();\n}\n```\n\n省略扫描过程，直接看bean加载的过程\n\n```java\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n    synchronized (this.startupShutdownMonitor) {\n        // Prepare this context for refreshing.\n        prepareRefresh();\n\n        // Tell the subclass to refresh the internal bean factory.\n        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n        // Prepare the bean factory for use in this context.\n        prepareBeanFactory(beanFactory);\n\n        try {\n            // Allows post-processing of the bean factory in context subclasses.\n            postProcessBeanFactory(beanFactory);\n\n            // Invoke factory processors registered as beans in the context.\n            invokeBeanFactoryPostProcessors(beanFactory);\n\n            // Register bean processors that intercept bean creation.\n            registerBeanPostProcessors(beanFactory);\n\n            // Initialize message source for this context.\n            initMessageSource();\n\n            // Initialize event multicaster for this context.\n            initApplicationEventMulticaster();\n\n            // Initialize other special beans in specific context subclasses.\n            onRefresh();\n\n            // Check for listener beans and register them.\n            registerListeners();\n\n            // 加载所有单例非懒加载的bean\n            finishBeanFactoryInitialization(beanFactory);\n\n            // Last step: publish corresponding event.\n            finishRefresh();\n        }\n```\n\n```java\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n    // Initialize conversion service for this context.\n    if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&\n            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\n        beanFactory.setConversionService(\n                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\n    }\n\n    // Register a default embedded value resolver if no bean post-processor\n    // (such as a PropertyPlaceholderConfigurer bean) registered any before:\n    // at this point, primarily for resolution in annotation attribute values.\n    if (!beanFactory.hasEmbeddedValueResolver()) {\n        beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal));\n    }\n\n    // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.\n    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);\n    for (String weaverAwareName : weaverAwareNames) {\n        getBean(weaverAwareName);\n    }\n\n    // Stop using the temporary ClassLoader for type matching.\n    beanFactory.setTempClassLoader(null);\n\n    // Allow for caching all bean definition metadata, not expecting further changes.\n    beanFactory.freezeConfiguration();\n\n    // 通过debug，一般情况下使用DefaultListableBeanFactory类\n    beanFactory.preInstantiateSingletons();\n}\n```\n\n`DefaultListableBeanFactory`类`preInstantiateSingletons`代码片段\n\n```java\nfor (String beanName : beanNames) {\n    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n    //非抽象类，单例，非延迟加载\n    if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\n        if (isFactoryBean(beanName)) {\n            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);\n            if (bean instanceof FactoryBean) {\n                final FactoryBean<?> factory = (FactoryBean<?>) bean;\n                boolean isEagerInit;\n                if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {\n                    isEagerInit = AccessController.doPrivileged((PrivilegedAction<Boolean>)\n                                    ((SmartFactoryBean<?>) factory)::isEagerInit,\n                            getAccessControlContext());\n                }\n                else {\n                    isEagerInit = (factory instanceof SmartFactoryBean &&\n                            ((SmartFactoryBean<?>) factory).isEagerInit());\n                }\n                if (isEagerInit) {\n                    getBean(beanName);\n                }\n            }\n        }\n        else {\n            getBean(beanName);\n        }\n    }\n}\n```\n\n通过`getBean`方法可以追踪到`org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String)`,然后\n`org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean`\n\n```java\nprotected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,\n                            @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException  \n\n    final String beanName = transformedBeanName(name);\n    Object bean;\n\n    //  单例的bean通过该方法获取\n    Object sharedInstance = getSingleton(beanName);\n```\n\n`DefaultSingletonBeanRegistry`\n\n```java\nprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);\n\npublic Object getSingleton(String beanName) {\n    return getSingleton(beanName, true);\n}\n\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n    //我们可以清晰的看到singleton的bean简单的bean存储在ConcurrentHashMap中\n    Object singletonObject = this.singletonObjects.get(beanName);\n    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n        synchronized (this.singletonObjects) {\n            singletonObject = this.earlySingletonObjects.get(beanName);\n            if (singletonObject == null && allowEarlyReference) {\n                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);\n                if (singletonFactory != null) {\n                    singletonObject = singletonFactory.getObject();\n                    this.earlySingletonObjects.put(beanName, singletonObject);\n                    this.singletonFactories.remove(beanName);\n                }\n            }\n        }\n    }\n    return singletonObject;\n}\n```\n\n首次创建`A`时，`singletonObject`肯定为`null`,`isSingletonCurrentlyInCreation`的代码很简单\n\n```java\npublic boolean isSingletonCurrentlyInCreation(String beanName) {\n    return this.singletonsCurrentlyInCreation.contains(beanName);\n}\n```\n\n我们只需要了解`singletonsCurrentlyInCreation`是何时被`add`，通过查看调用关系，最终可以发现`org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean`中\n\n```java\nif (mbd.isSingleton()) {\n    //getSingleton代码里调用beforeSingletonCreation方法将beanName加入singletonsCurrentlyInCreation\n    //lambda表达式createBean则创建bean\n    sharedInstance = getSingleton(beanName, () -> {\n        try {\n            return createBean(beanName, mbd, args);\n        } catch (BeansException ex) {\n            destroySingleton(beanName);\n            throw ex;\n        }\n    });\n    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n}\n ```\n\n继续回到`A`的创建，在`getSingleton`中未取到缓存是，`A`尝试`createBean`，也就是上述代码部分。\n追踪调用关系可以知道最终调用`org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])`后进入`org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean`\n\n节选片段\n\n```java\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)\n        throws BeanCreationException {\n\n    // 初始化bean\n    BeanWrapper instanceWrapper = null;\n    if (mbd.isSingleton()) {\n        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n    }\n    if (instanceWrapper == null) {\n        instanceWrapper = createBeanInstance(beanName, mbd, args);\n    }\n    final Object bean = instanceWrapper.getWrappedInstance();\n    Class<?> beanType = instanceWrapper.getWrappedClass();\n    if (beanType != NullBean.class) {\n        mbd.resolvedTargetType = beanType;\n    }\n\n    // Allow post-processors to modify the merged bean definition.\n    synchronized (mbd.postProcessingLock) {\n        if (!mbd.postProcessed) {\n            try {\n                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n            }\n            catch (Throwable ex) {\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"Post-processing of merged bean definition failed\", ex);\n            }\n            mbd.postProcessed = true;\n        }\n    }\n\n    boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n            isSingletonCurrentlyInCreation(beanName));\n    if (earlySingletonExposure) {\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Eagerly caching bean '\" + beanName +\n                    \"' to allow for resolving potential circular references\");\n        }\n        //将bean的引用缓存\n        addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n    }\n...\n```\n\n我们查看下`addSingletonFactory`的细节\n\n```java\nprotected void addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory) {\n    Assert.notNull(singletonFactory, \"Singleton factory must not be null\");\n    synchronized (this.singletonObjects) {\n        if (!this.singletonObjects.containsKey(beanName)) {\n            //根据beanName缓存可以取出bean的lambda中\n            this.singletonFactories.put(beanName, singletonFactory);\n            this.earlySingletonObjects.remove(beanName);\n            this.registeredSingletons.add(beanName);\n        }\n    }\n}\n```\n\n到这里`bean`通过构造器创建实例的过程结束了，但是`bean`在`spring`容器中的生命周期还未结束，后续发现`A`依赖`B`，则会去创建`B`，`B`在实例化后加载依赖时，会去创建`A`,不同的是在调用`DefaultSingletonBeanRegistry`的`getSingleton`时判断条件`isSingletonCurrentlyInCreation`时`A`已在创建过程中，那么就会去执行\n\n```java\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n    //我们可以清晰的看到singleton的bean简单的bean存储在ConcurrentHashMap中\n    Object singletonObject = this.singletonObjects.get(beanName);\n    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n        synchronized (this.singletonObjects) {\n            singletonObject = this.earlySingletonObjects.get(beanName);\n            if (singletonObject == null && allowEarlyReference) {\n                //根据前面的分析我们知道A的引用被缓存在此处。\n                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);\n                if (singletonFactory != null) {\n                    singletonObject = singletonFactory.getObject();\n                    this.earlySingletonObjects.put(beanName, singletonObject);\n                    this.singletonFactories.remove(beanName);\n                }\n            }\n        }\n    }\n    return singletonObject;\n}\n```\n\n此时`B`顺利完成整个`Spring`生命周期，从而`A`也完成了整个生命周期\n","tags":["源码"],"categories":["spring"]},{"title":"spring-ioc 源码","url":"%2F2019%2F08%2F26%2Fspring-ioc-%E6%BA%90%E7%A0%81%2F","content":"\n## `BeanDefinition`\n\n`BeanDefinition`是`Spring`用来定义一个类的元数据，它定义了\n\n    1. 如何创建一个`Bean`\n\n    2. `Bean`的生命周期\n\n    3. `Bean`的依赖关系\n\n详细属性值如下图所示：\n\n![BeanDefinition](/images/spring-ioc-源码_BeanDefinition.png)\n\n`Spring`在扫描类后将类的`BeanDefiniton`元数据存储在`BeanFactory`中，当需要时，`BeanFactory`根据`BeanDefinition`信息生成`Bean`\n","tags":["源码"],"categories":["spring"]},{"title":"Spring上传文件","url":"%2F2019%2F08%2F21%2FSpring%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%2F","content":"\n## MultipartResolver\n\n`DispatcherServlet`用于处理所有请求\b，\b`doDispatch`方法中会判断请求参数中是否包含文件。\n\n```java\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    HttpServletRequest processedRequest = request;\n    HandlerExecutionChain mappedHandler = null;\n    boolean multipartRequestParsed = false;\n\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n    try {\n        ModelAndView mv = null;\n        Exception dispatchException = null;\n\n        try {\n            processedRequest = checkMultipart(request);\n            multipartRequestParsed = (processedRequest != request);\n\n            // Determine handler for the current request.\n            mappedHandler = getHandler(processedRequest);\n            if (mappedHandler == null) {\n                noHandlerFound(processedRequest, response);\n                return;\n            }\n\n    ...\n}\n```\n\n查看`checkMultipart`细节\n\n```java\nprotected HttpServletRequest checkMultipart(HttpServletRequest request) throws MultipartException {\n    if (this.multipartResolver != null && this.multipartResolver.isMultipart(request)) {\n        if (WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class) != null) {\n            if (request.getDispatcherType().equals(DispatcherType.REQUEST)) {\n                logger.trace(\"Request already resolved to MultipartHttpServletRequest, e.g. by MultipartFilter\");\n            }\n        }\n        else if (hasMultipartException(request)) {\n            logger.debug(\"Multipart resolution previously failed for current request - \" +\n                    \"skipping re-resolution for undisturbed error rendering\");\n        }\n        else {\n            try {\n                return this.multipartResolver.resolveMultipart(request);\n            }\n            catch (MultipartException ex) {\n                if (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) != null) {\n                    logger.debug(\"Multipart resolution failed for error dispatch\", ex);\n                    // Keep processing error dispatch with regular request handle below\n                }\n                else {\n                    throw ex;\n                }\n            }\n        }\n    }\n    // If not returned before: return original request.\n    return request;\n}\n```\n\n首先我们了解下`this.multipartResolver`是如何被加载的\n\n我们可以看到`DispatcherServlet`的方法中有初始化\n\n```java\nprivate void initMultipartResolver(ApplicationContext context) {\n    try {\n        this.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Detected \" + this.multipartResolver);\n        }\n        else if (logger.isDebugEnabled()) {\n            logger.debug(\"Detected \" + this.multipartResolver.getClass().getSimpleName());\n        }\n    }\n    catch (NoSuchBeanDefinitionException ex) {\n        // Default is no multipart resolver.\n        this.multipartResolver = null;\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"No MultipartResolver '\" + MULTIPART_RESOLVER_BEAN_NAME + \"' declared\");\n        }\n    }\n}\n```\n\n通过查看`MultipartResolver`的实现类，我们可以看到如下两个实现类\n\n1. `CommonsMultipartResolver`\n2. `StandardServletMultipartResolver`\n\n其中`StandardServletMultipartResolver`在下述自动配置类中有被加载\n\n```java\npackage org.springframework.boot.autoconfigure.web.servlet;\n\nimport javax.servlet.MultipartConfigElement;\nimport javax.servlet.Servlet;\n\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication.Type;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.multipart.MultipartResolver;\nimport org.springframework.web.multipart.commons.CommonsMultipartResolver;\nimport org.springframework.web.multipart.support.StandardServletMultipartResolver;\nimport org.springframework.web.servlet.DispatcherServlet;\n\n@Configuration\n@ConditionalOnClass({ Servlet.class, StandardServletMultipartResolver.class, MultipartConfigElement.class })\n@ConditionalOnProperty(prefix = \"spring.servlet.multipart\", name = \"enabled\", matchIfMissing = true)\n@ConditionalOnWebApplication(type = Type.SERVLET)\n@EnableConfigurationProperties(MultipartProperties.class)\npublic class MultipartAutoConfiguration {\n\nprivate final MultipartProperties multipartProperties;\n\n    public MultipartAutoConfiguration(MultipartProperties multipartProperties) {\n        this.multipartProperties = multipartProperties;\n    }\n\n    @Bean\n    @ConditionalOnMissingBean({ MultipartConfigElement.class, CommonsMultipartResolver.class })\n    public MultipartConfigElement multipartConfigElement() {\n        return this.multipartProperties.createMultipartConfig();\n    }\n\n    @Bean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)\n    @ConditionalOnMissingBean(MultipartResolver.class)\n    public StandardServletMultipartResolver multipartResolver() {\n        StandardServletMultipartResolver multipartResolver = new StandardServletMultipartResolver();\n        multipartResolver.setResolveLazily(this.multipartProperties.isResolveLazily());\n        return multipartResolver;\n    }\n\n}\n\n```\n\n可以看出若没有指定`MultipartResolver`时，会默认加载`StandardServletMultipartResolver`。我们查看其`isMultipart`放过可知\n当请求`ContentType`类型以`multipart/`则会认为是文件上传操作。\n\n```java\n@Override\npublic boolean isMultipart(HttpServletRequest request) {\n    return StringUtils.startsWithIgnoreCase(request.getContentType(), \"multipart/\");\n}\n```\n\n## 解决上传文件大小限制\n\n同时我们也可以得出，若没有指定的`MultipartConfigElement`时，会使用默认的`this.multipartProperties.createMultipartConfig()`\n\n通过查看`this.multipartProperties`\n\n```java\n@ConfigurationProperties(prefix = \"spring.servlet.multipart\", ignoreUnknownFields = false)\npublic class MultipartProperties {\n    ...\n}\n```\n\n`MultipartProperties`被自动`EnableConfigurationProperties`所引用\n\n```java\n@Configuration\n@ConditionalOnClass({ Servlet.class, StandardServletMultipartResolver.class, MultipartConfigElement.class })\n@ConditionalOnProperty(prefix = \"spring.servlet.multipart\", name = \"enabled\", matchIfMissing = true)\n@ConditionalOnWebApplication(type = Type.SERVLET)\n@EnableConfigurationProperties(MultipartProperties.class)\npublic class MultipartAutoConfiguration {\n}\n```\n\n则可通过修改对应`SpringBoot`可以配置`application.yml`\n\n```yaml\nspring:\n  servlet:\n    multipart:\n      max-file-size: 150MB\n      max-request-size: 150MB\n```\n\n## `EnableConfigurationProperties`原理\n\n通过查看注解`EnableConfigurationProperties`被调用处，即查找`EnableConfigurationProperties.class`出现处。我们可以看到在`EnableConfigurationPropertiesImportSelector`的方法\n\n```java\nprivate List<Class<?>> getTypes(AnnotationMetadata metadata) {\n        MultiValueMap<String, Object> attributes = metadata\n                .getAllAnnotationAttributes(EnableConfigurationProperties.class.getName(), false);\n        return collectClasses((attributes != null) ? attributes.get(\"value\") : Collections.emptyList());\n    }\n```\n\n所有注解了`EnableConfigurationProperties`的类被自动注入到容器中了。\n\n```java\n@Override\npublic void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {\n    getTypes(metadata).forEach((type) -> register(registry, (ConfigurableListableBeanFactory) registry, type));\n}\n```\n\n```java\nprivate void register(BeanDefinitionRegistry registry, ConfigurableListableBeanFactory beanFactory,\n            Class<?> type) {\n        String name = getName(type);\n        if (!containsBeanDefinition(beanFactory, name)) {\n            registerBeanDefinition(registry, name, type);\n        }\n    }\n\n```\n\n一步一步回溯可以最终可以看到被`AbstractApplicationContext`的`refresh`方法调用。\n","tags":["EnableConfigurationProperties"],"categories":["spring"]},{"title":"静态内部类的泛型与建造者模式","url":"%2F2019%2F08%2F20%2F%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F","content":"\n静态内部类的泛型和外部类的泛型没有任何关系，即使使用同一个字母。\n\n```java\npackage com.li.springboot.bean;\n\nimport java.util.List;\n\npublic class LayuiResponse<T> {\n\n    private final int code;\n    private final String msg;\n    private final List<T> data;\n    private final Integer count;\n\n    public int getCode() {\n        return code;\n    }\n\n    public String getMsg() {\n        return msg;\n    }\n\n    public List<T> getData() {\n        return data;\n    }\n\n    public int getCount() {\n        return count;\n    }\n\n    public static <T> Builder<T> builder() {\n        return new Builder<T>();\n    }\n\n    private LayuiResponse(Builder<T> builder) {\n        this.code = builder.code;\n        this.msg = builder.msg;\n        this.data = builder.data;\n        this.count = builder.count;\n    }\n\n    public static class Builder<R> {\n        private int code;\n        private String msg;\n        private List<R> data;\n        private Integer count;\n\n        public Builder<R> code(int code) {\n            this.code = code;\n            return this;\n        }\n\n        public Builder<R> msg(String msg) {\n            this.msg = msg;\n            return this;\n        }\n\n        public Builder<R> data(List<R> data) {\n            this.data = data;\n            return this;\n        }\n\n        public Builder<R> count(int count) {\n            this.count = count;\n            return this;\n        }\n\n        public LayuiResponse<R> build() {\n            return new LayuiResponse<>(this);\n        }\n    }\n}\n\n```\n\n使用时，需指定内部类的泛型\n\n```java\n List<String> list = new ArrayList<>();\nlist.add(\"123\");\nLayuiResponse<String> ok = LayuiResponse.<String>builder().code(0).msg(\"ok\").data(list).build();\n```\n\n使用构造器模式，主要是为了使属性在构建时一次性初始化好，不允许中间过程去设置属性，保持`bean`的状态一致性。同时也是为了清晰化构建过程。推荐使用`final`来修饰被构建对象的属性值，\n确保成员属性不会被赋值。\n","tags":["generic"],"categories":["pattern"]},{"title":"SpringBoot自定义扫描器","url":"%2F2019%2F08%2F18%2FSpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%AB%E6%8F%8F%E5%99%A8%2F","content":"\n实现自定义注解扫描器，将被`JsonBean`注解的类，注入到`spring`容器中，当由`spring`生成时，自动根据对应的`json`文件自动生成。\n\n首先是两个注解\n\n```java\n\nimport java.lang.annotation.*;\n\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface JsonBean {\n    String value();\n}\n\n\n\nimport com.li.ivr.test.scanner.JsonBeanRegistrar;\nimport org.springframework.context.annotation.Import;\n\nimport java.lang.annotation.*;\n\n@Target( ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import(JsonBeanRegistrar.class)\npublic @interface JsonBeanScanner {\n    String value();\n}\n\n```\n\n被注解类\n\n```java\npackage com.li.ivr.test.expression;\n\n\nimport com.li.ivr.test.annotation.JsonBean;\n\nimport java.util.Map;\n\n@JsonBean(\"/data.json\")\npublic class Session {\n\n    private Map<String,?> avaya;\n\n    public Map<String, ?> getAvaya() {\n        return avaya;\n    }\n\n    public void setAvaya(Map<String, ?> avaya) {\n        this.avaya = avaya;\n    }\n\n    @Override\n    public String toString() {\n        return \"Session{\" +\n            \"avaya=\" + avaya +\n            '}';\n    }\n}\n\n```\n\n核心代码,即`JsonBeanScanner`中`import`的类`JsonBeanRegistrar`\n\n```java\npackage com.li.ivr.test.scanner;\n\nimport com.li.ivr.test.advise.ProxyFactoryBean;\nimport com.li.ivr.test.annotation.JsonBean;\nimport com.li.ivr.test.annotation.JsonBeanScanner;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;\nimport org.springframework.context.annotation.ImportBeanDefinitionRegistrar;\nimport org.springframework.core.type.AnnotationMetadata;\nimport org.springframework.core.type.filter.AnnotationTypeFilter;\n\nimport java.util.Objects;\n\npublic class JsonBeanRegistrar implements ImportBeanDefinitionRegistrar {\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n        String path =\n            (String) Objects.requireNonNull(importingClassMetadata.getAnnotationAttributes(JsonBeanScanner.class.getName())).get(\n                \"value\");\n        createComponentScanner().findCandidateComponents(path).forEach(beanDefinition -> {\n            beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(Objects.requireNonNull(beanDefinition.getBeanClassName()));\n            beanDefinition.setBeanClassName(ProxyFactoryBean.class.getName());\n            registry.registerBeanDefinition(Objects.requireNonNull(beanDefinition.getBeanClassName()), beanDefinition);\n        });\n\n    }\n\n    private ClassPathScanningCandidateComponentProvider createComponentScanner() {\n        // Don't pull default filters (@Component, etc.):\n        ClassPathScanningCandidateComponentProvider provider\n            = new ClassPathScanningCandidateComponentProvider(false);\n        provider.addIncludeFilter(new AnnotationTypeFilter(JsonBean.class));\n        return provider;\n    }\n}\n\n```\n\n其中`ProxyFactoryBean`为生成`bean`的工厂类，代码如下\n\n```java\npackage com.li.ivr.test.advise;\n\nimport com.google.gson.Gson;\nimport com.li.ivr.test.annotation.JsonBean;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.util.StreamUtils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\npublic class ProxyFactoryBean<T> implements FactoryBean {\n    private Class<T> interfaceClass;\n\n    public ProxyFactoryBean(Class<T> interfaceClass) {\n        this.interfaceClass = interfaceClass;\n    }\n\n    @Override\n    public T getObject() throws IOException {\n        JsonBean annotation = interfaceClass.getAnnotation(JsonBean.class);\n        InputStream in = ProxyFactoryBean.class.getResourceAsStream(annotation.value());\n        String json = StreamUtils.copyToString(in, StandardCharsets.UTF_8);\n        return new Gson().fromJson(json, interfaceClass);\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return interfaceClass;\n    }\n}\n```\n\n我们在任意配置类中设置扫描路径即可\n\n```java\n@@Configuration\n@JsonBeanScanner(\"com.li\")\npublic class Application {\n}\n```\n","tags":["自定义扫描器"],"categories":["springboot"]},{"title":"java中使用js","url":"%2F2019%2F08%2F18%2Fjava%E4%B8%AD%E4%BD%BF%E7%94%A8js%2F","content":"\n\n## 背景\n\n使用`SpringBoot`构建的项目\n\n注入`js`代码\n\n```js\nfunction objectToString(obj) {\n  try {\n    var result = \"\";\n    result += getobjectprops(\"\", obj);\n    if (result.charAt(0) == '|') {\n      result = result.substring(1);\n    }\n  } catch (errMsg) {\n    return (\"undefined\");\n  }\n  return result;\n}\n\nfunction getArray(arrayName, item) {\n  try {\n    var len = eval(arrayName + '.length;');\n    var result = \"\";\n    for (var i = 0; i < len; i++) {\n      if (i > 0) {\n        result += \" |\";\n      }\n      var temp = arrayName + \"[\" + i + \"].\" + item;\n      result += eval(temp);\n    }\n    return result;\n  } catch (errMsg) {\n    return ('unknown');\n  }\n}\n\nfunction getRedirect(item) {\n  return (getArray('session.connection.redirect', item));\n}\n\nf\n```\n\n```java\npackage com.li.ivr.test.expression;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.core.io.Resource;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.StreamUtils;\n\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptException;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\n/**\n *\n */\n@Component\npublic class JS {\n\n    @Value(\"classpath:rootxml.js\")\n    private Resource js;\n\n    @Bean\n    public ScriptEngine scriptEngine() throws IOException, ScriptException {\n        ScriptEngineManager manager = new ScriptEngineManager();\n        ScriptEngine engine = manager.getEngineByName(\"javascript\");\n        engine.eval(StreamUtils.copyToString(js.getInputStream(), StandardCharsets.UTF_8));\n        return engine;\n    }\n}\n\n```\n\n测试\n\n```java\npackage com.li.ivr.test.expression;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptException;\nimport java.io.IOException;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest\npublic class JSTest {\n\n    @Autowired\n    ScriptEngine js;\n\n    @Test\n    public void test() throws ScriptException, IOException {\n        Object eval = js.eval(\"objectToString(1)\");\n        System.out.println(eval);\n    }\n}\n```\n","tags":["js"],"categories":["java"]},{"title":"gradle入门","url":"%2F2019%2F08%2F18%2Fgradle%E5%85%A5%E9%97%A8%2F","content":"\n## 刷新依赖\n\n```shell\ngradle build --refresh-dependencies\n```\n","tags":["gradle"],"categories":["build"]},{"title":"vim","url":"%2F2019%2F08%2F11%2Fvim%2F","content":"\nc与d命令功能类似，c会进入插入模式\n\n`%`  \n匹配对应的括号  \n`(`  \n光标移至句首,)反向  \n`:%s/vivian/sky/g`  \n替换每一行中所有 vivian 为 sky  \n`:1,$ s/$/WORLD/g`  \n替换行尾  \n`:1,$ s/^/HELLO/g`  \n替换行首  \n`:1,10d`  \n命令解释：删除第一行到第10行  \n`:f`  \n在命令模式下，用于显示当前的文件名、光标所在行的行号以及显示比例；  \n`:g/^s*$/d`  \n删除所有空格  \n`:s/vivian/sky/g`  \n替换当前行所有 vivian 为 sky  \n`b`  \n光标左移一个字至字首,跳过空格  \n`caw ciw`  \n更改当前光标所在字符的单词并进入插入模式  \n`ct`  \n删除到某个单词并进入插入模式,T反向  \n`c`  \n和其它命令组合,和d模式基本相同，进入插入模式  \n`C`  \n删除直到行尾并进入插入模式  \n`Ctrl+b`  \n向文件首翻一屏；  \n`Ctrl+d`  \n向文件尾翻半屏；  \n`Ctrl+f`  \n向文件尾翻一屏；  \n`Ctrl+u`  \n向文件首翻半屏；  \n`f`  \n跳转到指定字符  \n`t`  \n`跳转到指定字符前`  \n``\n`D`  \n删除直到行尾  \n`diw`  \n删除当前单词,和其它组合，如di{,di(,di\"  \n`daw`  \n删除当前单词,和其它组合，如di{,di(,di\",同时删除组合  \n`dt`  \n删除知道某个单词 仅限当前行,T反向  \n`e`  \n光标右移一个字至字尾,跳过空格  \n`gd`  \n高亮显示光标所属单词，\"n\" 查找！  \n`ge`  \n光标左移一个字至字尾,跳过空格  \n`gU`  \n转换大写到 需配合w,b等移动命令，类似t  \n`gu`  \n转换小写到 需配合w,b等移动命令，类似t  \n`H`  \n光标移至屏幕顶行  \n`L`  \n光标移至屏幕最后行  \n`M`  \n光标移至屏幕中间行  \n`R`  \n进入替换模式，直到按下esc  \n`s`  \n删除当前字符并进入插入模式  \n`S`  \n删除当前行，并进入插入模式  \n`vi{`  \n选中大括号内,小括号等同理  \n`w`  \n光标右移一个字至字首,跳过空格  \n`ZZ`  \n命令模式下保存当前文件所做的修改后退出vi；  \n`{`  \n转到上一个空行 }反向  \n`＃`  \n普通模式下输入＃寻找游标所在处的单词,＊是反向  \n`ma`  \nmark currrent position  \n`da`  \ndelete everything from the marked position to here  \n\\`a\ngo back to the marked position  \n`''`  \n跳转到光标上次停靠的地方, 是两个', 而不是一个\"  \n`gD`  \n跳转到局部变量的定义处  \n`:E`  \n浏览当前目录  \n  \n## 宏模式\n\n在命令模式下按下`qa`开始记录，指导在命令模式下再次按下`q`结束记录。\n可通过`@a`，重复执行命令，`n@a`重复执行`n`次。\n  ","tags":["vim"],"categories":["linux"]},{"title":"tomcat配置jndi","url":"%2F2019%2F08%2F10%2Ftomcat%E9%85%8D%E7%BD%AEjndi%2F","content":"\n确保tomcat下有相关`jar`\n\ntomcat目录下`/conf/context.xml`中增加配置\n\n```xml\n<Resource name = \"jdbc/mysql\"\n      auth = \"Container\"\n      type = \"javax.sql.DataSource\"  \n      driverClassName = \"com.mysql.jdbc.Driver\"  \n      url = \"jdbc:mysql://localhost:3306/app\"  \n      factory=\"com.li.jndi.EncryptedDataSourceFactory\"\n      username = \"root\"\n      password = \"xxxx\"\n      maxActive = \"200\"\n      maxIdle = \"30\"\n      maxWait = \"5000\"\n/>  \n```\n\n确保tomcat目录下有`driver`的`jar`包\n>`/lib/mysql-connector-java-8.0.16.jar`\n\n`factory`标签是指定`BasicDataSourceFactory`工厂类，可以用来解密`password`密文。需要如下依赖\n\n```xml\n<dependency>\n    <groupId>commons-dbcp</groupId>\n    <artifactId>commons-dbcp</artifactId>\n    <version>1.2.2</version>\n</dependency>\n```\n\n`EncryptedDataSourceFactory`代码如下\n\n```java\npackage com.li.jndi;\n\nimport org.apache.commons.dbcp.BasicDataSourceFactory;\nimport org.apache.naming.ResourceRef;\n\nimport javax.naming.*;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\n\npublic class EncryptedDataSourceFactory extends BasicDataSourceFactory {\n\n    @Override\n    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable environment) throws Exception {\n        if (obj instanceof ResourceRef) {\n            decode(\"password\", (Reference) obj);\n        }\n        return super.getObjectInstance(obj, name, nameCtx, environment);\n    }\n\n    private String decode(String old) throws Exception {\n        return \"root\";\n    }\n\n    private int find(String addrType, Reference ref) throws Exception {\n        Enumeration enu = ref.getAll();\n        for (int i = 0; enu.hasMoreElements(); i++) {\n            RefAddr addr = (RefAddr) enu.nextElement();\n            if (addr.getType().compareTo(addrType) == 0) {\n                return i;\n            }\n        }\n        throw new Exception(\"The \\\"\" + addrType\n            + \"\\\" name/value pair was not found\"\n            + \" in the Reference object. The reference Object is\" + \" \"\n            + ref.toString());\n    }\n\n    private void decode(String refType, Reference ref) throws Exception {\n        int index = find(refType, ref);\n        RefAddr refAddr = ref.get(index);\n        Object content = refAddr.getContent();\n        if (content instanceof String) {\n            ref.remove(index);\n            ref.add(index, new StringRefAddr(refType, decode((String) content)));\n        }\n    }\n\n}\n\n```\n\n使用`jndi`服务\n\n```java\npackage com.li.jndi;\n\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\npublic class DBConn {\n\n    private static DataSource dataSource;\n\n    static {\n        try {\n            Context context = new InitialContext();\n            dataSource = (DataSource)context.lookup(\"java:comp/env/jdbc/mysql\");\n        }\n        catch (NamingException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n","tags":["jndi"],"categories":["tomcat"]},{"title":"java-bridge-method","url":"%2F2019%2F08%2F09%2Fjava-bridge-method%2F","content":"\n## 桥接方法\n\n泛型类型擦除的影响，以及bridge方法介绍\n\n```java\npublic class Node<T> {\n\n    public T data;\n\n    public Node(T data) { this.data = data; }\n\n    public void setData(T data) {\n        System.out.println(\"Node.setData\");\n        this.data = data;\n    }\n}\n\npublic class MyNode extends Node<Integer> {\n    public MyNode(Integer data) { super(data); }\n\n    public void setData(Integer data) {\n        System.out.println(\"MyNode.setData\");\n        super.setData(data);\n    }\n}\n```\n\n当做如下使用时\n\n```java\nNode node = new MyNode(5);\nn.setData(\"Hello\");\n```\n\n我们的子类中实际是没有setData(Object.class)的方法的，`java`编译器在进行类型擦除的时候会自动生成一个`synthetic`方法，也叫`bridge`方法,我们通过生成的字节码可以看到实际`bridge`方法，首先校验类型是否为`Integer`，然后在调用`setData(Integer.class)`因此，上述代码会抛出`ClassCastException`\n\n```java\npublic void setData(java.lang.Integer);\n    descriptor: (Ljava/lang/Integer;)V\n    flags: ACC_PUBLIC\n    Code:\n        stack=2, locals=2, args_size=2\n            0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n            3: ldc           #3                  // String MyNode.setNode\n            5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n            8: aload_0\n            9: aload_1\n            10: invokespecial #5                  // Method com/li/springboot/bridge/Node.setData:(Ljava/lang/Object;)V\n            13: return\n        LineNumberTable:\n        line 11: 0\n        line 12: 8\n        line 13: 13\n        LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      14     0  this   Lcom/li/springboot/bridge/MyNode;\n            0      14     1 integer   Ljava/lang/Integer;\n    MethodParameters:\n        Name                           Flags\n        integer\n\n\npublic void setData(java.lang.Object);\n    descriptor: (Ljava/lang/Object;)V\n    flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC\n    Code:\n        stack=2, locals=2, args_size=2\n            0: aload_0\n            1: aload_1\n            2: checkcast     #11                 // class java/lang/Integer\n            5: invokevirtual #12                 // Method setData:(Ljava/lang/Integer;)V\n            8: return\n        LineNumberTable:\n        line 3: 0\n        LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       9     0  this   Lcom/li/springboot/bridge/MyNode;\n    MethodParameters:\n        Name                           Flags\n        integer                        synthetic\n\n```\n\n## 桥接子类获取泛型\n\n父类泛型可以使用\n\n```java\nParameterizedTypeImpl type = (ParameterizedTypeImpl) MyNode.class.getGenericSuperclass();\n//具体每个泛型\ntype.getActualTypeArguments()\n```\n\n接口泛型\n\n```java\nParameterizedTypeImpl[] types = (ParameterizedTypeImpl[]) MyNode.class.getGenericInterfaces();\n\n```\n\n## Spring注入桥接子类注意\n\n```java\npublic interface Generic<T,R> {}\n@Component\npublic class G1 implements Generic<Object, Collection> {}\npublic class G2 implements Generic<Object, List> {}\npublic class G3<T> implements Generic<T, List> {}\npublic class G4 implements Generic<String, List> {}\n```\n\n```java\n\n   @Autowired\n   List<Generic> generics; //G1 G2 G3 G4\n   @Autowired\n   List<Generic<?, ? extends Collection>> generics; //G1 G2 G3 G4\n   @Autowired\n   List<Generic<?, Collection>> generics;//G1\n   @Autowired\n   List<Generic<Object, ? extends Collection>> generics; //G1 G2 G3\n   @Autowired\n   List<Generic<Object, Collection>> generics; //G1 G2 \n```\n","tags":["java"],"categories":["java"]},{"title":"restTemplate使用","url":"%2F2019%2F08%2F09%2FrestTemplate%E4%BD%BF%E7%94%A8%2F","content":"\n## 基础\n\n推荐使用`RestTemplateBuilder`构建`RestTemplate`\n\n我们看下`RestTemplate`的基础成员变量\n\n`requestFactory: ClientHttpRequestFactory`\n`defaultUriVariables: Map<String, ?>`\n`uriTemplateHandler: UriTemplateHandler`\n`interceptors: List<ClientHttpRequestInterceptor>`\n`messageConverters: List<HttpMessageConverter<?>>`\n`errorHandler: ResponseErrorHandler`\n\n下面我们主要针对这些属性做一些分析\n\n## requestFactory\n\n指定使用的`HTTP`请求方式，\n设置`http`请求工厂类，处理超时，线程，异常处理等情况。\n\n```java\nRestTemplate restTemplate() {\n    return new RestTemplateBuilder().requestFactory(requestFactory()).build();\n}\n\nprivate Supplier<ClientHttpRequestFactory> requestFactory() {\n    return () -> {\n        HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n        requestFactory.setConnectionRequestTimeout(3000);\n        requestFactory.setConnectTimeout(3000);\n        requestFactory.setReadTimeout(8000);\n        requestFactory.setHttpClient(httpClient());\n        return requestFactory;\n    };\n}\n\nprivate HttpClient httpClient() {\n    HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();\n    httpClientBuilder.setMaxConnTotal(50);\n    httpClientBuilder.setMaxConnPerRoute(5);\n    return HttpClientBuilder.create().build();\n}\n```\n\n## defaultUriVariables\n\n当被赋值时就不能使用自定义`uriTemplateHandler`。这是就使用默认的`uriTemplateHandler`即`DefaultUriBuilderFactory`。\n假设现在`defaultUriVariables`包含`default=demo`。\n\n例如：\n\n```java\nString url = \"http://localhost:8080/{default}/{replace}\"\n\nMap<String,String> uriVariables = new HashMap<>();\nuriVariables.put(\"replace\",\"someuri\");\n\npublic <T> T postForObject(String url, @Nullable Object request, Class<T> responseType,\n        Map<String, ?> uriVariables)\n```\n\n在实际请求时:\n`{default}`会被替换为`demo`  \n`{replace}`会被替换为`someuri`  \n 替换后的值中包含`/`会无法正常解析。  \n\n## uriTemplateHandler\n\n根据需要，生成满足自己需要的URI。\n\n```java\npublic interface UriTemplateHandler {\n    URI expand(String uriTemplate, Map<String, ?> uriVariables);\n    URI expand(String uriTemplate, Object... uriVariables);\n}\n```\n\n返回的URI经过自定义处理器会将`{xxx}`,替换为`uriVariables`中对应的值，这个可以正常解析`/`\n\n```java\nRestTemplate rest = restTemplate();\n    rest.setUriTemplateHandler(new UriTemplateHandler() {\n        @Override\n        public URI expand(String uriTemplate, Map<String, ?> uriVariables) {\n            return new UriTemplate(uriTemplate).expand(uriVariables);\n        }\n\n        @Override\n        public URI expand(String uriTemplate, Object... uriVariables) {\n            return new UriTemplate(uriTemplate).expand(uriVariables);\n        }\n    });\n\n    Map<String, Object> uriVariables = new HashMap<>();\n    uriVariables.put(\"replace\", \"response/test\");\n    String hello = rest.postForObject(\"http://localhost:8080/{replace}\", \"\", String.class, uriVariables);\n```\n\n## interceptors\n\n类似`AOP`切面，在`HTTP`请求前后进行拦截，比如统一加`headers\n\n```java\npublic interface ClientHttpRequestInterceptor {\n\n    ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution)\n            throws IOException;\n}\n\n ClientHttpRequestInterceptor interceptor = (request, body, execution) -> {\n            return execution.execute(request, body);\n        };\n```\n\n## messageConverters\n\n与`SpringMVC`的`messageConverters`原理是一样的。\b`HTTP`交易时数据传递是通过二进制`byte`传递的。而我们使用`RestTemplate`时，一般请求返回都使用`javaBean`,那就需要`messageConverters`来统一处理。\n\n我们看下`RestTemplate`的静态方法\n\n```java\nprivate static boolean romePresent;\n\nprivate static final boolean jaxb2Present;\n\nprivate static final boolean jackson2Present;\n\nprivate static final boolean jackson2XmlPresent;\n\nprivate static final boolean jackson2SmilePresent;\n\nprivate static final boolean jackson2CborPresent;\n\nprivate static final boolean gsonPresent;\n\nprivate static final boolean jsonbPresent;\n\nstatic {\n    ClassLoader classLoader = RestTemplate.class.getClassLoader();\n    romePresent = ClassUtils.isPresent(\"com.rometools.rome.feed.WireFeed\", classLoader);\n    jaxb2Present = ClassUtils.isPresent(\"javax.xml.bind.Binder\", classLoader);\n    jackson2Present =\n            ClassUtils.isPresent(\"com.fasterxml.jackson.databind.ObjectMapper\", classLoader) &&\n                    ClassUtils.isPresent(\"com.fasterxml.jackson.core.JsonGenerator\", classLoader);\n    jackson2XmlPresent = ClassUtils.isPresent(\"com.fasterxml.jackson.dataformat.xml.XmlMapper\", classLoader);\n    jackson2SmilePresent = ClassUtils.isPresent(\"com.fasterxml.jackson.dataformat.smile.SmileFactory\", classLoader);\n    jackson2CborPresent = ClassUtils.isPresent(\"com.fasterxml.jackson.dataformat.cbor.CBORFactory\", classLoader);\n    gsonPresent = ClassUtils.isPresent(\"com.google.gson.Gson\", classLoader);\n    jsonbPresent = ClassUtils.isPresent(\"javax.json.bind.Jsonb\", classLoader);\n}\n```\n\n再看下`RestTemplate`构造器，当`classpath`中有对应的`class`时，可以看到`RestTemplate`会自动加载\n\n```java\npublic RestTemplate() {\n    this.messageConverters.add(new ByteArrayHttpMessageConverter());\n    this.messageConverters.add(new StringHttpMessageConverter());\n    this.messageConverters.add(new ResourceHttpMessageConverter(false));\n    try {\n        this.messageConverters.add(new SourceHttpMessageConverter<>());\n    }\n    catch (Error err) {\n        // Ignore when no TransformerFactory implementation is available\n    }\n    this.messageConverters.add(new AllEncompassingFormHttpMessageConverter());\n\n    if (romePresent) {\n        this.messageConverters.add(new AtomFeedHttpMessageConverter());\n        this.messageConverters.add(new RssChannelHttpMessageConverter());\n    }\n\n    if (jackson2XmlPresent) {\n        this.messageConverters.add(new MappingJackson2XmlHttpMessageConverter());\n    }\n    else if (jaxb2Present) {\n        this.messageConverters.add(new Jaxb2RootElementHttpMessageConverter());\n    }\n\n    if (jackson2Present) {\n        this.messageConverters.add(new MappingJackson2HttpMessageConverter());\n    }\n    else if (gsonPresent) {\n        this.messageConverters.add(new GsonHttpMessageConverter());\n    }\n    else if (jsonbPresent) {\n        this.messageConverters.add(new JsonbHttpMessageConverter());\n    }\n\n    if (jackson2SmilePresent) {\n        this.messageConverters.add(new MappingJackson2SmileHttpMessageConverter());\n    }\n    if (jackson2CborPresent) {\n        this.messageConverters.add(new MappingJackson2CborHttpMessageConverter());\n    }\n\n    this.uriTemplateHandler = initUriTemplateHandler();\n}\n```\n\n## errorHandler\n\n仅在`HTTP`成功返回后才会被执行，决定当前`HTTP`请求是否成功。`hasError`返回`true`时才会调用`handleError`方法。\n\n```java\npublic interface ResponseErrorHandler {\n    boolean hasError(ClientHttpResponse response) throws IOException;\n    void handleError(ClientHttpResponse response) throws IOException;\n    default void handleError(URI url, HttpMethod method, ClientHttpResponse response) throws IOException {\n        handleError(response);\n    }\n}\n```\n\n## rootUri\n\n通过`RestTemplateBuilder`设置`rootUri`,进行`HTTP`请求时，若非`http`开头，则会自动加上`rootUri`\n\n```java\nRestTemplate rest = new RestTemplateBuilder().rootUri(\"http://localhost:8080\").build();\nrest.postForObject(\"/test\", \"\", String.class, variables);\n```\n\n## POST请求参数\n\n上传文件的请求模拟\n\n```java\nRestTemplate restTemplate = new RestTemplate();\nMultiValueMap multiValueMap = new LinkedMultiValueMap();\nFileSystemResource resource = new FileSystemResource(new File(\"/Users/li/Documents/Blog/db.json\"));\nmultiValueMap.add(\"file\",resource);\nString msg = restTemplate.postForObject(\"http://localhost:8082/upload/any\", multiValueMap, String.class);\n```\n\n## 上传文件的错误\n\n错误信息\n> The request was rejected because no multipart boundary was found  \n\n通过查找该报错信息打印处可以定位\n\n```java\nFileItemIteratorImpl(RequestContext ctx)\n        throws FileUploadException, IOException {\n    if (ctx == null) {\n        throw new NullPointerException(\"ctx parameter\");\n    }\n\n    String contentType = ctx.getContentType();\n    if ((null == contentType)\n            || (!contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART))) {\n        throw new InvalidContentTypeException(String.format(\n                \"the request doesn't contain a %s or %s stream, content type header is %s\",\n                MULTIPART_FORM_DATA, MULTIPART_MIXED, contentType));\n    }\n\n\n    final long requestSize = ((UploadContext) ctx).contentLength();\n\n    InputStream input; // N.B. this is eventually closed in MultipartStream processing\n    if (sizeMax >= 0) {\n        if (requestSize != -1 && requestSize > sizeMax) {\n            throw new SizeLimitExceededException(String.format(\n                    \"the request was rejected because its size (%s) exceeds the configured maximum (%s)\",\n                    Long.valueOf(requestSize), Long.valueOf(sizeMax)),\n                    requestSize, sizeMax);\n        }\n        // N.B. this is eventually closed in MultipartStream processing\n        input = new LimitedInputStream(ctx.getInputStream(), sizeMax) {\n            @Override\n            protected void raiseError(long pSizeMax, long pCount)\n                    throws IOException {\n                FileUploadException ex = new SizeLimitExceededException(\n                String.format(\"the request was rejected because its size (%s) exceeds the configured maximum (%s)\",\n                        Long.valueOf(pCount), Long.valueOf(pSizeMax)),\n                        pCount, pSizeMax);\n                throw new FileUploadIOException(ex);\n            }\n        };\n    } else {\n        input = ctx.getInputStream();\n    }\n\n    String charEncoding = headerEncoding;\n    if (charEncoding == null) {\n        charEncoding = ctx.getCharacterEncoding();\n    }\n\n    boundary = getBoundary(contentType);\n    if (boundary == null) {\n        IOUtils.closeQuietly(input); // avoid possible resource leak\n        throw new FileUploadException(\"the request was rejected because no multipart boundary was found\");\n    }\n\n    notifier = new MultipartStream.ProgressNotifier(listener, requestSize);\n    try {\n        multi = new MultipartStream(input, boundary, notifier);\n    } catch (IllegalArgumentException iae) {\n        IOUtils.closeQuietly(input); // avoid possible resource leak\n        throw new InvalidContentTypeException(\n                String.format(\"The boundary specified in the %s header is too long\", CONTENT_TYPE), iae);\n    }\n    multi.setHeaderEncoding(charEncoding);\n\n    skipPreamble = true;\n    findNextItem();\n}\n```\n\n通过查看`getBoundary`\n\n```java\nprotected byte[] getBoundary(String contentType) {\n    ParameterParser parser = new ParameterParser();\n    parser.setLowerCaseNames(true);\n    // Parameter parser can handle null input\n    Map<String,String> params =\n            parser.parse(contentType, new char[] {';', ','});\n    //Content-Type中包含boundary=xxx字段\n    String boundaryStr = params.get(\"boundary\");\n\n    if (boundaryStr == null) {\n        return null;\n    }\n    byte[] boundary;\n    boundary = boundaryStr.getBytes(StandardCharsets.ISO_8859_1);\n    return boundary;\n}\n```\n\n根据上一节的说明，我们知道上送文件是使用`MultiValueMap`来上送的，那么我们只要知道`MultiValueMap`请求的`Content-Type`是什么即可。\n\n根据前面章节`messageConverters`的加载介绍，我们知道`RestTemplate`会选择一个合适的处理器来处理，\n其中`AllEncompassingFormHttpMessageConverter`的父类`FormHttpMessageConverter`\n\n```java\npublic void doWithRequest(ClientHttpRequest httpRequest) throws IOException {\n    super.doWithRequest(httpRequest);\n    Object requestBody = this.requestEntity.getBody();\n    if (requestBody == null) {\n        HttpHeaders httpHeaders = httpRequest.getHeaders();\n        HttpHeaders requestHeaders = this.requestEntity.getHeaders();\n        if (!requestHeaders.isEmpty()) {\n            requestHeaders.forEach((key, values) -> httpHeaders.put(key, new LinkedList<>(values)));\n        }\n        if (httpHeaders.getContentLength() < 0) {\n            httpHeaders.setContentLength(0L);\n        }\n    }\n    else {\n        //request的类型需要继承自MultiValueMap或者HttpEntity<MultiValueMap>\n        Class<?> requestBodyClass = requestBody.getClass();\n        Type requestBodyType = (this.requestEntity instanceof RequestEntity ?\n                ((RequestEntity<?>)this.requestEntity).getType() : requestBodyClass);\n        HttpHeaders httpHeaders = httpRequest.getHeaders();\n        HttpHeaders requestHeaders = this.requestEntity.getHeaders();\n        MediaType requestContentType = requestHeaders.getContentType();\n        for (HttpMessageConverter<?> messageConverter : getMessageConverters()) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                GenericHttpMessageConverter<Object> genericConverter =\n                        (GenericHttpMessageConverter<Object>) messageConverter;\n                if (genericConverter.canWrite(requestBodyType, requestBodyClass, requestContentType)) {\n                    if (!requestHeaders.isEmpty()) {\n                        requestHeaders.forEach((key, values) -> httpHeaders.put(key, new LinkedList<>(values)));\n                    }\n                    logBody(requestBody, requestContentType, genericConverter);\n                    genericConverter.write(requestBody, requestBodyType, requestContentType, httpRequest);\n                    return;\n                }\n            }\n            //requestContentType需满足如下之一\n            // null\n            // multipart/form-data\n            // */*\n            //application/x-www-form-urlencoded\n            else if (messageConverter.canWrite(requestBodyClass, requestContentType)) {\n                if (!requestHeaders.isEmpty()) {\n                    requestHeaders.forEach((key, values) -> httpHeaders.put(key, new LinkedList<>(values)));\n                }\n                logBody(requestBody, requestContentType, messageConverter);\n                ((HttpMessageConverter<Object>) messageConverter).write(\n                        requestBody, requestContentType, httpRequest);\n                return;\n            }\n        }\n        String message = \"No HttpMessageConverter for \" + requestBodyClass.getName();\n        if (requestContentType != null) {\n            message += \" and content type \\\"\" + requestContentType + \"\\\"\";\n        }\n        throw new RestClientException(message);\n    }\n}\n```\n\n查看具体`FormHttpMessageConverter`的`write`方法\n\n```java\npublic void write(MultiValueMap<String, ?> map, @Nullable MediaType contentType, HttpOutputMessage outputMessage)\n        throws IOException, HttpMessageNotWritableException {\n    //上送文件肯定使用的writeMultipart\n    if (!isMultipart(map, contentType)) {\n        writeForm((MultiValueMap<String, Object>) map, contentType, outputMessage);\n    }\n    else {\n        writeMultipart((MultiValueMap<String, Object>) map, outputMessage);\n    }\n}\n```\n\n```java\nprivate void writeMultipart(final MultiValueMap<String, Object> parts, HttpOutputMessage outputMessage)\n        throws IOException {\n\n    final byte[] boundary = generateMultipartBoundary();\n    Map<String, String> parameters = new LinkedHashMap<>(2);\n    if (!isFilenameCharsetSet()) {\n        parameters.put(\"charset\", this.charset.name());\n    }\n    //这里我们可以看到生成的boundary信息\n    parameters.put(\"boundary\", new String(boundary, StandardCharsets.US_ASCII));\n\n    MediaType contentType = new MediaType(MediaType.MULTIPART_FORM_DATA, parameters);\n    HttpHeaders headers = outputMessage.getHeaders();\n    headers.setContentType(contentType);\n\n    if (outputMessage instanceof StreamingHttpOutputMessage) {\n        StreamingHttpOutputMessage streamingOutputMessage = (StreamingHttpOutputMessage) outputMessage;\n        streamingOutputMessage.setBody(outputStream -> {\n            writeParts(outputStream, parts, boundary);\n            writeEnd(outputStream, boundary);\n        });\n    }\n    else {\n        writeParts(outputMessage.getBody(), parts, boundary);\n        writeEnd(outputMessage.getBody(), boundary);\n    }\n}\n```\n\n所以我们定位一下具体发生错误的情况下使用的是何种`messageConverter`即可\n","tags":["restTemplate"],"categories":["spring"]},{"title":"spring自定义注解改变方法","url":"%2F2019%2F08%2F09%2Fspring%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E6%94%B9%E5%8F%98%E6%96%B9%E6%B3%95%2F","content":"\n## 版本说明\n\n`jdk`:1.8.0_131  \n`springboot`:2.1.6.RELEAS  \n`maven`:3.6.1  \n`lombok插件`  \n\n## 概述\n\n仅仅示范简单用法不涉及源码介绍，仅仅是一些实现方式，不一定是最优实现方式。这里仅仅只做打印参数，不做其他特殊操作，\n可以根据需要，可以实现的包括异步调用，远程调用，缓存等等。\n\n标记注解类\n\n```java\nimport org.slf4j.event.Level;\n\nimport java.lang.annotation.*;\n\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface LogAnnotation {\n    Level value() default Level.DEBUG;\n}\n```\n\n被注解bean\n\n```java\n\nimport org.slf4j.event.Level;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class LogBean {\n    @LogAnnotation\n    public void debug() {\n\n    }\n\n    @LogAnnotation(Level.ERROR)\n    public void error() {\n\n    }\n\n    public void normal(){\n\n    }\n}\n```\n\n## 方案一\n\n使用`BeanPostProcessor`，扫描方法或类是否有`LogAnnotation`注解，如果有，则替换bean为代理类。\n\n```java\nimport lombok.extern.slf4j.Slf4j;\nimport org.slf4j.event.Level;\nimport org.springframework.aop.support.AopUtils;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.config.BeanPostProcessor;\nimport org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.MethodInterceptor;\nimport org.springframework.core.annotation.AnnotatedElementUtils;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Arrays;\n\n@Component\n@Order(Integer.MAX_VALUE)\n@Slf4j\npublic class LogBeanPostProcessor implements BeanPostProcessor {\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\n    Class<?> targetClass = AopUtils.getTargetClass(bean);\n    //判断类是否有注解LogAnnotation\n    if (AnnotatedElementUtils.findMergedAnnotation(targetClass, LogAnnotation.class) != null || Arrays.stream(targetClass.getMethods()).anyMatch(method -> AnnotatedElementUtils.findMergedAnnotation(method, LogAnnotation.class) != null)) {\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(targetClass);\n        //注册切面方法\n        enhancer.setCallback((MethodInterceptor) (o, method, args, methodProxy) -> {\n            LogAnnotation annotation = AnnotatedElementUtils.findMergedAnnotation(targetClass, LogAnnotation.class);\n            if (annotation == null) {\n                annotation = AnnotatedElementUtils.findMergedAnnotation(method, LogAnnotation.class);\n            }\n            if (annotation == null) {\n                return method.invoke(bean, args);\n            }\n            //包含有注解的方法，或者类上有注解的方法，打印日志\n            Level level = annotation.value();\n            if (log.isDebugEnabled()) {\n                log.debug(\"[\" + level + \"]\" + method.getName() + \" \" + Arrays.toString(args));\n            } else if (log.isErrorEnabled()) {\n                log.debug(\"[\" + level + \"]\" + method.getName() + \" \" + Arrays.toString(args));\n            }\n            return method.invoke(bean, args);\n        });\n        //生成代理类\n        return enhancer.create();\n    }\n    return bean;\n}\n}\n\n```\n\n## 方案二\n\n使用`spring`提供的切面功能，针对被注解的类进行切面\n\n```java\npackage com.li.springboot.other;\n\nimport com.li.springboot.advice.MyPointcutAdvisor;\nimport lombok.extern.slf4j.Slf4j;\nimport org.aopalliance.aop.Advice;\nimport org.aopalliance.intercept.MethodInterceptor;\nimport org.slf4j.event.Level;\nimport org.springframework.aop.Pointcut;\nimport org.springframework.aop.framework.AbstractAdvisingBeanPostProcessor;\nimport org.springframework.aop.support.AbstractPointcutAdvisor;\nimport org.springframework.aop.support.AopUtils;\nimport org.springframework.aop.support.ComposablePointcut;\nimport org.springframework.aop.support.annotation.AnnotationMatchingPointcut;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryAware;\nimport org.springframework.core.BridgeMethodResolver;\nimport org.springframework.core.annotation.AnnotatedElementUtils;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.ClassUtils;\n\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\n\n@Component\n@Order(Integer.MAX_VALUE)\n@Slf4j\npublic class LogBeanAdvisingBeanPostProcessor extends AbstractAdvisingBeanPostProcessor implements BeanFactoryAware {\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n        setBeforeExistingAdvisors(true);\n        MyPointcutAdvisor advisor = new MyPointcutAdvisor();\n        this.advisor = new AbstractPointcutAdvisor() {\n            @Override\n            public Advice getAdvice() {\n                return (MethodInterceptor) invocation -> {\n                    //获取目标类\n                    Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);\n                    //获取指定方法\n                    Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass);\n                    //获取真正执行的方法,可能存在桥接方法\n                    final Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);\n                    //获取方法上注解\n                    LogAnnotation annotation = AnnotatedElementUtils.findMergedAnnotation(userDeclaredMethod,\n                        LogAnnotation.class);\n                    if (annotation == null) {\n                        annotation = AnnotatedElementUtils.findMergedAnnotation(targetClass, LogAnnotation.class);\n                    }\n                    //包含注解则打印参数\n                    if (annotation != null) {\n                        Level level = annotation.value();\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"[\" + level + \"]\" + specificMethod.getName() + \" \" + Arrays.toString(invocation.getArguments()));\n                        } else if (log.isErrorEnabled()) {\n                            log.debug(\"[\" + level + \"]\" + specificMethod.getName() + \" \" + Arrays.toString(invocation.getArguments()));\n                        }\n                    }\n                    //执行具体业务逻辑\n                    return invocation.proceed();\n                };\n            }\n\n            @Override\n            public Pointcut getPointcut() {\n                ComposablePointcut result = null;\n                //类级别\n                Pointcut cpc = new AnnotationMatchingPointcut(LogAnnotation.class, true);\n                //方法级别\n                Pointcut mpc = AnnotationMatchingPointcut.forMethodAnnotation(LogAnnotation.class);\n                //对于类和方法上都可以添加注解的情况\n                //类上的注解,最终会将注解绑定到每个方法上\n                result = new ComposablePointcut(cpc);\n                return result.union(mpc);\n            }\n        };\n    }\n}\n```\n","tags":["自定义注解"],"categories":["spring"]},{"title":"spring ControllerAdvice源码分析","url":"%2F2019%2F08%2F06%2Fspring-ControllerAdvice%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F","content":"\n## 版本说明\n\n`jdk`:1.8.0_131  \n`springboot`:2.1.6.RELEAS  \n`maven`:3.6.1  \n`database`:mysql-5.7.14  \n`lombok插件`  \n\n## 源码分析\n\n仅仅针对被`@ControllerAdvice`注解的且实现接口`ResponseBodyAdvice`的类，进行源码分析，了解一下当`controller`中被`@ResponseBody`注解的方法的返回值，是如何被解析成前端需要的值的。\n至于`RequestBodyAdvice`和`@ExceptionHandler`等实现原理是差不多的。\n\n根据{% post_link Spring自定义ReturnValueHandlers %}中的分析，我们了解了实际调用`controller`类中的被`@ResponseBody`注解方法时，实际使用`RequestResponseBodyMethodProcessor`处理器去处理。\n\n我们查看下`RequestResponseBodyMethodProcessor`的`handleReturnValue`\n\n```java\n@Override\npublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n        ModelAndViewContainer mavContainer, NativeWebRequest webRequest)\n        throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n\n    mavContainer.setRequestHandled(true);\n    ServletServerHttpRequest inputMessage = createInputMessage(webRequest);\n    ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);\n\n    writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);\n}\n```\n\n`writeWithMessageConverters`节选片段\n\n```java\nif (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ?\n                    (GenericHttpMessageConverter<?>) converter : null);\n            if (genericConverter != null ?\n                    ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :\n                    converter.canWrite(valueType, selectedMediaType)) {\n                body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,\n                        (Class<? extends HttpMessageConverter<?>>) converter.getClass(),\n                        inputMessage, outputMessage);\n                if (body != null) {\n                    Object theBody = body;\n                    LogFormatUtils.traceDebug(logger, traceOn ->\n                            \"Writing [\" + LogFormatUtils.formatValue(theBody, !traceOn) + \"]\");\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter != null) {\n                        genericConverter.write(body, targetType, selectedMediaType, outputMessage);\n                    }\n                    else {\n                        ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                    }\n                }\n                else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Nothing to write: null body\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n\n```\n\n`this.messageConverters`的循环调用，其实就是用合适的`HttpMessageConverter`来解析返回报文，默认情况下我们用的就是`SpringBoot`内容的`MappingJackson2HttpMessageConverter`处理器\n\n`MappingJackson2HttpMessageConverter`的`canWrite`就是查看`MediaType`是否满足\n\n```java\nprotected boolean canWrite(@Nullable MediaType mediaType) {\n    if (mediaType == null || MediaType.ALL.equalsTypeAndSubtype(mediaType)) {\n        return true;\n    }\n    for (MediaType supportedMediaType : getSupportedMediaTypes()) {\n        if (supportedMediaType.isCompatibleWith(mediaType)) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n重点的是`getAdvice()`的加载\n\n```java\nRequestResponseBodyAdviceChain getAdvice() {\n    return this.advice;\n}\n```\n\n用`Debug`模式一步步回溯最终发现`RequestMappingHandlerAdapter`中\n\n```java\npublic void afterPropertiesSet() {\n    //扫描所有@ControllerAdvice\n    initControllerAdviceCache();\n\n    if (this.argumentResolvers == null) {\n        //\n        List<HandlerMethodArgumentResolver> resolvers = getDefaultArgumentResolvers();\n        this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);\n    }\n    if (this.initBinderArgumentResolvers == null) {\n        List<HandlerMethodArgumentResolver> resolvers = getDefaultInitBinderArgumentResolvers();\n        this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);\n    }\n    if (this.returnValueHandlers == null) {\n        List<HandlerMethodReturnValueHandler> handlers = getDefaultReturnValueHandlers();\n        this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);\n    }\n}\n```\n\n节选`initControllerAdviceCache`\n\n```java\nList<ControllerAdviceBean> adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());\n...\nif (!requestResponseBodyAdviceBeans.isEmpty()) {\n    this.requestResponseBodyAdvice.addAll(0, requestResponseBodyAdviceBeans);\n}\n\n```\n\n节选方法`getDefaultArgumentResolvers`细节\n\n```java\nresolvers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));\n\n```\n\n`RequestResponseBodyMethodProcessor`构造方法最终指向父类`AbstractMessageConverterMethodArgumentResolver`,那么我们看到`@ControllerAdvice`注解的且实现接口`ResponseBodyAdvice`的类被加载到`this.advice`中\n\n```java\npublic AbstractMessageConverterMethodArgumentResolver(List<HttpMessageConverter<?>> converters,\n        @Nullable List<Object> requestResponseBodyAdvice) {\n\n    Assert.notEmpty(converters, \"'messageConverters' must not be empty\");\n    this.messageConverters = converters;\n    this.allSupportedMediaTypes = getAllSupportedMediaTypes(converters);\n    this.advice = new RequestResponseBodyAdviceChain(requestResponseBodyAdvice);\n}\n```\n\n那么我们看下`this.advice`的类`RequestResponseBodyAdviceChain`方法`beforeBodyWrite`细节\n\n```java\n@Override\n@Nullable\npublic Object beforeBodyWrite(@Nullable Object body, MethodParameter returnType, MediaType contentType,\n        Class<? extends HttpMessageConverter<?>> converterType,\n        ServerHttpRequest request, ServerHttpResponse response) {\n\n    return processBody(body, returnType, contentType, converterType, request, response);\n}\n\n    private <T> Object processBody(@Nullable Object body, MethodParameter returnType, MediaType contentType,\n        Class<? extends HttpMessageConverter<?>> converterType,\n        ServerHttpRequest request, ServerHttpResponse response) {\n\n    for (ResponseBodyAdvice<?> advice : getMatchingAdvice(returnType, ResponseBodyAdvice.class)) {\n        //决定自定义@ControllerAdvice是否启用\n        if (advice.supports(returnType, converterType)) {\n            //调用我们的返回值处理类\n            body = ((ResponseBodyAdvice<T>) advice).beforeBodyWrite((T) body, returnType,\n                    contentType, converterType, request, response);\n        }\n    }\n    return body;\n}\n```\n\n 最后贴下`@ControllerAdvice`实现类\n\n ```java\npackage com.li.springboot.controller;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.server.ServerHttpRequest;\nimport org.springframework.http.server.ServerHttpResponse;\nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;\n\n@ControllerAdvice\n@Slf4j\npublic class MyControllerAdvice implements ResponseBodyAdvice{\n    @Override\n    public boolean supports(MethodParameter returnType, Class converterType) {\n        return true;\n    }\n\n    @Override\n    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {\n        log.debug(\"MyControllerAdvice beforeBodyWrite\");\n        return body;\n    }\n}\n ```\n","tags":["ControllerAdvice"],"categories":["springboot"]},{"title":"java tips","url":"%2F2019%2F08%2F06%2Fjava-tips%2F","content":"\n控制台`console`乱码\n\n`java`启动参数添加 `-Dfile.encoding=utf-8`\n\n将常量放在接口中，通过继承该接口，调用常量\n\n```java\npublic interface ClassConstants{\n   int CONSUMER = 1;//接口中变量默认为 static final\n   int DISPLAY = 2;\n}\n```\n\n查看 Class 是否是基本类型\n\n```java\nclasz.isPrimitive();\n```\n\n查看类是否为基本类型或包装类型\n\n```java\nimport org.apache.commons.lang3.ClassUtils;\nClassUtils.isPrimitiveOrWrapper(klass)\n```\n\n读取 properties 中文乱码解决\n\n```java\nproperties.load(new InputStreamReader(AutoConfig.class.getResourceAsStream(\"/application.properties\"),\"utf-8\"));\n```\n\n判断类是否为数组\n\n```java\nklass.isArray();\n```\n\n判断类是否继承自\n\n```java\nFather.class.isAssignableFrom(Son.class)\n```\n\n流快速删除,`Collection`提供了方法\n\n```java\nCollection.removeIf(Predicate<? super E> filter)\n```\n\n获取当前执行的方法名,通过方法内的内部类来实现的\n\n```java\nnew Object(){}.getClass().getEnclosingMethod().getName();\n```\n\n设置`SAXReader`的`feature`属性，禁止校验`dtd`文件,读取`String`为`DOMDocument`\n\n```java\nimport com.sun.org.apache.xerces.internal.impl.Constants;\n\n/**\n * 在读取文件时，去掉dtd的验证，可以缩短运行时间\n */\npublic static SAXReader getSAXReader(){\n    SAXReader saxReader = new SAXReader(DOMDocumentFactory.getInstance(),false);\n     try {\n         saxReader.setFeature(Constants.XERCES_FEATURE_PREFIX + Constants.LOAD_EXTERNAL_DTD_FEATURE, false);  //设置不需要校验头文件\n     } catch (Exception e) {\n         e.printStackTrace();\n     }\n     return saxReader;\n }\n\nString xml = \"...xml...\";\nDOMDocument document = (DOMDocument) getSAXReader().read(new StringReader(xml));\n\n```\n\n切割字符串\n\n```java\nString value = \"Notice:4001\";\nStringTokenizer st = new StringTokenizer(value, \":\");\nif(st.hasMoreElements()){\n  System.out.println(st.nextToken());\n}\n```\n\n`String` 替换 正则匹配组\n\n```java\nString s = \"HelloWorldMyNameIsCarl\".replaceAll(\"(.)([A-Z])\", \"$1_$2\");\nString s = \"1.1\".replaceAll(\"(\\\\.\\\\d)$\", \"$10\");//$1表示前面正则表达式组1所捕获到的字符\n```\n\n`Spring`注入文件\n\n```java\n import org.springframework.core.io.Resource;\n\n @Value(\"classpath:rootxml.js\")\n private Resource cert;\n\n @Test\n public void test() throws ScriptException, IOException {\n    System.out.println(StreamUtils.copyToString(cert.getInputStream(), StandardCharsets.UTF_8));\n }\n```\n\n`@Autowired(required = false)`若`Spring`容器中没有对应的`BeanDefinition`时不会注入值，可赋值一个默认值避免空指针的情况。\n\n`Spring`的`@Scheduled`  可使用`crontab`语法，但是不同于`unix`的标准语法，它第一位是秒\n\n```java\n@Scheduled(cron = \"1 22 22 * * *\")\npublic void log() {\n    logger.info(\"--------------------\" + index++);\n}\n```\n\n`cron`规则一定是 6 位以空白字符间隔的字符串，其中每位代表的含义如下\n\n```shell\n秒     分   小时    日    月    星期\n0-59 0-59  0-23  1-31  1-12  0-6\n\n记住几个特殊符号的含义:\n*  代表取值范围内的数字\n*/x  代表每x\nx-y  代表从x到y\n,  分开几个离散的数字\n```\n\n使用 shell\n\n```java\n//获取当前系统名称，可根据不同系统调用不同的命令\nString os = System.getProperty(\"os.name\");\n//命令行的参数\nString [] para = new String[]{\"-l\"}\n//执行命令\nProcess ls = Runtime.getRuntime().exec(\"ls\",para, new File(\"/Users/li/Downloads\"));\n\n\n\n//获取命令执行结果的inputstream流\nString getLs = new BufferedReader(new InputStreamReader(ls.getInputStream())).lines().collect(Collectors.joining(System.lineSeparator()));\n\n//在目录下执行具体的命令\n//因为java执行shell无法进行连续性的交互命令，通过封装的bash或者python脚本执行一系列命令是比较好的选择\nProcess process = Runtime.getRuntime().exec(\"python test.py\", null, new File(\"/Users/li/Downloads\"));\n// 部分os需要先输出outputStream流，才能正确取得shell执行结果\nOutputstream out = process.getOutputStream();\nout.flush();\nout.close();\n\n//使用构造器模式\nProcessBuilder builder = new ProcessBuilder();\nbuilder.command(\"more\",\"test.py\");\nbuilder.directory(new File(\"/Users/li/Downloads\"));\n//重定向错误流，即System.Err\nbuilder.redirectErrorStream(true);\nProcess process = builder.start();\n```\n\n获取`tomcat`运行端口\n\n```java\n//通过classpath定位tomcat配置文件conf/server.xml，使用xpath去解析\nFile serverXml = new File(\"/Users/li/java/apache-tomcat-7.0.70/conf/server.xml\");\nDocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();\ndomFactory.setNamespaceAware(true); // never forget this!\nDocumentBuilder builder = domFactory.newDocumentBuilder();\nDocument doc = builder.parse(serverXml);\nXPathFactory factory = XPathFactory.newInstance();\nXPath xpath = factory.newXPath();\nXPathExpression expr = xpath.compile(\"/Server/Service[@name='Catalina']/Connector[starts-with(@protocol,'HTTP')]/@port[1]\");\nString result = (String) expr.evaluate(doc, XPathConstants.STRING);\nport = result != null && result.length() > 0 ? Integer.valueOf(result) : null;\n```\n\n## `tomcat`使用`java`启动变量作为端口\n\ntomcat 默认会加载`bin`目录下新建`setenv.sh`作为启动环境，若无则新建即可\n\n```shell\n#!/bin/sh\n#JAVA-OPTIONS\n\nJAVA_OPTS=\"$JAVA_OPTS -Dtomcat.port=9999\"\n```\n\n`tomcat`的端口配置文件`conf/server.xml`中，将默认端口替换为如下\n\n```xml\n <Service name=\"Catalina\">\n\n<Connector port=\"{tomcat.port}\" protocol=\"HTTP/1.1\"\n    ...\n```\n\n## stream 一些方法\n\n`reduce`\n\n```java\n List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);\nString join= numbers.stream().map(String::valueOf).reduce((total, element) -> total + element+\"\").get();\nSystem.out.println(\"join= \" + join);\n```\n\n`groupingBy`\n\n```java\n List<String> items =\n            Arrays.asList(\"apple\", \"apple\", \"banana\",\n                \"apple\", \"orange\", \"banana\", \"papaya\");\nMap<String, Long> result =\n    items.stream().collect(\n        Collectors.groupingBy(\n            Function.identity(), Collectors.counting()\n        )\n    );\nSystem.out.println(\"result = \" + result);\nMap<Object, Set<String>> collect = items.stream().collect(Collectors.groupingBy(String::length, Collectors.mapping(e -> e,\n    Collectors.toSet())));\n\nSystem.out.println(\"collect = \" + collect);\n```\n\n`join`\n\n```java\nString join = items.stream().collect(Collectors.joining(\",\"));\n\n```\n\n## EventBus\n\n`maven`\n\n```xml\n<dependency>\n    <groupId>com.google.guava</groupId>\n    <artifactId>guava</artifactId>\n    <version>21.0</version>\n</dependency>\n```\n\n`post`事件，注册的 listener 中注解了`@Subscribe`的方法会被执行，该方法的参数的类型需要与`event`类型一致，若没有类型一致的`@Subscribe`，则由参数类型`DeadEvent`的`listener`统一处理\n\n```java\npublic class EventBusTest {\n    @Test\n    public void test() {\n        EventBus eventBus = new EventBus();\n        EventListener eventListener = new EventListener();\n        eventBus.register(eventListener);\n        eventBus.post(\"hello\");\n        eventBus.post(123);\n    }\n    public static class EventListener {\n        @Subscribe\n        public void stringEvent(String event) {\n            System.out.println(\"event = \" + event);\n        }\n        @Subscribe\n        public void handleDeadEvent(DeadEvent deadEvent) {\n            System.out.println(\"deadEvent = \" + deadEvent);\n        }\n    }\n}\n\n```\n\n## `dom4j`直接获取值\n\n```java\nSystem.out.println(doc.selectObject(\"substring(/root/name/text(),2)\"));\n```\n\n## `junit` 断言异常\n\n```java\npublic class Student {\n    public boolean canVote(int age) {\n        if (i<=0) throw new IllegalArgumentException(\"age should be +ve\");\n        if (i<18) return false;\n        else return true;\n    }\n}\npublic class TestStudent{\n\n    @Rule\n    public ExpectedException thrown= ExpectedException.none();\n\n    @Test\n    public void canVote_throws_IllegalArgumentException_for_zero_age() {\n        Student student = new Student();\n        thrown.expect(IllegalArgumentException.class);\n        thrown.expectMessage(\"age should be +ve\");\n        student.canVote(0);\n    }\n}\n```\n\n## 基本类型零值\n\n对基本数据类型来说，对于类变量`static`和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，可以根据这个特性，直接用静态类常量来获取基本变量的初始值\n\n```java\npublic class Primitive {\n  public static int i; //默认值0\n  public static char c; //默认值'\\u0000'\n}\n```\n","tags":["java"],"categories":["java"]},{"title":"Spring自定义ReturnValueHandlers","url":"%2F2019%2F08%2F05%2FSpring%E8%87%AA%E5%AE%9A%E4%B9%89ReturnValueHandlers%2F","content":"\n## 版本说明\n\n`jdk`:1.8.0_131  \n`springboot`:2.1.6.RELEAS  \n`maven`:3.6.1  \n`database`:mysql-5.7.14  \n`lombok插件`\n\n## 源码分析\n\n省略构建项目，junit 测试等步骤，只分析代码与实现。\n根据{% post_link spring静态资源加载源码浅析 %}中的分析,我们可以知道 \u001b`DispatcherServlet`会拦截所有请求，寻找合适的`mappedHandler`去处理请求，并根据`mappedHandler`去找对应的适配器`HandlerAdapter`来实际请求`controller`的方法，针对接口来说一般使用的是`RequestMappingHandlerAdapter`\n\n具体调用`controller`方法的细节我们不需要关注，这里我们仅仅关注`RequestMappingHandlerAdapter`是如何处理方法的返回值的。\n节选部分`DispatcherServlet`的`doDispatch`方法\n\n```java\n// 根据mappedHandler查找合适的适配器\nHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n// Process last-modified header, if supported by the handler.\nString method = request.getMethod();\nboolean isGet = \"GET\".equals(method);\nif (isGet || \"HEAD\".equals(method)) {\n    long lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n    if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n        return;\n    }\n}\n\nif (!mappedHandler.applyPreHandle(processedRequest, response)) {\n    return;\n}\n\n// 实际调用controller方法的地方\nmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n```\n\n`RequestMappingHandlerAdapter`的`handle`方法调用了内部的`handleInternal`方法\n\n```java\n@Override\nprotected ModelAndView handleInternal(HttpServletRequest request,\n        HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n    ModelAndView mav;\n    checkRequest(request);\n\n    // Execute invokeHandlerMethod in synchronized block if required.\n    if (this.synchronizeOnSession) {\n        HttpSession session = request.getSession(false);\n        if (session != null) {\n            Object mutex = WebUtils.getSessionMutex(session);\n            synchronized (mutex) {\n                mav = invokeHandlerMethod(request, response, handlerMethod);\n            }\n        }\n        else {\n            // No HttpSession available -> no mutex necessary\n            mav = invokeHandlerMethod(request, response, handlerMethod);\n        }\n    }\n    else {\n        // No synchronization on session demanded at all...\n        mav = invokeHandlerMethod(request, response, handlerMethod);\n    }\n\n    if (!response.containsHeader(HEADER_CACHE_CONTROL)) {\n        if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {\n            applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);\n        }\n        else {\n            prepareResponse(response);\n        }\n    }\n\n    return mav;\n}\n\n```\n\n我们再查看`invokeHandlerMethod`实现细节\n\n```java\nprotected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n        HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n    ServletWebRequest webRequest = new ServletWebRequest(request, response);\n    try {\n        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);\n        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);\n\n        ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);\n        if (this.argumentResolvers != null) {\n            invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n        }\n        //这里我们要注意下，后面实现的自定义MyResponseType注解就和这里有关\n        if (this.returnValueHandlers != null) {\n            invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\n        }\n        invocableMethod.setDataBinderFactory(binderFactory);\n        invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);\n\n        ModelAndViewContainer mavContainer = new ModelAndViewContainer();\n        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));\n        modelFactory.initModel(webRequest, mavContainer, invocableMethod);\n        mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);\n\n        AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);\n        asyncWebRequest.setTimeout(this.asyncRequestTimeout);\n\n        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n        asyncManager.setTaskExecutor(this.taskExecutor);\n        asyncManager.setAsyncWebRequest(asyncWebRequest);\n        asyncManager.registerCallableInterceptors(this.callableInterceptors);\n        asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);\n\n        if (asyncManager.hasConcurrentResult()) {\n            Object result = asyncManager.getConcurrentResult();\n            mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];\n            asyncManager.clearConcurrentResult();\n            LogFormatUtils.traceDebug(logger, traceOn -> {\n                String formatted = LogFormatUtils.formatValue(result, !traceOn);\n                return \"Resume with async result [\" + formatted + \"]\";\n            });\n            invocableMethod = invocableMethod.wrapConcurrentResult(result);\n        }\n        //实际调用的地方\n        invocableMethod.invokeAndHandle(webRequest, mavContainer);\n        if (asyncManager.isConcurrentHandlingStarted()) {\n            return null;\n        }\n\n        return getModelAndView(mavContainer, modelFactory, webRequest);\n    }\n    finally {\n        webRequest.requestCompleted();\n    }\n}\n```\n\n我们查看下`invocableMethod.invokeAndHandle`的细节\n\n```java\npublic void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\n        Object... providedArgs) throws Exception {\n\n    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\n    setResponseStatus(webRequest);\n\n    if (returnValue == null) {\n        if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {\n            disableContentCachingIfNecessary(webRequest);\n            mavContainer.setRequestHandled(true);\n            return;\n        }\n    }\n    else if (StringUtils.hasText(getResponseStatusReason())) {\n        mavContainer.setRequestHandled(true);\n        return;\n    }\n\n    mavContainer.setRequestHandled(false);\n    Assert.state(this.returnValueHandlers != null, \"No return value handlers\");\n    try {\n        //处理返回结果\n        this.returnValueHandlers.handleReturnValue(\n                returnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n    }\n    catch (Exception ex) {\n        if (logger.isTraceEnabled()) {\n            logger.trace(formatErrorForReturnValue(returnValue), ex);\n        }\n        throw ex;\n    }\n}\n```\n\n`this.returnValueHandlers.handleReturnValue`的实现细节类`HandlerMethodReturnValueHandlerComposite`\n\n```java\n@Override\npublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n        ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n    //查找合适的处理器\n    HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);\n    if (handler == null) {\n        throw new IllegalArgumentException(\"Unknown return value type: \" + returnType.getParameterType().getName());\n    }\n    //处理器执行\n    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);\n}\n\n@Nullable\nprivate HandlerMethodReturnValueHandler selectHandler(@Nullable Object value, MethodParameter returnType) {\n    boolean isAsyncValue = isAsyncReturnValue(value, returnType);\n    //遍历所有处理器，只要找到就直接返回，所以得考虑下优先级关系\n    for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) {\n        if (isAsyncValue && !(handler instanceof AsyncHandlerMethodReturnValueHandler)) {\n            continue;\n        }\n        if (handler.supportsReturnType(returnType)) {\n            return handler;\n        }\n    }\n    return null;\n}\n```\n\n默认的返回值处理器有以下\n\n![返回值处理器](/images/Spring自定义ReturnValueHandlers_返回值处理器.jpg)\n\n我们查看下典型的`@ResponseBody`的处理器`RequestResponseBodyMethodProcessor`的方法`supportsReturnType`就明白`selectHandler`是如何起作用的\n\n```java\n@Override\npublic boolean supportsReturnType(MethodParameter returnType) {\n    return (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) ||\n            returnType.hasMethodAnnotation(ResponseBody.class));\n}\n```\n\n因为我们自定义的处理器是模仿`@ResponseBody`,那么我们只需要在`returnValueHandlers`中`RequestResponseBodyMethodProcessor`位置处插入我们自定义的处理器即可\n\n那么首先我们需要了解下`HandlerMethodReturnValueHandlerComposite`的属性`returnValueHandlers`是如何被加载赋值的，通过查看调用关系，我们发现 returnValueHandlers 赋值的方法为`addHandlers`,此方法被两处调用\n\n第一处,这里是加载 bean 时的初始化方法，即默认`returnValueHandlers`为`getDefaultReturnValueHandlers`的返回值\n\n```java\n@Override\npublic void afterPropertiesSet() {\n    // Do this first, it may add ResponseBody advice beans\n    initControllerAdviceCache();\n\n    if (this.argumentResolvers == null) {\n        List<HandlerMethodArgumentResolver> resolvers = getDefaultArgumentResolvers();\n        this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);\n    }\n    if (this.initBinderArgumentResolvers == null) {\n        List<HandlerMethodArgumentResolver> resolvers = getDefaultInitBinderArgumentResolvers();\n        this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);\n    }\n    if (this.returnValueHandlers == null) {\n        List<HandlerMethodReturnValueHandler> handlers = getDefaultReturnValueHandlers();\n        this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);\n    }\n}\n```\n\n第二处\n\n```java\npublic void setReturnValueHandlers(@Nullable List<HandlerMethodReturnValueHandler> returnValueHandlers) {\n    if (returnValueHandlers == null) {\n        this.returnValueHandlers = null;\n    }\n    else {\n        this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite();\n        this.returnValueHandlers.addHandlers(returnValueHandlers);\n    }\n}\n```\n\n明显我们无法改变`afterPropertiesSet`的实现细节，那么继承`WebMvcConfigurationSupport`,重写`RequestMappingHandlerAdapter`方法，手动调用`setReturnValueHandlers`方法即可注入我们自定义的处理器。\n但是我们需要取出默认的返回值处理器，避免其他返回值处理器不起作用，`getDefaultReturnValueHandlers`是私有方法，所以我们需要使用反射取值。然后将自定义处理器插入到`RequestResponseBodyMethodProcessor`之前即可,\n这种方式会使`@ControllerAdvice`失效，慎用，更好的方式通过`@ControllerAdvice`实现同样的效果\n\n```java\npackage com.li.springboot.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.method.support.HandlerMethodReturnValueHandler;\nimport org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor;\n\nimport java.lang.reflect.Method;\nimport java.util.List;\n\n@Configuration\npublic class WebMvc extends WebMvcConfigurationSupport {\n\n    @Override\n    public RequestMappingHandlerAdapter requestMappingHandlerAdapter() {\n        RequestMappingHandlerAdapter requestMappingHandlerAdapter = super.requestMappingHandlerAdapter();\n        try {\n            Method method = RequestMappingHandlerAdapter.class.getDeclaredMethod(\"getDefaultReturnValueHandlers\");\n            method.setAccessible(true);\n            List<HandlerMethodReturnValueHandler> returnValueHandlers = (List<HandlerMethodReturnValueHandler>) method.invoke(requestMappingHandlerAdapter);\n            System.out.println(\"invoke \" + returnValueHandlers);\n            int i = 0;\n            for (HandlerMethodReturnValueHandler handlerMethodReturnValueHandler : returnValueHandlers) {\n                if (handlerMethodReturnValueHandler instanceof RequestResponseBodyMethodProcessor) {\n                    returnValueHandlers.add(i, new MyReturnValueHandler(getMessageConverters()));\n                    break;\n                }\n                i++;\n            }\n            requestMappingHandlerAdapter.setReturnValueHandlers(returnValueHandlers);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return requestMappingHandlerAdapter;\n    }\n}\n\npackage com.li.springboot.config;\n\nimport com.li.springboot.annotation.MyResponseBody;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.http.converter.HttpMessageConverter;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.bind.support.WebDataBinderFactory;\nimport org.springframework.web.context.request.NativeWebRequest;\nimport org.springframework.web.method.support.ModelAndViewContainer;\nimport org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@Component\npublic class MyReturnValueHandler extends AbstractMessageConverterMethodProcessor {\n    protected MyReturnValueHandler(List<HttpMessageConverter<?>> converters) {\n        super(converters);\n    }\n\n    @Override\n    public boolean supportsParameter(MethodParameter parameter) {\n        //不需要支持请求参数\n        return false;\n    }\n\n    @Override\n    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n        return null;\n    }\n\n    @Override\n    public boolean supportsReturnType(MethodParameter returnType) {\n        //有注解@MyResponseBody的使用该处理器\n        return returnType.getMethodAnnotation(MyResponseBody.class) != null;\n    }\n\n    @Override\n    public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n        mavContainer.setRequestHandled(true);\n        Map map = new HashMap();\n        map.put(\"data\",returnValue);\n        //替换返回值\n        writeWithMessageConverters(map, returnType, webRequest);\n    }\n}\n\n```\n\n实现后我们可以看到返回值处理器的集合变化\n![返回值处理器2](/images/Spring自定义ReturnValueHandlers_返回值处理器2.jpg)\n","tags":["ReturnValueHandlers"],"categories":["springboot"]},{"title":"idea debug","url":"%2F2019%2F08%2F04%2Fidea-debug%2F","content":"\n>IDEA开发web项目时，建议使用`debug`启动模式，这样可以随时打断点调试项目\n\n## 1. 使用异常类型断点，在抛出异常时快速进入报错点\n\n## 2. 断点设置`condition`，仅当满足条件时触发断点\n\n## 3. 断点可设置依赖关系，仅在前置断点触发后再触发\n\n## 4. `evaluate Expression`可编写代码进行测试\n\n## 5. 使用`watches`监听属性的变化\n\n## 6. `variables`直接修改属性值，进行调试\n\n## 7. 指定线程下触发断点\n\n## 8. 移动到下个断点\n\n## option + 左键 查看变量值\n","tags":["debug"],"categories":["idea"]},{"title":"spring静态资源加载源码浅析","url":"%2F2019%2F08%2F04%2Fspring%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%2F","content":"\n## 自定义资源处理器\n\n`DispatcherServlet`会拦截所有请求，针对`js`,`css`等静态资源文件，我们不期望被`controller`拦截，通过重写`WebMvcConfigurationSupport`的`addResourceHandlers`方法，由拦截指定规则的请求url。代码如下\n\n```java\npackage com.li.springboot.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n\n@Configuration\n@EnableWebMvc\npublic class WebMvc extends WebMvcConfigurationSupport {\n    @Override\n    protected void addResourceHandlers(ResourceHandlerRegistry registry) {\n        registry.addResourceHandler(\"/static\").addResourceLocations(\"classpath:/static\");\n    }\n}\n```\n\n## 源码分析\n\n`SpringBoot`拦截url，根据`HandlerMapping`找到对应的`Handler`去执行相关操作。\n\n`DispatcherServlet`初始化时会调用初始化方法时会加载`HandlerMapping`\n\n```java\nprivate void initHandlerMappings(ApplicationContext context) {\n    this.handlerMappings = null;\n\n    if (this.detectAllHandlerMappings) {\n        // 查找所有HandlerMapping实现类\n        Map<String, HandlerMapping> matchingBeans =\n                BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);\n        if (!matchingBeans.isEmpty()) {\n            this.handlerMappings = new ArrayList<>(matchingBeans.values());\n            // We keep HandlerMappings in sorted order.\n            AnnotationAwareOrderComparator.sort(this.handlerMappings);\n        }\n    }\n...\n```\n\n`WebMvcConfigurationSupport`的方法`resourceHandlerMapping`中注解了`@Bean`，所以自定义的资源处理器类得以被加载\n\n```java\n@Bean\n@Nullable\npublic HandlerMapping resourceHandlerMapping() {\n    Assert.state(this.applicationContext != null, \"No ApplicationContext set\");\n    Assert.state(this.servletContext != null, \"No ServletContext set\");\n\n    ResourceHandlerRegistry registry = new ResourceHandlerRegistry(this.applicationContext,\n            this.servletContext, mvcContentNegotiationManager(), mvcUrlPathHelper());\n    // 我们重写的方法\n    addResourceHandlers(registry);\n\n    AbstractHandlerMapping handlerMapping = registry.getHandlerMapping();\n    if (handlerMapping == null) {\n        return null;\n    }\n    handlerMapping.setPathMatcher(mvcPathMatcher());\n    handlerMapping.setUrlPathHelper(mvcUrlPathHelper());\n    handlerMapping.setInterceptors(getInterceptors());\n    handlerMapping.setCorsConfigurations(getCorsConfigurations());\n    return handlerMapping;\n}\n\n```\n\n重写的方法`new`了`ResourceHandlerRegistration`\n\n```java\npublic ResourceHandlerRegistration addResourceHandler(String... pathPatterns) {\n    ResourceHandlerRegistration registration = new ResourceHandlerRegistration(pathPatterns);\n    this.registrations.add(registration);\n    return registration;\n}\n```\n\n返回到`WebMvcConfigurationSupport`方法`resourceHandlerMapping`的`registry.getHandlerMapping()`中，\n\n```java\nprotected AbstractHandlerMapping getHandlerMapping() {\n    if (this.registrations.isEmpty()) {\n        return null;\n    }\n\n    Map<String, HttpRequestHandler> urlMap = new LinkedHashMap<>();\n    for (ResourceHandlerRegistration registration : this.registrations) {\n        for (String pathPattern : registration.getPathPatterns()) {\n            //找到实际handler\n            ResourceHttpRequestHandler handler = registration.getRequestHandler();\n            if (this.pathHelper != null) {\n                handler.setUrlPathHelper(this.pathHelper);\n            }\n            if (this.contentNegotiationManager != null) {\n                handler.setContentNegotiationManager(this.contentNegotiationManager);\n            }\n            handler.setServletContext(this.servletContext);\n            handler.setApplicationContext(this.applicationContext);\n            try {\n                handler.afterPropertiesSet();\n            }\n            catch (Throwable ex) {\n                throw new BeanInitializationException(\"Failed to init ResourceHttpRequestHandler\", ex);\n            }\n            urlMap.put(pathPattern, handler);\n        }\n    }\n\n    SimpleUrlHandlerMapping handlerMapping = new SimpleUrlHandlerMapping();\n    handlerMapping.setOrder(this.order);\n    handlerMapping.setUrlMap(urlMap);\n    return handlerMapping;\n}\n```\n\n`ResourceHandlerRegistration`的`getRequestHandler`\n\n```java\nprotected ResourceHttpRequestHandler getRequestHandler() {\n    ResourceHttpRequestHandler handler = new ResourceHttpRequestHandler();\n    if (this.resourceChainRegistration != null) {\n        handler.setResourceResolvers(this.resourceChainRegistration.getResourceResolvers());\n        handler.setResourceTransformers(this.resourceChainRegistration.getResourceTransformers());\n    }\n    handler.setLocationValues(this.locationValues);\n    if (this.cacheControl != null) {\n        handler.setCacheControl(this.cacheControl);\n    }\n    else if (this.cachePeriod != null) {\n        handler.setCacheSeconds(this.cachePeriod);\n    }\n    return handler;\n}\n```\n\n那么我们现在只需要搞清楚`ResourceHttpRequestHandler`中的方法是如何被调用即可。\n\n`SpringBoot`或者`SpringMVC`的请求由`DispatcherServlet`拦截所有请求，实现了`Servlet`标准。那么我们从`service`方法入口即可\n\n`DispatcherServlet`的父类`FrameworkServlet`重写了`service`方法\n\n```java\nprotected void service(HttpServletRequest request, HttpServletResponse response)\n        throws ServletException, IOException {\n\n    HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());\n    if (httpMethod == HttpMethod.PATCH || httpMethod == null) {\n        //\n        processRequest(request, response);\n    }\n    else {\n        super.service(request, response);\n    }\n}\n```\n\n`processRequest`方法中，实际由`DispatcherServlet`实现的方法`doService`去处理。而`doService`最终调用`doDispatch`方法\n\n```java\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    HttpServletRequest processedRequest = request;\n    HandlerExecutionChain mappedHandler = null;\n    boolean multipartRequestParsed = false;\n\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n    try {\n        ModelAndView mv = null;\n        Exception dispatchException = null;\n\n        try {\n            processedRequest = checkMultipart(request);\n            multipartRequestParsed = (processedRequest != request);\n\n            //查找合适的handlerMapping\n            mappedHandler = getHandler(processedRequest);\n            if (mappedHandler == null) {\n                noHandlerFound(processedRequest, response);\n                return;\n            }\n\n            // Determine handler adapter for the current request.\n            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n            // Process last-modified header, if supported by the handler.\n            String method = request.getMethod();\n            boolean isGet = \"GET\".equals(method);\n            if (isGet || \"HEAD\".equals(method)) {\n                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n                if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n                    return;\n                }\n            }\n\n            if (!mappedHandler.applyPreHandle(processedRequest, response)) {\n                return;\n            }\n\n            // ha实际使用HttpRequestHandlerAdapter，mappedHandler.getHandler()则为ResourceHttpRequestHandler\n            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n            if (asyncManager.isConcurrentHandlingStarted()) {\n                return;\n            }\n\n            applyDefaultViewName(processedRequest, mv);\n            mappedHandler.applyPostHandle(processedRequest, response, mv);\n        }\n        catch (Exception ex) {\n            dispatchException = ex;\n        }\n        catch (Throwable err) {\n            // As of 4.3, we're processing Errors thrown from handler methods as well,\n            // making them available for @ExceptionHandler methods and other scenarios.\n            dispatchException = new NestedServletException(\"Handler dispatch failed\", err);\n        }\n        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n    }\n    catch (Exception ex) {\n        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n    }\n    catch (Throwable err) {\n        triggerAfterCompletion(processedRequest, response, mappedHandler,\n                new NestedServletException(\"Handler processing failed\", err));\n    }\n    finally {\n        if (asyncManager.isConcurrentHandlingStarted()) {\n            // Instead of postHandle and afterCompletion\n            if (mappedHandler != null) {\n                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n            }\n        }\n        else {\n            // Clean up any resources used by a multipart request.\n            if (multipartRequestParsed) {\n                cleanupMultipart(processedRequest);\n            }\n        }\n    }\n}\n```\n\n我们查看具体查找`mappedHandler`的具体实现,\n\n```java\nprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n    //handlerMappings的加载在上文中有详细解释，这里就加载了ResourceHttpRequestHandler\n    if (this.handlerMappings != null) {\n        for (HandlerMapping mapping : this.handlerMappings) {\n            HandlerExecutionChain handler = mapping.getHandler(request);\n            if (handler != null) {\n                return handler;\n            }\n        }\n    }\n    return null;\n}\n```\n\n接着我们查看查找具体`handlerAdapter`的具体实现\n\n```java\nprotected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {\n    //和handlerMappings的加载代码细节一样，这里加载了HttpRequestHandlerAdapter\n    if (this.handlerAdapters != null) {\n        for (HandlerAdapter adapter : this.handlerAdapters) {\n            if (adapter.supports(handler)) {\n                return adapter;\n            }\n        }\n    }\n    throw new ServletException(\"No adapter for handler [\" + handler +\n            \"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler\");\n}\n```\n\n`handlerAdapter`调用`handle`,对于`HttpRequestHandlerAdapter`来说，\n\n```java\n@Override\n@Nullable\npublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n        throws Exception {\n\n    ((HttpRequestHandler) handler).handleRequest(request, response);\n    return null;\n}\n```\n\n那么根据`doDispatch`中传入的`handler`即则为`ResourceHttpRequestHandler`,我们可以看到资源文件的具体加载过程。\n\n```java\n@Override\npublic void handleRequest(HttpServletRequest request, HttpServletResponse response)\n        throws ServletException, IOException {\n\n    // For very general mappings (e.g. \"/\") we need to check 404 first\n    Resource resource = getResource(request);\n    if (resource == null) {\n        logger.debug(\"Resource not found\");\n        response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        return;\n    }\n\n    if (HttpMethod.OPTIONS.matches(request.getMethod())) {\n        response.setHeader(\"Allow\", getAllowHeader());\n        return;\n    }\n\n    // Supported methods and required session\n    checkRequest(request);\n\n    // Header phase\n    if (new ServletWebRequest(request, response).checkNotModified(resource.lastModified())) {\n        logger.trace(\"Resource not modified\");\n        return;\n    }\n\n    // Apply cache settings, if any\n    prepareResponse(response);\n\n    // Check the media type for the resource\n    MediaType mediaType = getMediaType(request, resource);\n\n    // Content phase\n    if (METHOD_HEAD.equals(request.getMethod())) {\n        setHeaders(response, resource, mediaType);\n        return;\n    }\n\n    ServletServerHttpResponse outputMessage = new ServletServerHttpResponse(response);\n    if (request.getHeader(HttpHeaders.RANGE) == null) {\n        Assert.state(this.resourceHttpMessageConverter != null, \"Not initialized\");\n        setHeaders(response, resource, mediaType);\n        this.resourceHttpMessageConverter.write(resource, mediaType, outputMessage);\n    }\n    else {\n        Assert.state(this.resourceRegionHttpMessageConverter != null, \"Not initialized\");\n        response.setHeader(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        ServletServerHttpRequest inputMessage = new ServletServerHttpRequest(request);\n        try {\n            List<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n            response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);\n            this.resourceRegionHttpMessageConverter.write(\n                    HttpRange.toResourceRegions(httpRanges, resource), mediaType, outputMessage);\n        }\n        catch (IllegalArgumentException ex) {\n            response.setHeader(\"Content-Range\", \"bytes */\" + resource.contentLength());\n            response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);\n        }\n    }\n}\n```\n","tags":["springmvc"],"categories":["springboot"]},{"title":"springboot静态资源定义mime类型","url":"%2F2019%2F08%2F02%2Fspringboot%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%AE%9A%E4%B9%89mime%E7%B1%BB%E5%9E%8B%2F","content":"\n## 问题描述\n\n项目中需要访问静态资源文件`xxx.ccxml`,这个文件不属于标准的文件格式。浏览器访问时，默认下载该文件。我们是期望可以直接在页面上查看的。\n\n## 背景知识\n\n>MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。\n\n详情可参考[MIME参考文档](https://baike.baidu.com/item/MIME/2900607?fr=aladdin)\n\n## 解决方案\n\n我们注册关于`ccxml`扩展类型的默认打开方式即可。\n\n一般情况下，在`tomcat`目录下的`conf/web.xml`修改或新增\n\n```xml\n <mime-mapping>\n        <extension>ccxml</extension>\n        <mime-type>application/xml</mime-type>\n </mime-mapping>\n```\n\n针对于`SpringBoot`的内置容器，提供了接口以供修改\n\nSpring Boot 1:\n\n```java\n@Configuration\npublic class HbbtvMimeMapping implements EmbeddedServletContainerCustomizer {\n\n    @Override\n    public void customize(ConfigurableEmbeddedServletContainer container) {\n        MimeMappings mappings = new MimeMappings(MimeMappings.DEFAULT);\n        mappings.add(\"ccxml\", \"application/xml; charset=utf-8\");\n        container.setMimeMappings(mappings);\n    }\n\n}\n```\n\nSpring Boot 2:\n\n```java\n@Configuration\npublic class HbbtvMimeMapping implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> {\n    @Override\n    public void customize(ConfigurableServletWebServerFactory factory) {\n        MimeMappings mappings = new MimeMappings(MimeMappings.DEFAULT);\n        mappings.add(\"ccxml\", \"application/xml; charset=utf-8\");\n        factory.setMimeMappings(mappings);\n    }\n}\n```\n\n## Spring加载静态资源的`mime`源码分析\n\n针对`SpringBoot2`，一般我们使用的是`tomcat`容器,我们自定义的加载`mimeType`的类注入了`ConfigurableServletWebServerFactory`实现类中`TomcatServletWebServerFactory`，其方法`configureContext`将自定义的`mimeType`存储到集合中\n节选片段\n\n```java\nfor (MimeMappings.Mapping mapping : getMimeMappings()) {\n    //getMimeMappings即为用自定义添加的扩展\n    //context实现类StandardContext\n    context.addMimeMapping(mapping.getExtension(), mapping.getMimeType());\n}\n```\n\n`StandardContext`\n\n```java\n@Override\npublic void addMimeMapping(String extension, String mimeType) {\n\n    synchronized (mimeMappings) {\n        //对外暴露的接口findMimeMapping\n        mimeMappings.put(extension.toLowerCase(Locale.ENGLISH), mimeType);\n    }\n    fireContainerEvent(\"addMimeMapping\", extension);\n\n}\n```\n\n根据{% post_link spring静态资源加载源码浅析 %}中的分析，找到`ResourceHttpRequestHandler`，实际执行方法`handleRequest`节选代码片段\n\n```java\nMediaType mediaType = getMediaType(request, resource);\n\nif (METHOD_HEAD.equals(request.getMethod())) {\n    setHeaders(response, resource, mediaType);\n    return;\n}\n```\n\n我们先看下`MediaType`的加载，\n\n```java\nprotected MediaType getMediaType(HttpServletRequest request, Resource resource) {\n    return (this.contentNegotiationStrategy != null ?\n            this.contentNegotiationStrategy.getMediaTypeForResource(resource) : null);\n}\n```\n\n`this.contentNegotiationStrategy`有方法`initContentNegotiationStrategy`来加载\n\n```java\nprotected PathExtensionContentNegotiationStrategy initContentNegotiationStrategy() {\n    Map<String, MediaType> mediaTypes = null;\n    if (getContentNegotiationManager() != null) {\n        PathExtensionContentNegotiationStrategy strategy =\n                getContentNegotiationManager().getStrategy(PathExtensionContentNegotiationStrategy.class);\n        if (strategy != null) {\n            mediaTypes = new HashMap<>(strategy.getMediaTypes());\n        }\n    }\n    //可以看出一般情况下加载ServletPathExtensionContentNegotiationStrategy\n    return (getServletContext() != null ?\n            new ServletPathExtensionContentNegotiationStrategy(getServletContext(), mediaTypes) :\n            new PathExtensionContentNegotiationStrategy(mediaTypes));\n}\n```\n\n我们追踪`PathExtensionContentNegotiationStrategy`的`getMediaTypeForResource`方法中\n\n```java\npublic MediaType getMediaTypeForResource(Resource resource) {\n    MediaType mediaType = null;\n    //我们可以看到mimeType和servletcontext上下文有关\n    String mimeType = this.servletContext.getMimeType(resource.getFilename());\n    if (StringUtils.hasText(mimeType)) {\n        mediaType = MediaType.parseMediaType(mimeType);\n    }\n    if (mediaType == null || MediaType.APPLICATION_OCTET_STREAM.equals(mediaType)) {\n        MediaType superMediaType = super.getMediaTypeForResource(resource);\n        if (superMediaType != null) {\n            mediaType = superMediaType;\n        }\n    }\n    return mediaType;\n}\n\n```\n\n那么我们看下具体的`servletContext.getMimeType`实现，针对`SpringBoot2`，一般我们使用的是`tomcat`容器，\n我们可定位到`ApplicationContext`\n\n```java\n@Override\npublic String getMimeType(String file) {\n\n    if (file == null)\n        return null;\n    int period = file.lastIndexOf('.');\n    if (period < 0)\n        return null;\n    String extension = file.substring(period + 1);\n    if (extension.length() < 1)\n        return null;\n    //此处context既是一开始提到的StandardContext，即可得到上文中我们自定义添加的mimetype\n    return context.findMimeMapping(extension);\n\n}\n ```\n\n最后可以看到`response`的`ContentType`和`mediaType`息息相关。\n\n```java\nprotected void setHeaders(HttpServletResponse response, Resource resource, @Nullable MediaType mediaType)\n        throws IOException {\n\n    long length = resource.contentLength();\n    if (length > Integer.MAX_VALUE) {\n        response.setContentLengthLong(length);\n    }\n    else {\n        response.setContentLength((int) length);\n    }\n\n    if (mediaType != null) {\n        //实际返回content-Type和MediaType有关\n        response.setContentType(mediaType.toString());\n    }\n    if (resource instanceof HttpResource) {\n        HttpHeaders resourceHeaders = ((HttpResource) resource).getResponseHeaders();\n        resourceHeaders.forEach((headerName, headerValues) -> {\n            boolean first = true;\n            for (String headerValue : headerValues) {\n                if (first) {\n                    response.setHeader(headerName, headerValue);\n                }\n                else {\n                    response.addHeader(headerName, headerValue);\n                }\n                first = false;\n            }\n        });\n    }\n    response.setHeader(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n}\n```\n","tags":["问题"],"categories":["springboot"]},{"title":"vscode相关","url":"%2F2019%2F08%2F01%2Fvscode%E7%9B%B8%E5%85%B3%2F","content":"\n## vim 自动切换输入法\n\n安装软件\n\n```shell\ncurl -Ls https://raw.githubusercontent.com/daipeihust/im-select/master/install_mac.sh | sh\n```\n\n软件会默认安装到目录`/user/local/bin/`下, 无参数执行时就会输出默认输入法的字符\n\n```log\n/usr/local/bin$ im-select\ncom.apple.keylayout.ABC\n```\n\n打开`vscode`的默认配置文件`setting.json`,新增如下配置\n\n```json\n    \"vim.autoSwitchInputMethod.enable\": true,\n    \"vim.autoSwitchInputMethod.defaultIM\": \"com.apple.keylayout.ABC\",\n    \"vim.autoSwitchInputMethod.obtainIMCmd\": \"/usr/local/bin/im-select\",\n    \"vim.autoSwitchInputMethod.switchIMCmd\": \"/usr/local/bin/im-select {im}\"\n```\n\n其中默认`defaultIM`的值为你需要自动切换的默认输入法\n\n## 保存后自动运行\n\n1.安装[Code Runner](https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner)\n\n在`settings.json`中配置\n\n```json\n \"code-runner.executorMapByFileExtension\": {\n     \".scm\": \"scheme --quiet<\",\n }\n```\n\n有些情况下可能需要添加如下配置才生效\n\n```json\n\"code-runner.executorMap\": {\n    \"scheme\": \"scheme --quiet< \\\"$dir$fileName\\\"\"\n}\n```\n\n2.安装[Run on Save](https://marketplace.visualstudio.com/items?itemName=pucelle.run-on-save)\n\n在`settings.json`中配置\n\n```json\n\"runOnSave.commands\": [\n    {\n        \"match\": \"\\\\.scm$\",\n        \"command\": \"scheme --quiet < ${file}\",\n        \"runIn\": \"backend\"\n    }\n]\n```\n\n具体详情配置可参考插件的文档\n\n## 最近打开文件\n\nopen recent file `⌃ R`\n\n## 括号匹配色\n\n使用 [Bracket Pair Colorizer2](https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer-2)\n\n颜色方案(使用黑色主题)使用如下在`settings.json`中配置\n\n```json\n\"bracket-pair-colorizer-2.colors\": [\n\n        \"#289CF4\",\n        \"#FED02F\",\n        \"#2CDD18\",\n        \"#FF5FFF\",\n        \"#D10000\",\n        \"#D05355\",\n        \"#fff\",\n    ]\n\n```\n\n## 是否显示侧边栏\n\n`Toggle activitiy Bar Visibility` 带图标的侧边工具栏\n\n`Toggle side Bar Visibility`快捷键`⌘b` 具体工具栏的实际内容\n\n## 合并当前行\n\njoin line `⌃ R`\n\n## 自定义代码片段\n\n1. `Configure user Snippets`\n2. 选择生效的语言\n   3 进行配置\n\nscope 不是文件扩展名\n\n```json\n\"Print to console\": {\n    \"scope\": \"scheme\",\n    \"prefix\": \"log\",\n    \"body\": [\n        \"(write-line ($0))\",\n    ],\n    \"description\": \"Log output to console\"\n}\n```\n\n## `markdown`图片插件\n\n使用[Paste Image](https://marketplace.visualstudio.com/items?itemName=mushan.vscode-paste-image)\n\n```json\n \"pasteImage.namePrefix\": \"${currentFileNameWithoutExt}_\",\n\"pasteImage.path\": \"${projectRoot}/source/images\",\n\"pasteImage.basePath\": \"${projectRoot}/source\",\n\"pasteImage.forceUnixStyleSeparator\": true,\n\"pasteImage.prefix\": \"/\",\n//插入markdown的语法\n\"pasteImage.insertPattern\": \"![${imageFileName}](/images/${imageFileName})\"\n```\n","tags":["插件"],"categories":["vscode"]},{"title":"gson使用手册","url":"%2F2019%2F08%2F01%2Fgson%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F","content":"\n## 基本类型\n\n```java\n// Serialization\nGson gson = new Gson();\ngson.toJson(1);            // ==> 1\ngson.toJson(\"abcd\");       // ==> \"abcd\"\ngson.toJson(new Long(10)); // ==> 10\nint[] values = { 1 };\ngson.toJson(values);       // ==> [1]\n\n// Deserialization\nint one = gson.fromJson(\"1\", int.class);\nInteger one = gson.fromJson(\"1\", Integer.class);\nLong one = gson.fromJson(\"1\", Long.class);\nBoolean false = gson.fromJson(\"false\", Boolean.class);\nString str = gson.fromJson(\"\\\"abc\\\"\", String.class);\nString[] anotherStr = gson.fromJson(\"[\\\"abc\\\"]\", String[].class);\n```\n\n## 类\n\n```java\nclass BagOfPrimitives {\n  private int value1 = 1;\n  private String value2 = \"abc\";\n  private transient int value3 = 3;\n  BagOfPrimitives() {\n    // no-args constructor\n  }\n}\n\n// Serialization\nBagOfPrimitives obj = new BagOfPrimitives();\nGson gson = new Gson();\nString json = gson.toJson(obj);  \n\n// ==> json is {\"value1\":1,\"value2\":\"abc\"}\n```\n\n注意事项\n\n1. 类的属性推荐使用`private`\n2. 默认情况下被`transient`修饰的属性会被忽略\n3. 序列化时为值`null`的属性将会被忽略\n4. 反序列化时，值`null`的属性将会被赋值为`零值`\n\n## 数组\n\n```java\nGson gson = new Gson();\nint[] ints = {1, 2, 3, 4, 5};\nString[] strings = {\"abc\", \"def\", \"ghi\"};\n\n// Serialization\ngson.toJson(ints);     // ==> [1,2,3,4,5]\ngson.toJson(strings);  // ==> [\"abc\", \"def\", \"ghi\"]\n\n// Deserialization\nint[] ints2 = gson.fromJson(\"[1,2,3,4,5]\", int[].class);\n// ==> ints2 will be same as ints\n```\n\n## 集合\n\n```java\nGson gson = new Gson();\nCollection<Integer> ints = Lists.immutableList(1,2,3,4,5);\n\n// Serialization\nString json = gson.toJson(ints);  // ==> json is [1,2,3,4,5]\n\n// Deserialization\nType collectionType = new TypeToken<Collection<Integer>>(){}.getType();\nCollection<Integer> ints2 = gson.fromJson(json, collectionType);\n// ==> ints2 is same as ints\n```\n\n## 泛型\n\n```java\nclass Foo<T> {\n  T value;\n}\nGson gson = new Gson();\n\nFoo<Bar> foo = new Foo<Bar>();\nType fooType = new TypeToken<Foo<Bar>>() {}.getType();\ngson.toJson(foo, fooType);\n\ngson.fromJson(json, fooType);\n```\n\n使用`TypeToken`可指定泛型\n\n## 内置解析器\n\n`java.net.URL`可以匹配如下格式的值`\"https://github.com/google/gson/\"`\n`java.net.URI` 可以匹配如下格式的值`\"/google/gson/\"`\n\n```java\nGson gson = new Gson();\nString json = \"{\\\"url\\\": \\\"https://github.com/google/gson/\\\",\\\"uri\\\": \\\"/google/gson/\\\"}\";\nTestUrl testUrl = gson.fromJson(json, TestUrl.class);\n// toString -->  GsonTest.TestUrl(url=https://github.com/google/gson/, uri=/google/gson/)\n\n@Data\npublic static class TestUrl{\n    private URL url;\n    private URI uri;\n}\n```\n\n## 自定义序列化与反序列化\n\n需要序列化的类`UserBean`\n\n```java\n@Data\npublic class UserBean {\n    private String name;\n}\n```\n\n序列化处理器，泛型为`UserBean`\n\n```java\n public class UserJsonSerializer implements JsonSerializer<UserBean>{\n\n    @Override\n    public JsonElement serialize(UserBean src, Type typeOfSrc, JsonSerializationContext context) {\n        //src 即是待序列化的实例对象\n        JsonObject userJson= new JsonObject();\n        userJson.addProperty(\"__name__\",src.getName());\n        return userJson;\n    }\n}\n```\n\n反序列化处理器，泛型为`UserBean`\n\n```java\n public class UserJsonDeserializer implements JsonDeserializer<UserBean>{\n\n    @Override\n    public UserBean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\n        UserBean userBean = new UserBean();\n        //json 即为待反序列化的字符串生成的json对象\n        JsonObject asJsonObject = json.getAsJsonObject();\n        if(asJsonObject.has(\"__name__\")){\n            userBean.setName(String.valueOf(asJsonObject.get(\"__name__\")));\n        }\n        return userBean;\n    }\n}\n```\n\n测试程序，注册`UserBean`的`TypeToken`的序列化与反序列化处理器\n\n```java\nGsonBuilder gsonBuilder = new GsonBuilder();\nType type= new TypeToken<UserBean>() {}.getType();\ngsonBuilder.registerTypeAdapter(type,new UserJsonSerializer());\ngsonBuilder.registerTypeAdapter(type,new UserJsonDeserializer());\nGson gson = gsonBuilder.create();\nUserBean userBean = new UserBean();\nuserBean.setName(\"123\");\nString json = gson.toJson(userBean);\n// {\"__name__\":\"123\"}\nuserBean = gson.fromJson(json, UserBean.class);\n//UserBean(name=\"123\")\n```\n\n## 优化打印\n\n```java\nGson gson = new GsonBuilder().setPrettyPrinting().create();\nPerson person= new Person();\nperson.setAge(1);\nperson.setName(\"hello\");\nSystem.out.println(gson.toJson(person))\n```\n\n打印结果如下\n\n```json\n{\n  \"name\": \"hello\",\n  \"age\": 1\n}\n```\n","tags":["gson"],"categories":["手册"]},{"title":"mybatis入门","url":"%2F2019%2F07%2F31%2Fmybatis%E5%85%A5%E9%97%A8%2F","content":"## 版本说明\n\n`jdk`:1.8.0_131\n`springboot`:2.1.6.RELEAS\n`maven`:3.6.1\n`database`:mysql-5.7.1\n`mybatis`:3.5.2\n`lombok插件`\n\n## 概述\n\n基于[官方文档](http://www.mybatis.org/mybatis-3/getting-started.html)的学习笔记。项目基于`maven`构建,项目主要介绍`mybatis`的使用，因此基本不使用`Spring`的相关代码\n\n建表语句如下，建表语句来自[git-mybatis-3](https://github.com/mybatis/mybatis-3/tree/master/src/test/java/org/apache/ibatis/databases/blog)，针对`mysql`进行部分修改\n\n```sql\n-- create your own database\n\nDROP TABLE IF EXISTS comment;\nDROP TABLE IF EXISTS post_tag;\nDROP TABLE IF EXISTS tag;\nDROP TABLE IF EXISTS post;\nDROP TABLE IF EXISTS blog;\nDROP TABLE IF EXISTS author;\nDROP TABLE IF EXISTS node;\n\nCREATE TABLE author (\n  id                INT PRIMARY KEY AUTO_INCREMENT,\n  username          VARCHAR(255) NOT NULL,\n  password          VARCHAR(255) NOT NULL,\n  email             VARCHAR(255) NOT NULL,\n  bio               BLOB,\n  favourite_section VARCHAR(25)\n)\n  AUTO_INCREMENT = 10000;\n\nCREATE TABLE blog (\n  id        INT PRIMARY KEY AUTO_INCREMENT,\n  author_id INT NOT NULL,\n  title     VARCHAR(255)\n);\n\nCREATE TABLE post (\n  id         INT PRIMARY KEY AUTO_INCREMENT,\n  blog_id    INT,\n  author_id  INT          NOT NULL,\n  created_on TIMESTAMP,\n  section    VARCHAR(25)  NOT NULL,\n  subject    VARCHAR(255) NOT NULL,\n  body       BLOB         NOT NULL,\n  draft      INT          NOT NULL,\n  FOREIGN KEY (blog_id) REFERENCES blog (id)\n);\n\nCREATE TABLE tag (\n  id   INT PRIMARY KEY AUTO_INCREMENT,\n  name VARCHAR(255) NOT NULL\n);\n\nCREATE TABLE post_tag (\n  post_id INT NOT NULL,\n  tag_id  INT NOT NULL,\n  PRIMARY KEY (post_id, tag_id)\n);\n\nCREATE TABLE comment (\n  id      INT PRIMARY KEY AUTO_INCREMENT,\n  post_id INT      NOT NULL,\n  name    LONGTEXT NOT NULL,\n  comment LONGTEXT NOT NULL\n);\n\nCREATE TABLE node (\n  id        INT NOT NULL,\n  parent_id INT,\n  PRIMARY KEY (id)\n);\n\n\nINSERT INTO author (id, username, password, email, bio, favourite_section)\nVALUES (101, 'jim', '********', 'jim@ibatis.apache.org', '', 'NEWS');\nINSERT INTO author (id, username, password, email, bio, favourite_section)\nVALUES (102, 'sally', '********', 'sally@ibatis.apache.org', NULL, 'VIDEOS');\n\nINSERT INTO blog (id, author_id, title) VALUES (1, 101, 'Jim Business');\nINSERT INTO blog (id, author_id, title) VALUES (2, 102, 'Bally Slog');\n\nINSERT INTO post (id, blog_id, author_id, created_on, section, subject, body, draft) VALUES\n  (1, 1, 101, '2008-01-01 00:00:01', 'NEWS', 'Corn nuts',\n   'I think if I never smelled another corn nut it would be too soon...', 1);\nINSERT INTO `post` (id, blog_id, author_id, created_on, section, subject, body, draft)\nVALUES (2, 1, 101, '2008-01-12 00.00.00', 'VIDEOS', 'Paul Hogan on Toy Dogs', 'That''s not a dog.  THAT''s a dog!', 0);\nINSERT INTO post (id, blog_id, author_id, created_on, section, subject, body, draft)\nVALUES (3, 2, 102, '2007-12-05 00.00.00', 'PODCASTS', 'Monster Trucks', 'I think monster trucks are great...', 1);\nINSERT INTO post (id, blog_id, author_id, created_on, section, subject, body, draft) VALUES\n  (4, 2, 102, '2008-01-12 00.00.00', 'IMAGES', 'Tea Parties', 'A tea party is no place to hold a business meeting...',\n   0);\n\nINSERT INTO post (id, blog_id, author_id, created_on, section, subject, body, draft)\nVALUES (5, NULL, 101, '2008-01-12 00.00.00', 'IMAGES', 'An orphaned post', 'this post is orphaned', 0);\n\nINSERT INTO tag (id, name) VALUES (1, 'funny');\nINSERT INTO tag (id, name) VALUES (2, 'cool');\nINSERT INTO tag (id, name) VALUES (3, 'food');\n\nINSERT INTO post_tag (post_id, tag_id) VALUES (1, 1);\nINSERT INTO post_tag (post_id, tag_id) VALUES (1, 2);\nINSERT INTO post_tag (post_id, tag_id) VALUES (1, 3);\nINSERT INTO post_tag (post_id, tag_id) VALUES (2, 1);\nINSERT INTO post_tag (post_id, tag_id) VALUES (4, 3);\n\nINSERT INTO comment (id, post_id, name, comment) VALUES (1, 1, 'troll', 'I disagree and think...');\nINSERT INTO comment (id, post_id, name, comment) VALUES (2, 1, 'anonymous', 'I agree and think troll is an...');\nINSERT INTO comment (id, post_id, name, comment)\nVALUES (4, 2, 'another', 'I don not agree and still think troll is an...');\nINSERT INTO comment (id, post_id, name, comment) VALUES (3, 3, 'rider', 'I prefer motorcycles to monster trucks...');\n\n\nINSERT INTO node (id, parent_id) VALUES (1, NULL);\nINSERT INTO node (id, parent_id) VALUES (2, 1);\nINSERT INTO node (id, parent_id) VALUES (3, 1);\nINSERT INTO node (id, parent_id) VALUES (4, 2);\nINSERT INTO node (id, parent_id) VALUES (5, 2);\nINSERT INTO node (id, parent_id) VALUES (6, 3);\nINSERT INTO node (id, parent_id) VALUES (7, 3);\n\n```\n\npom文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.li</groupId>\n  <artifactId>mybatis</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  <dependencies>\n    <dependency>\n      <groupId>org.mybatis</groupId>\n      <artifactId>mybatis</artifactId>\n      <version>3.5.2</version>\n    </dependency>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.11</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.projectlombok</groupId>\n      <artifactId>lombok</artifactId>\n      <version>1.18.4</version>\n    </dependency>\n  </dependencies>\n</project>\n```\n\n`mybatis`配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n    PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n    \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n  <properties resource=\"config.properties\">\n  </properties>\n  <typeAliases>\n    <package name=\"org.mybatis.example\"/>\n  </typeAliases>\n  <environments default=\"development\">\n    <environment id=\"development\">\n      <transactionManager type=\"JDBC\"/>\n      <dataSource type=\"POOLED\">\n        <property name=\"driver\" value=\"${driver}\"/>\n        <property name=\"url\" value=\"${url}\"/>\n        <property name=\"username\" value=\"${username}\"/>\n        <property name=\"password\" value=\"${password}\"/>\n      </dataSource>\n    </environment>\n    </environments>\n  <mappers>\n    <package  name=\"org.mybatis.example\"/>\n  </mappers>\n</configuration>\n```\n\n## properties\n\n定义配置文件地址，标签属性值可以`${xxx}`取配置文件的值\n\n## DataSource\n\n`dataSource`标签用来定义一个标准的`DataSource`标准，`mybatis`内置了三种类型的`DataSource`  \n>`type=\"[UNPOOLED|POOLED|JNDI]\"`\n\n### `UNPOOLED`\n\n每一次数据操作都新建。可做如下配置\n> `driver`  \n> `url`\n> `username`  \n> `password`  \n> `defaultTransactionIsolationLevel`:数据库隔离级别  \n> `defaultNetworkTimeout`\n> 同时可以为`driver`设置属性`driver.encoding=UTF8`\n\n### `POOLED`\n\n使用连接池来管理数据源,除了`UNPOOLED`的配置还可做如下配置\n>`poolMaximumActiveConnections`  \n>`poolMaximumIdleConnections`  \n>`poolMaximumCheckoutTime`  \n>`poolTimeToWait`  \n>`poolMaximumLocalBadConnectionTolerance`  \n>`poolPingQuery`  \n>`poolPingEnabled`  \n>`poolPingConnectionsNotUsedFor`  \n\n### `JNDI`\n\n`initial_context`\n`data_source`\n\n`env.`前缀的配置将被加载到`InitialContext`中\n`env.encoding=UTF8`\n\n```xml\n<dataSource type=\"JNDI\">\n  <property name=\"data_source\" value=\"java:/comp/env/jdbc/mysql\"/>\n</dataSource>\n```\n\n### 自定义类型\n\n`type`可指定为其他工厂类\n\n```xml\n<dataSource type=\"org.myproject.C3P0DataSourceFactory\">\n    <property name=\"driver\" value=\"${driver}\"/>\n    <property name=\"url\" value=\"${url}\"/>\n    <property name=\"username\" value=\"${username}\"/>\n    <property name=\"password\" value=\"${password}\"/>\n</dataSource>\n```\n\nenv.encoding=UTF8\n\n## mappers\n\n定位映射的`SQL`语句\n\n```xml\n<mappers>\n  <mapper url=\"file:/Users/BlogMapper.xml\"/>\n  <mapper class=\"org.mybatis.example.BlogMapper\"/>\n  <mapper resource=\"org.mybatis.example.BlogMapper.xml\"/>\n  <package  name=\"org.mybatis.example\"/>\n</mappers>\n```\n\n## typeAliases\n\n`mybatis`默认别名有如下\n\n|别名|class类型|\n|:-:|:-:|\n|_byte|byte|\n|_long|long|\n|_short|short|\n|_int|int|\n|_integer|int|\n|_double|double|\n|_float|float|\n|_boolean|boolean|\n|string|String|\n|byte|Byte|\n|long|Long|\n|short|Short|\n|int|Integer|\n|integer|Integer|\n|double|Double|\n|float|Float|\n|boolean|Boolean|\n|date|Date|\n|decimal|BigDecimal|\n|bigdecimal|BigDecimal|\n|object|Object|\n|map|Map|\n|hashmap|HashMap|\n|list|List|\n|arraylist|ArrayList|\n|collection|Collection|\n|iterator|Iterator|\n\n可指定其他别名\n\n```xml\n<typeAliases>\n  <typeAlias type=\"org.mybatis.example.Blog\" alias=\"blog\"/>\n  <package name=\"org.mybatis.example\"/>\n</typeAliases>\n```\n\n别名可供`resultType`或`parameterType`使用\n\n## typeHandlers\n\n每当MyBatis在PreparedStatement上设置参数或从ResultSet中检索值时，都会使用TypeHandler以适合Java类型的方式检索值。 下表描述了默认的TypeHandlers。\n\n|Type Handler|java Types|JDBC Types|\n|:-|:-|:-|\n|BooleanTypeHandler|java.lang.Boolean, boolean|Any compatible BOOLEAN|\n|ByteTypeHandler|java.lang.Byte, byte|Any compatible NUMERIC or BYTE|\n|ShortTypeHandler|java.lang.Short, short|Any compatible NUMERIC or SMALLINT|\n|IntegerTypeHandler|java.lang.Integer, int|Any compatible NUMERIC or INTEGER|\n|LongTypeHandler|java.lang.Long, long|Any compatible NUMERIC or BIGINT|\n|FloatTypeHandler|java.lang.Float, float|Any compatible NUMERIC or FLOAT|\n|DoubleTypeHandler|java.lang.Double, double|Any compatible NUMERIC or DOUBLE|\n|BigDecimalTypeHandler|java.math.BigDecimal|Any compatible NUMERIC or DECIMAL|\n|StringTypeHandler|java.lang.String|CHAR, VARCHAR|\n|ClobReaderTypeHandler|java.io.Reader|-|\n|ClobTypeHandler|java.lang.String|CLOB, LONGVARCHAR|\n|NStringTypeHandler|java.lang.String|NVARCHAR, NCHAR|\n|NClobTypeHandler|java.lang.String|NCLOB|\n|BlobInputStreamTypeHandler|java.io.InputStream|-|\n|ByteArrayTypeHandler|byte[]|Any compatible byte stream type|\n|BlobTypeHandler|byte[]|BLOB, LONGVARBINARY|\n|DateTypeHandler|java.util.Date|TIMESTAMP|\n|DateOnlyTypeHandler|java.util.Date|DATE|\n|TimeOnlyTypeHandler|java.util.Date|TIME|\n|SqlTimestampTypeHandler|java.sql.Timestamp|TIMESTAMP|\n|SqlDateTypeHandler|java.sql.Date|DATE|\n|SqlTimeTypeHandler|java.sql.Time|TIME|\n|ObjectTypeHandler|Any OTHER, or unspecified||\n|EnumTypeHandler |Enumeration Type|VARCHAR any string compatible type, as the code is stored (not index).|\n|EnumOrdinalTypeHandler|Enumeration Type|Any compatible NUMERIC or DOUBLE, as the position is stored (not the code itself).|\n|SqlxmlTypeHandler|java.lang.String|SQLXML|\n|InstantTypeHandler|java.time.Instant|TIMESTAMP|\n|LocalDateTimeTypeHandler|java.time.LocalDateTime|TIMESTAMP|\n|LocalDateTypeHandler|java.time.LocalDate|DATE|\n|LocalTimeTypeHandler|java.time.LocalTime|TIME|\n|OffsetDateTimeTypeHandler|java.time.OffsetDateTime|TIMESTAMP|\n|OffsetTimeTypeHandler|java.time.OffsetTime|TIME|\n|ZonedDateTimeTypeHandler|java.time.ZonedDateTime|TIMESTAMP|\n|YearTypeHandler|java.time.Year|INTEGER|\n|MonthTypeHandler|java.time.Month|INTEGER|\n|YearMonthTypeHandler|java.time.YearMonth|VARCHAR or LONGVARCHAR|\n|JapaneseDateTypeHandler|java.time.chrono.JapaneseDate|DATE|\n\n你可以通过继承`org.apache.ibatis.type.TypeHandler`或者使用`org.apache.ibatis.type.BaseTypeHandler`来使用非标准的`TypeHandler`\n\n在配置文件`typeHandlers`中的`typeHandler`标签中配置`jdbcType`,可指定`sql`表字段类型，若实际`java`类注解了`@MappedJdbcTypes`，会无视配置文件  \n在配置文件`typeHandlers`中的`typeHandler`标签中配置`javaType`,可指定`javaBean`类型，若实际`java`类注解了`@MappedTypes`，会无视配置文件  \n示例如下：\n\n```java\npackage org.mybatis.example;\n\nimport org.apache.ibatis.type.BaseTypeHandler;\nimport org.apache.ibatis.type.JdbcType;\nimport org.apache.ibatis.type.MappedJdbcTypes;\n\nimport java.sql.CallableStatement;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n/**\n* includeNullJdbcType=true表示当sql字段类型未知也可使用\n*/\n@MappedJdbcTypes(value=JdbcType.VARCHAR,includeNullJdbcType=true)\n@MappedTypes(String.class)  \npublic class ExampleTypeHandler extends BaseTypeHandler<String> {\n\n    @Override\n    public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {\n        ps.setString(i, parameter+\"_sql\");\n    }\n\n    @Override\n    public String getNullableResult(ResultSet rs, String columnName) throws SQLException {\n        return rs.getString(columnName)+\"_java\";\n    }\n\n    @Override\n    public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {\n        return rs.getString(columnIndex)+\":java\";\n    }\n\n    @Override\n    public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {\n        return cs.getString(columnIndex)+\"#java\";\n    }\n}\n\n```\n\n在`mybatis`配置文件中若配置了`<typehandlers>`将会替换默认的数据库类型为`VARCHAR`，`java`类型为`java.lang.String`的转换处理器\n\n```xml\n<typeHandlers>\n  <typeHandler handler=\"org.mybatis.example.ExampleTypeHandler\"/>\n  <!-- 扫描package目录下所有类型转换器-->\n  <package name=\"org.mybatis.example\"/>\n</typeHandlers>\n```\n\n 也可临时指定\n\n```xml\n<resultMap id=\"blogMap\" type=\"blog\">\n  <result column=\"id\"  property=\"id\"/>\n  <result column=\"title\" typeHandler=\"exampleTypeHandler\" property=\"title\"/>\n</resultMap>\n```\n\n可使用泛型，通过配置文件`typeHandler`的`javaType`觉得处理的`java`类型\n\n```java\npublic class GenericTypeHandler<E extends MyObject> extends BaseTypeHandler<E> {\n\n  private Class<E> type;\n\n  public GenericTypeHandler(Class<E> type) {\n    if (type == null) throw new IllegalArgumentException(\"Type argument cannot be null\");\n    this.type = type;\n  }\n```\n\n```xml\n<typeHandlers>\n  <typeHandler handler=\"org.mybatis.example.ExampleTypeHandler\" javaType=\"String\"/>\n</typeHandlers>\n```\n\n## plugins\n\n`mybatis`可定义插件来对数据库操作的各个阶段以切面的方式进行处理。`mybatis`提供了四种类型的插件\n\n在`mybatis`中增加配置，`<property>`的值注入到具体插件的`setProperties`方法的参数\n\n```xml\n<plugins>\n  <plugin interceptor=\"org.mybatis.example.ExamplePlugin\">\n    <property name=\"someProperty\" value=\"100\"/>\n  </plugin>\n</plugins>\n```\n\n插件需要继承`org.apache.ibatis.plugin.Interceptor`，其中注解`Intercepts`的值，表示切面的位置\n\n`type`\n>`Executor` (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)  \n>`ParameterHandler` (getParameterObject, setParameters)  \n>`ResultSetHandler` (handleResultSets, handleOutputParameters)  \n>`StatementHandler` (prepare, parameterize, batch, update, query)  \n\n`method`\n> `type`里的方法名\n\n`args`\n> `type`里的方法的参数类型\n\n`metdho`和`args`可以定位到一个具体的`java`方法。所以`method`和`args`的值参考`type`中的方法即可\n\n```java\npackage org.mybatis.example;\n\nimport org.apache.ibatis.cache.CacheKey;\nimport org.apache.ibatis.executor.Executor;\nimport org.apache.ibatis.mapping.BoundSql;\nimport org.apache.ibatis.mapping.MappedStatement;\nimport org.apache.ibatis.plugin.Interceptor;\nimport org.apache.ibatis.plugin.Intercepts;\nimport org.apache.ibatis.plugin.Invocation;\nimport org.apache.ibatis.plugin.Signature;\nimport org.apache.ibatis.session.ResultHandler;\nimport org.apache.ibatis.session.RowBounds;\n\nimport java.util.Properties;\n\n@Intercepts({\n    @Signature(type = Executor.class, method = \"query\", args = {MappedStatement.class, Object.class, RowBounds.class,\n        ResultHandler.class, CacheKey.class, BoundSql.class}),\n    @Signature(type = Executor.class, method = \"query\", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})\n})\npublic class ExamplePlugin implements Interceptor {\n    private Properties properties = new Properties();\n\n    public Object intercept(Invocation invocation) throws Throwable {\n        System.out.println(\"properties:\"+properties);\n        return invocation.proceed();\n    }\n\n    public void setProperties(Properties properties) {\n        this.properties = properties;\n    }\n}\n```\n\n通过自定义插件我们可以去分析下 `#{}`,`${}`的区别\n\n```java\n@Intercepts({\n    @Signature(type = Executor.class, method = \"query\", args = {MappedStatement.class, Object.class, RowBounds.class,\n        ResultHandler.class}),\n})\npublic class ExamplePlugin implements Interceptor {\n\n    public Object intercept(Invocation invocation) throws Throwable {\n        MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[0];\n        BoundSql boundSql = mappedStatement.getBoundSql(Map.class);\n        System.out.println(\"boundSql:\" + boundSql.getSql());\n        return invocation.proceed();\n    }\n}\n```\n\n```java\nsqlSession.selectOne(\n            \"org.mybatis.example.BlogMapper.selectBlog\", 1 );\n```\n\n`#{}`,`${}`的实际输出，后者有被`sql`注入的可能性\n\n```sql\nboundSql:select *\n    from Blog\n    where id = ?\n```\n\n```sql\nboundSql:select *\n    from Blog\n    where id = 1\n```\n\n## transactionManager\n\n略，一般由`spring`去控制\n\n## environments\n\n可配置多环境的数据源\n\n```xml\n<environments default=\"development\">\n    <environment id=\"development\">\n    ...\n    </environment>\n</environments>\n```\n\n可指定`id`的数据源，若未指定则使用`default`的数据源\n\n```java\nSqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);\nSqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);\n```\n\n## mapping xml\n\n详细信息科参考[官方文档](http://www.mybatis.org/mybatis-3/sqlmap-xml.html)\n`mybatis`的核心在于映射的`SQL`\n\n### SELECT\n\n```xml\n<select id=\"selectBlog\" parameterType=\"int\" resultType=\"hashmap\" >\n  select * from Blog where id = #{id}\n</select>\n```\n\n`#{id}`这个通知`mybatis`创建一个`PreparedStatement`参数，在预编译阶段实际`sql`语句会被替换为\n>`select * from Blog where id = ?`\n\n实际执行代码类型如下\n\n```java\nString selectPerson = \"SELECT * FROM PERSON WHERE ID=?\";\nPreparedStatement ps = conn.prepareStatement(selectPerson);\nps.setInt(1,id);\n```\n\n`id` `SQL`映射唯一标识  \n`parameterType` 请求参数`class`类型  \n`resultType` 返回结果集类型  \n`resultMap` 扩展的返回类型的`id`  \n`flushCache` 是否清空二级缓存，默认不清空  \n`useCache` 是否开启二级缓存，默认不缓存  \n`timeout`  请求超时时间  \n`fetchSize` 返回最大条数，默认不限制  \n`statementType` 可选`STATEMENT`,`PREPARED`或`CALLABLE`，决定使用的是 `Statement`,`PreparedStatement`或`CallableStatement`，默认的是`PREPARED`  \n`resultSetType`  \n`databaseId` `databaseIdProvider` 多种数据库引擎支持  \n`resultOrdered`  \n`resultSets`  \n\n### insert, update and delete\n\n`id` `SQL`映射唯一标识  \n`parameterType` 请求参数`class`类型  \n`flushCache` 是否清空二级缓存，默认不清空  \n`timeout`  请求超时时间  \n`statementType` 可选`STATEMENT`,`PREPARED`或`CALLABLE`，决定使用的是 `Statement`,`PreparedStatement`或`CallableStatement`，默认的是`PREPARED`  \n`useGeneratedKeys` 是否使用数据库自增主键  \n`keyProperty` 用于指定传入的`java`成员变量  \n`keyColumn` 用于指定数据库表的主键字段  \n`databaseId` `databaseIdProvider` 多种数据库引擎支持  \n\n#### 返回主键\n\n 在配置了`useGeneratedKeys`时，如何取得返回的主键\n\n ```xml\n   <insert id=\"insertBlog\" useGeneratedKeys=\"true\" keyProperty=\"java_id\" keyColumn=\"id\">\n    insert into blog( title,author_id) values (#{title},#{author_id})\n  </insert>\n ```\n\n ```java\nSqlSession sqlSession = sqlSessionFactory.openSession();\nMap map = new HashMap();\nmap.put(\"title\", \"title3\");\nmap.put(\"author_id\", \"102\");\nint insert = sqlSession.insert(\"org.mybatis.example.BlogMapper.insertBlog\", map);\nSystem.out.println(map);\nsqlSession.commit();\n ```\n\n> {title=title3, author_id=102, java_id=6}\n\n可以看到返回主键写入到请求的`pojo`中了\n\n`mybatis`还提供了其他方式进行主键的生成\n\n`<selectKey>`\n`keyProperty` 指定存储主键的字段\n`keyColumn` 用于指定数据库表的主键字段  \n`order` `Before`或者`After`,若是`Before`,则先生成主键，执行`insert`。而设置为`After`,则先`insert`,再讲返回的主键插入的写入请求的`pojo`中  \n`resultType` 返回主键类型  \n`statementType` 可选`STATEMENT`,`PREPARED`或`CALLABLE`，决定使用的是 `Statement`,`PreparedStatement`或`CallableStatement`，默认的是`PREPARED`  \n\n#### 批量插入\n\n```xml\n <insert id=\"insertBlog\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n    insert into blog( title,author_id) values\n    <foreach item=\"item\" collection=\"list\" separator=\",\">\n    (#{item.title}, #{item.author_id})\n    </foreach>\n  </insert>\n```\n\n### SQL\n\n可被其他`SQL`映射语句重复使用\n\n```xml\n<sql id=\"userColumns\"> ${alias}.id,${alias}.username,${alias}.password </sql>\n\n<select id=\"selectUsers\" resultType=\"map\">\n  select\n    <include refid=\"userColumns\"><property name=\"alias\" value=\"t1\"/></include>,\n    <include refid=\"userColumns\"><property name=\"alias\" value=\"t2\"/></include>\n  from some_table t1\n    cross join some_table t2\n</select>\n```\n\n### Parameters\n\n#### `${}`或`#{}`\n\n`${}`会被直接替换为值，而`#{}`则进入`prepared`阶段\n\n使用介绍\n\n```java\n@Select(\"select * from user where ${column} = #{value}\")\nUser findByColumn(@Param(\"column\") String column, @Param(\"value\") String value);\n```\n\n#### `#{}`高阶\n\n>`#{age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler}`\n\n指定`double`的精度\n>`#{height,javaType=double,jdbcType=NUMERIC,numericScale=2}`\n\n### ResultMap\n\n通过自定义映射关系来处理复杂的返回结果集\n\n属性\n`id` 主键\n`type` 返回`class`类型\n`autoMapping` 自动匹配的模式。查询的`ResultSet`转换`pojo`时，会自动查找同名属性(忽略大小写)\n>`NONE`表示不启用自动映射\n>`PARTIAL`表示只对非嵌套的resultMap进行自动映射\n>`FULL`表示对所有的resultMap都进行自动映射\n\n```xml\n<resultMap id=\"detailedBlogResultMap\" type=\"Blog\">\n  <constructor>\n    <idArg column=\"blog_id\" javaType=\"int\"/>\n  </constructor>\n  <result property=\"title\" column=\"blog_title\"/>\n  <association property=\"author\" javaType=\"Author\">\n    <id property=\"id\" column=\"author_id\"/>\n    <result property=\"username\" column=\"author_username\"/>\n    <result property=\"password\" column=\"author_password\"/>\n    <result property=\"email\" column=\"author_email\"/>\n    <result property=\"bio\" column=\"author_bio\"/>\n    <result property=\"favouriteSection\" column=\"author_favourite_section\"/>\n  </association>\n  <collection property=\"posts\" ofType=\"Post\">\n    <id property=\"id\" column=\"post_id\"/>\n    <result property=\"subject\" column=\"post_subject\"/>\n    <association property=\"author\" javaType=\"Author\"/>\n    <collection property=\"comments\" ofType=\"Comment\">\n      <id property=\"id\" column=\"comment_id\"/>\n    </collection>\n    <collection property=\"tags\" ofType=\"Tag\" >\n      <id property=\"id\" column=\"tag_id\"/>\n    </collection>\n    <discriminator javaType=\"int\" column=\"draft\">\n      <case value=\"1\" resultType=\"DraftPost\"/>\n    </discriminator>\n  </collection>\n</resultMap>\n```\n\n#### id & result\n\n映射基本类型，`id`表示主键  \n>`property` `pojo`成员变量  \n>`column`  数据库字段  \n>`javaType` 成员变量`class`类型  \n>`jdbcType`  数据库字段类型  \n>`typeHandler`  使用具体的处理器去处理\n\n支持的数据库类型\n>`BIT` `FLOAT` `CHAR` `TIMESTAMP` `OTHER` `UNDEFINED`\n>`TINYINT` `REAL` `VARCHAR` `BINARY` `BLOB` `NVARCHAR`\n>`SMALLINT` `DOUBLE` `LONGVARCHAR` `VARBINARY` `CLOB` `NCHAR`\n>`INTEGER` `NUMERIC` `DATE` `LONGVARBINARY` `BOOLEAN` `NCLOB`\n>`BIGINT` `DECIMAL` `TIME` `NULL` `CURSOR` `ARRAY`\n\n#### constructor\n\n为`type`有参构造器传递参数，分为`<idArg>`（主键）和`<arg>`，默认构造器参数根据顺序进行传参。\n>`property` `pojo`成员变量  \n>`column`  数据库字段  \n>`javaType` 成员变量`class`类型  \n>`jdbcType`  数据库字段类型  \n>`typeHandler`  使用具体的处理器去处理\n>`select` 其他映射语句的id，根据其查询值注入构造器参数中\n>`resultMap` 引入其他`resultMap`\n> `name` 根据名称指定具体参数值，无视参数顺序。\n\n#### association\n\n一定要注意集合类型的长度\n\n>`property` `pojo`成员变量  \n>`column`  数据库字段  \n>`javaType` 成员变量`class`类型  \n>`jdbcType`  数据库字段类型  \n>`typeHandler` 使用具体的处理器去处理\n>`select` 其他映射语句的id，根据其查询值注入到成员变量中\n>`resultMap` 引入其他`resultMap`\n>`fetchType` 可设置为`lazy`或`eager`是否延迟加载\n>`columnPrefix` 当涉及到多表查询时，多表的字段相同，那么`sql`语句就需要使用`as`来区分字段。\n例如：\n\n```xml\n<select id=\"selectBlog\" resultMap=\"blogResult\">\n  select\n  B.id as blog_id,\n  B.title as blog_title,\n  B.author_id as blog_author_id,\n  P.id as post_id,\n  P.subject as post_subject,\n  P.body as post_body,\n  from Blog B\n  left outer join Post P on B.id = P.blog_id\n  where B.id = #{id}\n</select>\n```\n\n一般情况下我们\n\n```xml\n<resultMap id=\"blogResult\" type=\"Blog\">\n  <id property=\"id\" column=\"blog_id\" />\n  <result property=\"title\" column=\"blog_title\"/>\n  <collection property=\"posts\" ofType=\"Post\">\n    <id property=\"id\" column=\"post_id\"/>\n    <result property=\"subject\" column=\"post_subject\"/>\n    <result property=\"body\" column=\"post_body\"/>\n  </collection>\n</resultMap>\n```\n\n我们可以使用`columnPrefix`来处理\n\n```xml\n<resultMap id=\"blogResult\" type=\"Blog\">\n  <id property=\"id\" column=\"blog_id\" />\n  <result property=\"title\" column=\"blog_title\"/>\n  <collection property=\"posts\" ofType=\"Post\" resultMap=\"blogPostResult\" columnPrefix=\"post_\"/>\n</resultMap>\n\n<resultMap id=\"blogPostResult\" type=\"Post\">\n  <id property=\"id\" column=\"id\"/>\n  <result property=\"subject\" column=\"subject\"/>\n  <result property=\"body\" column=\"body\"/>\n</resultMap>\n```\n\n#### discriminator\n\n```xml\n<resultMap id=\"vehicleResult\" type=\"Vehicle\">\n  <id property=\"id\" column=\"id\" />\n  <result property=\"vin\" column=\"vin\"/>\n  <result property=\"year\" column=\"year\"/>\n  <result property=\"make\" column=\"make\"/>\n  <result property=\"model\" column=\"model\"/>\n  <result property=\"color\" column=\"color\"/>\n  <discriminator javaType=\"int\" column=\"vehicle_type\">\n    <case value=\"1\" resultMap=\"carResult\"/>\n    <case value=\"2\" resultMap=\"truckResult\"/>\n    <case value=\"3\" resultMap=\"vanResult\"/>\n    <case value=\"4\" resultMap=\"suvResult\"/>\n  </discriminator>\n</resultMap>\n```\n\n根据`column`的值决定哪种`<case>`执行\n\n### cache\n\n略过，由`spring`去控制\n\n## Dynamic SQL\n\n## SpringBoot\n\nmaven依赖\n\n```xml\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>2.1.0</version>\n</dependency>\n```\n\n[官方文档](http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/)\n\n可在`springboot`配置文件`application.properties`(或`application.yml`).中配置`Mybatis`使用`mybatis`前缀作为配置  \n\n`config-location` `mybatis`配置文件目录\n`mapper-locations` `mapper`文件目录地址\n`type-aliases-package` 别名包名，不同目录可用`,; \\t\\n`分割\n`type-handlers-package` 类型转换器包名，不同目录可用`,; \\t\\n`分割\n`configuration-properties` 指定`properties`配置文件，可被`mybatis`配置文件和`mapper`文件中作为占位符使用\n`configuration.*` 等同于`mybatis`配置文件中的`settings`\n\n可使用`ConfigurationCustomizer`来自定制细节\n\n```java\n@Configuration\npublic class MyBatisConfig {\n  @Bean\n  ConfigurationCustomizer mybatisConfigurationCustomizer() {\n    return new ConfigurationCustomizer() {\n      @Override\n      public void customize(Configuration configuration) {\n        // customize ...\n      }\n    };\n  }\n}\n```\n\n`mybatis`会自动检测继承`mybatis`接口的`bean`  \n`Interceptor`  \n`TypeHandler`  \n`LanguageDriver (Requires to use together with mybatis-spring 2.0.2+)`  \n`DatabaseIdProvider`  \n\n```java\n@Configuration\npublic class MyBatisConfig {\n  @Bean\n  MyInterceptor myInterceptor() {\n    return MyInterceptor();\n  }\n  @Bean\n  MyTypeHandler myTypeHandler() {\n    return MyTypeHandler();\n  }\n}\n```\n","tags":["mysql"],"categories":["mybatis"]},{"title":"动态规划","url":"%2F2019%2F07%2F31%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F","content":"## 题目\n\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n注意：给定 n 是一个正整数。\n\n示例 1：\n>输入： 2\n输出： 2\n\n解释： 有两种方法可以爬到楼顶。\n\n> 1 阶 + 1 阶\n> 2 阶\n\n示例 2：\n>输入： 3\n输出： 3\n\n解释： 有三种方法可以爬到楼顶。\n\n>1 阶 + 1 阶 + 1 阶\n1 阶 + 2 阶\n2 阶 + 1 阶\n\n## 思路\n\n使用动态规划的思路去解决问题。对于指定n阶的楼梯，最后一次爬楼梯，要嘛是1阶，要嘛就是2阶，那么总共就有爬$n-1$阶和$n-2$阶的楼梯\n\n状态转移方程式\n\n$F(1) = 1$  \n$F(2) = 2$  \n$F(n) = F(n-1)+F(n-2)$  \n\n根据状态转移方程式，我们可以很容易的得出代码如下\n\n```java\n\nclass Solution {\n  \n  public int climbStairs(int n) {\n    if (n < 3) {\n      return n;\n    }\n    int f1 = 1;\n    int f2 = 2;\n    for (int i = 3; i <=n; i++) {\n      int t = f2;\n      f2 = f2 + f1;\n      f1 = t;\n    }\n    return f2;\n  }\n}\n```\n","tags":["动态规划"],"categories":["算法"]},{"title":"springboot-jpa","url":"%2F2019%2F07%2F30%2Fspringboot-jpa%2F","content":"\n## 版本说明\n\n`jdk`:1.8.0_131\n`springboot`:2.1.6.RELEAS\n`maven`:3.6.1\n`database`:mysql-5.7.14\n`lombok插件`\n\n## 概述\n\n项目基于maven，pom配置如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.1.6.RELEASE</version>\n    <relativePath/> <!-- lookup parent from repository -->\n  </parent>\n  <groupId>com.li</groupId>\n  <artifactId>springboot</artifactId>\n  <version>0.0.1-SNAPSHOT</version>\n  <name>springboot</name>\n  <description>Demo project for Spring Boot</description>\n\n  <properties>\n    <java.version>1.8</java.version>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-jdbc</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-data-jpa</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>com.github.ulisesbocchio</groupId>\n      <artifactId>jasypt-spring-boot</artifactId>\n      <version>2.1.1</version>\n    </dependency>\n    <dependency>\n      <groupId>log4j</groupId>\n      <artifactId>log4j</artifactId>\n      <version>1.2.17</version>\n    </dependency>\n    <dependency>\n      <groupId>org.projectlombok</groupId>\n      <artifactId>lombok</artifactId>\n      <optional>true</optional>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-test</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>javax.inject</groupId>\n      <artifactId>javax.inject</artifactId>\n      <version>1</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.aspectj</groupId>\n      <artifactId>aspectjweaver</artifactId>\n      <version>1.9.4</version>\n    </dependency>\n    <dependency>\n      <groupId>org.apache.commons</groupId>\n      <artifactId>commons-lang3</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>com.google.code.gson</groupId>\n      <artifactId>gson</artifactId>\n      <version>2.8.5</version>\n    </dependency>\n  </dependencies>\n\n  <build>\n    <plugins>\n      <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n      </plugin>\n      <plugin>\n        <artifactId>maven-clean-plugin</artifactId>\n        <version>3.1.0</version>\n      </plugin>\n    </plugins>\n  </build>\n\n</project>\n```\n\n部分代码使用`lombok`进行简化\n\n表实体类\n\n```java\npackage com.li.springboot.bean;\n\nimport lombok.Data;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.Id;\n\n@Proxy(lazy = false)\n@Entity(name = \"log\")\n@Data\npublic class Log {\n    @Id\n    private String id;\n    private String log;\n    private String time;\n    @Column(name = \"user_id\")\n    private String userID;\n}\n```\n\n`@Id`表示主键\n`@Entity`标记当前类为一个表，若指定属性`name`，则实际表名使用`name`的值，否则使用类名。\n`@Column`中的`name`同样也是指定表的字段名。\n\n表操作类\n\n```java\npackage com.li.springboot.dao;\n\nimport com.li.springboot.bean.Log;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface LogDao extends JpaRepository<Log, String> {\n}\n\n```\n\n```java\npackage com.li.springboot.controller;\n\nimport com.li.springboot.bean.Log;\nimport com.li.springboot.dao.LogDao;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class LogController {\n  @Autowired\n  LogDao logDao;\n\n  @RequestMapping(\"/{id}\")\n  public Log log(@PathVariable String id) {\n    return logDao.getOne(id);\n  }\n}\n```\n\n`JpaRepository`的泛型，分别指定表实体类和表主键,`JpaRepository`包含常用的数据库操作，`LogDao`可直接使用。\n\n数据库连接信息配置\n\n```yml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/app\n    username: root\n    password: '{cipher}cm9vdA'\n    driver-class-name: com.mysql.cj.jdbc.Driver\n  jpa:\n    show-sql: true\nlogging:\n  level:\n    root: error\n    com:\n      li: debug\n\n```\n\n其他，略\n\n测试\n\n```java\npackage com.li.springboot.controller;\n\nimport com.google.gson.Gson;\nimport com.li.springboot.bean.Log;\nimport lombok.extern.slf4j.Slf4j;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\nimport org.springframework.test.web.servlet.MockMvc;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\n@AutoConfigureMockMvc\n@Slf4j\npublic class LogControllerTest {\n    @Autowired\n    MockMvc mockMvc;\n\n    @Test\n    public void test() throws Exception {\n        mockMvc.perform(get(\"/1\")).andDo(print()).andExpect(result -> {\n            Log log = new Gson().fromJson(result.getResponse().getContentAsString(), Log.class);\n            assert log !=null;\n        });\n    }\n\n}\n```\n","tags":["jpa"],"categories":["springboot"]},{"title":"简单逻辑学","url":"%2F2019%2F07%2F29%2F%E7%AE%80%E5%8D%95%E9%80%BB%E8%BE%91%E5%AD%A6%2F","content":"\n## 为什么学习逻辑学\n\n**提升口语表达能力**\n你所说的就是你所想的，若对事物没有一个清晰明了的认知，就更不可能用语言去精准的描述它。不要求说话说得多么好听，但求能够清楚有力的表达自己想要说的。\n\n**费曼学习法**\n能够用简单的语言向别人解释一个知识的时候，就是掌握知识的时候。而逻辑学就是关于如何精准描述事物的学科。\n\n## 如何学习逻辑学\n\n**思维导图**\n    思维导图是用简单的词语高度抽象概括知识的一个工具，而抽象的过程既是逻辑化的一个过程。\n**博客**\n    写作的过程即是讲自己所想所思转变为文字的过程，在编写博客的过程中，始终遵循简单逻辑学和金字塔原理的理论思想，不断加强自己的概括抽象能力。\n\n## 概述\n\n逻辑学是关于如何进行清晰有效的思维。逻辑学是揭露客观事实真相的一门学问。\n\n## 心里上的准备\n\n1. 保持注意力，世上没有两片相同的树叶，每个事务都是唯一的，我们需要保持警惕。\n\n2. 事实客观存在，不因人的主观认知而改变，而人的主观认知会随着对客观事实的理解加深而愈加接近客观事实。\n\n3. 主观认知愈加接近客观事实，就越容易清晰准确的用语言去描述它。\n\n4. 语言只能描述人的主观认知，而不是客观事实。\n\n## 如何进行有效的沟通\n\n1. 不要假设听众了解你的潜台词。\n\n2. 使用完整的语句表达自己的观点。\n\n3. 避免使用猜测，不准确的表述形式。\n\n4. 站在听众的角度，以他们能理解的方式去陈述。\n\n5. 避免使用歧义，模糊的表达。\n\n## 逻辑学第一原则\n\n1. 客观事实的定义，苹果就是苹果，不是橙子，不是香蕉，也不是梨子。\n\n2. 客观事实要嘛存在要嘛不存在，不存在中间状态\n\n3. 客观事实存在有充足的理由\n\n4. 在同样的角度下，不可能同时是同时不是\n\n## 其他原则\n\n1. 有些事务无法被清晰的定义。\n\n2. 有些事务我们不知道是如何发生的，但是我们知道一定是有原因的\n\n3. 尽量缩短逻辑链\n\n4. 区分主次\n\n5. 用自己的语言去解释\n\n6. 用明确的肯定的语言描述\n\n7. 抽象概括观点\n","tags":["学习"],"categories":["逻辑学"]},{"title":"docker基础","url":"%2F2019%2F07%2F22%2Fdocker%E5%9F%BA%E7%A1%80%2F","content":"## 指南\n\n### 安装\n\n[官方安装文档](https://docs.docker.com/install/)\n\n`docker --version` 查看版本号\n`docker info` 查看docker详细信息\n\n### 概述\n\n#### image\n\n容器是由镜像文件加载启动的。镜像是一个可执行文件，包含运行应用程序所需要的所有资源，包括\n代码，运行环境，环境变量，配置文件等。\n可通过`docker images`查看所有镜像\n\n```shell\nREPOSITORY                                             TAG                 IMAGE ID            CREATED             SIZE\njenkins/jenkins                                        2.138.4             b8efbb99cea6        7 months ago        701MB\nregistry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g   latest              3fa112fd3642        3 years ago         6.85GB\n```\n\n#### container\n\n容器是镜像的运行实例，容器共享宿主机的`kernel`内核，独立进程运行，不占用其他任何可执行文件的内存。\n\n部分命令\n\n```shell\n## List Docker CLI commands\ndocker\ndocker container --help\n\n## Display Docker version and info\ndocker --version\ndocker version\ndocker info\n\n## Execute Docker image\ndocker run hello-world\n\n## List Docker images\ndocker image ls\n\n## List Docker containers (running, all, all in quiet mode)\ndocker container ls\ndocker container ls --all\ndocker container ls -aq\n```\n\n## 容器\n\n### 创建自己的容器\n\n通过`Dockerfile`定义镜像\n新建一个空目录，`cd`进入目录，编辑`Dockerfile`文件\n\n```bash\n# Use an official Python runtime as a parent image\nFROM python:2.7-slim\n\n# Set the working directory to /app\nWORKDIR /app\n\n# Copy the current directory contents into the container at /app\nCOPY . /app\n\n# Install any needed packages specified in requirements.txt\nRUN pip install --trusted-host pypi.python.org -r requirements.txt\n\n# Make port 80 available to the world outside this container\nEXPOSE 80\n\n# Define environment variable\nENV NAME World\n\n# Run app.py when the container launches\nCMD [\"python\", \"app.py\"]\n```\n\n根据上述`Dockerfile`新建`requirements.txt`和`app.py`\n\n```txt\nFlask\nRedis\n```\n\n```python\nfrom flask import Flask\nfrom redis import Redis, RedisError\nimport os\nimport socket\n\n# Connect to Redis\nredis = Redis(host=\"redis\", db=0, socket_connect_timeout=2, socket_timeout=2)\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    try:\n        visits = redis.incr(\"counter\")\n    except RedisError:\n        visits = \"<i>cannot connect to Redis, counter disabled</i>\"\n\n    html = \"<h3>Hello {name}!</h3>\" \\\n           \"<b>Hostname:</b> {hostname}<br/>\" \\\n           \"<b>Visits:</b> {visits}\"\n    return html.format(name=os.getenv(\"NAME\", \"world\"), hostname=socket.gethostname(), visits=visits)\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port=80)\n```\n\n执行`docker build -t=friendlyhello .`\n等待编译完成后通过`docker image ls`可查看到已经编译好的镜像\n\n```bash\nREPOSITORY                                             TAG                 IMAGE ID            CREATED             SIZE\nfriendlyhello                                          latest              9f7c2034a1f3        27 seconds ago      148MB\npython                                                 2.7-slim            5caa018c2dc0        9 days ago          137MB\n```\n\n 执行`docker run -d -p 4000:80 friendlyhello`，以后台进程的方式运行容器\n\n 可通过[http://localhost:4000](http://localhost:4000)访问首页\n\n版本控制\n`docker tag image username/repository:tag`\n\n部分命令\n\n```bash\ndocker build -t friendlyhello .  # Create image using this directory's Dockerfile\ndocker run -p 4000:80 friendlyhello  # Run \"friendlyhello\" mapping port 4000 to 80\ndocker run -d -p 4000:80 friendlyhello         # Same thing, but in detached mode\ndocker container ls                                # List all running containers\ndocker container ls -a             # List all containers, even those not running\ndocker container stop <hash>           # Gracefully stop the specified container\ndocker container kill <hash>         # Force shutdown of the specified container\ndocker container rm <hash>        # Remove specified container from this machine\ndocker container rm $(docker container ls -a -q)         # Remove all containers\ndocker image ls -a                             # List all images on this machine\ndocker image rm <image id>            # Remove specified image from this machine\ndocker image rm $(docker image ls -a -q)   # Remove all images from this machine\ndocker login             # Log in this CLI session using your Docker credentials\ndocker tag <image> username/repository:tag  # Tag <image> for upload to registry\ndocker push username/repository:tag            # Upload tagged image to registry\ndocker run username/repository:tag                   # Run image from a registry\n```\n\n## 服务化\n\n## 下载镜像\n\n`docker pull name:tag`\n`name`镜像名\n`tag`镜像版本\n\n>若速度较慢，可以配置阿里云镜像加速 [镜像加速参考文档](https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors)\n\n## 删除镜像\n\n`docker images`查看所有镜像\n`dockder rmi 'image_id'`删除镜像\n\n## 查看日志\n\n```shell\ndocker logs [OPTIONS] CONTAINER\n  Options:\n        --details        显示更多的信息\n    -f, --follow         跟踪实时日志\n        --since string   显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟）\n        --tail string    从日志末尾显示多少行日志， 默认是all\n    -t, --timestamps     显示时间戳\n        --until string   显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟）\n```\n\n查看指定时间后的日志，只显示最后100行：\n\n```shell\ndocker logs -f -t --since=\"2018-02-08\" --tail=100 CONTAINER_ID`\n```\n\n查看最近30分钟的日志:\n\n```shell\ndocker logs --since 30m CONTAINER_ID\n```\n\n查看某时间之后的日志：\n\n```shell\ndocker logs -t --since=\"2018-02-08T13:23:37\" CONTAINER_ID\n```\n\n查看某时间段日志：\n\n```shell\ndocker logs -t --since=\"2018-02-08T13:23:37\" --until \"2018-02-09T12:23:37\" CONTAINER_ID\n```\n\n## 挂载宿主目录\n\n`-v`可重复使用，指定多个目录\n\n```shell\ndocker run -d -p 8002:8080 -v ~/jenkins:/var/jenkins_home -v /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home:/mnt/java -v /usr/local/Cellar/maven/3.6.1:/mnt/maven -v /Users/li/.m2:/mnt/.m2 --name jenkins --restart=always jenkins/jenkins:2.138.4\n\n```\n\n`/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home:/mnt/java`挂载jdk\n\n## 进入容器\n\n`docker exec -it 6bcaf729d3d4 bash`\n\n`6bcaf729d3d4`容器id，可通过`docker ps`查看\n\n```shell\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES\n6bcaf729d3d4        jenkins             \"/bin/tini -- /usr/l…\"   31 seconds ago      Up 29 seconds       50000/tcp, 0.0.0.0:8002->8080/tcp   jenkins\n```\n\n以root权限登录\n`sudo docker exec -ti -u root 6bcaf729d3d4 bash`\n\n## 容器内vi安装\n\n进入容器中使用vi提示不存在\n\n`apt-get update`更新软件包管理工具\n`apt-get install vi`安装vi\n","tags":["基础教程"],"categories":["docker"]},{"title":"jenkins远程发布","url":"%2F2019%2F07%2F22%2Fjenkins%E8%BF%9C%E7%A8%8B%E5%8F%91%E5%B8%83%2F","content":"\n## 版本说明\n\n省略docker安装过程\n\n`docker version`\n\n```log\nClient:\n Version:           18.06.1-ce\n API version:       1.38\n Go version:        go1.10.3\n Git commit:        e68fc7a\n Built:             Tue Aug 21 17:21:31 2018\n OS/Arch:           darwin/amd64\n Experimental:      false\n\nServer:\n Engine:\n  Version:          18.06.1-ce\n  API version:      1.38 (minimum version 1.12)\n  Go version:       go1.10.3\n  Git commit:       e68fc7a\n  Built:            Tue Aug 21 17:29:02 2018\n  OS/Arch:          linux/amd64\n  Experimental:     true\n```\n\n`java -version`\n\n```log\njava version \"1.8.0_131\"\nJava(TM) SE Runtime Environment (build 1.8.0_131-b11)\nJava HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)\n```\n\n## 安装Jenkins镜像\n\n```shell\ndocker pull jenkins/jenkins:2.138.1-slim\n```\n\n拉取的是2.138.1-slim版本的jenkins，可通过命令查看下载的版本\n\n`docker images`\n\n```log\nREPOSITORY                                             TAG                 IMAGE ID            CREATED             SIZE\njenkins                                                latest              cd14cecfdb3a        12 months ago       696MB\n```\n\n## 启动Jenkins\n\n```shell\ndocker run -d -p 8002:8080 -v ~/jenkins:/var/jenkins_home -v /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home:/mnt/java -v /usr/local/Cellar/maven/3.6.1:/mnt/maven --name jenkins --restart=always jenkins/jenkins:2.138\n```\n\n`8002:8080` 本地8002端口映射容器8080端口\n\n查看启动日志\n`docker logs -f jenkins`\n可以看到`jenkins`的默认`admin`密码\n\n```log\nJenkins initial setup is required. An admin user has been created and a password generated.\nPlease use the following password to proceed to installation:\n\n8b34af422fa24794bdb86d3e299162bd\n\nThis may also be found at: /var/jenkins_home/secrets/initialAdminPassword\n```\n\n界面访问[`127.0.0.1:8002`](http://127.0.0.1:8002),自动跳转至登录界面,首次进线输入默认密码，登录后安装推荐插件。\n\njenkins插件镜像\n\n页面依次点击/Manage Jenkins/Manage Plugins/Advanced\n镜像地址：\n\n```shell\nhttps://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json\n```\n\n![jenkins插件镜像](jenkins远程发布/jenkins插件镜像.jpg)\n","tags":["tomact"],"categories":["jenkins"]},{"title":"idea技巧","url":"%2F2019%2F07%2F21%2Fidea%E6%8A%80%E5%B7%A7%2F","content":"\n## 调试\n\n1. `Evaluate Expression`,在`Debug`模式下使用，可以动态编写代码进行调试\n\n2. 右键`BreakPoint`可设置`condition`，即在指定条件下断点生效\n\n## 输入\n\n多尝试用自定义模板[官方自定义模板内容函数](https://www.jetbrains.com/help/idea/template-variables.html)\n\n## 快捷键\n\n==⇧⌘F12== 最小化工具窗口\n\n## `gradle`\n\n`gradle`编译特别慢，需要在`idea`设置中设置`HTTP Proxy`\n\n## 跳转源码\n\n`jump to source`快捷键为`⎋(esc)`或`⌘+↓`\n\n## 回到`Project`视图源码处\n\n`select in project view`默认没有快捷键\n\n## 自动分屏到右边\n\n`move right`\n\n## 切换 tab\n\n`switcher` 快捷键为`⌃⇥`\n\n`⇧⌘[`上个 tab\n`⇧⌘]`下个 tab\n\n## debug 模式下,开启变量提示\n\n`show values inline`\n\n## 当前行行数高亮\n\n`line number on caret row`\n\n## `live templates`\n\n`ifn`快速判断当前行数变量是否为 null\n\n```java\nif (var == null) {\n\n}\n```\n\n## `Hippie completion`\n\n自动输入前面或后面的单词`⌥/` `⌥⇧/`\n\n## `Smart Type`\n\n智能补全，比如说提示使用何种`lambda` `⇧ space`\n\n## 自动补全根据使用频率\n\n`sort suggestions alphabetically`\n\n## `quick Definitions`\n\n弹出窗口快速查看代码`⌥q`\n\n## `quick documentation`\n\n弹出窗口快速查看文档`⌥F1`\n\n## 为报错文件设置提醒色\n\n`File Color`\n\n## 使用`favorite`\n\n## `custome live template`\n\n可以选中代码后，抽取为`template`\n\n## `keymap abbrevation`\n\n添加快捷方式的缩写，方便使用`find action`查找\n\n## `recent location`\n\n最近访问的路径`⌘⇧e`\n\n## `paster form history`\n\n`idea`记录了最近复制过(`⌘c`)的文本\n\n## `adjust code style setting`\n\n选中代码后，使用可以查卡到选中代码所使用的格式选项，可以去调整它，``⌥⏎`\n\n## `breadcrumbs`\n\n使用面包屑导航显示代码类，方法\n","tags":["tips"],"categories":["tips"]},{"title":"springboot数据库密码加密","url":"%2F2019%2F07%2F19%2Fspringboot%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86%2F","content":"\n## 方案一\n\n`SpringBoot`在配置文件`application`中配置的关于数据库连接信息,在实际使用时是转换为`DataSource`类，那么只要将`SpringBoot`实现的`DataSource`继承类中，\n将实际密文解密即可。通过查看源码可得知，`SpringBoot`中`DataSource`实现类为`HikariDataSource`,那么我们通过`BeanPostProcessor`在实例化`HikariDataSource`时,\n替换密文即可。代码如下\n\n```yml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/app\n    username: root\n    password: cm9vdA==\n    driver-class-name: com.mysql.jdbc.Driver\n```\n\n```java\n  @Bean\n  public static BeanPostProcessor beanPostProcessor() {\n    return new BeanPostProcessor() {\n      @Override\n      public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        if (bean instanceof HikariDataSource) {\n          HikariDataSource hikariDataSource = (HikariDataSource) bean;\n          hikariDataSource.setPassword(new String(Base64Utils.decode(hikariDataSource.getPassword().getBytes())));\n        }\n        return null;\n      }\n    };\n  }\n```\n\n## 方案二\n\n使用jasypt\n\n```xml\n<dependency>\n    <groupId>com.github.ulisesbocchio</groupId>\n    <artifactId>jasypt-spring-boot-starter</artifactId>\n    <version>2.1.1</version>\n</dependency>\n```\n\n开启\n\n```java\n@EnableEncryptableProperties\npublic class SpringbootApplication {\n}\n```\n\n自定义处理器解密处理器\n\n```yml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/app\n    username: root\n    password: \"{cipher}cm9vdA\"\n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\n```java\n\n  public static final String ENCODED_PASSWORD_HINT = \"{cipher}\";\n\n  @Bean\n  public static EncryptablePropertyDetector encryptablePropertyDetector() {\n    return new EncryptablePropertyDetector() {\n\n      @Override\n      public boolean isEncrypted(String s) {\n        if (null != s) {\n          return s.startsWith(ENCODED_PASSWORD_HINT);\n        }\n        return false;\n      }\n\n      @Override\n      public String unwrapEncryptedValue(String s) {\n        return s.substring(ENCODED_PASSWORD_HINT.length());\n      }\n    };\n  }\n\n  @Bean\n  public static EncryptablePropertyResolver encryptablePropertyResolver() {\n    return new EncryptablePropertyResolver() {\n      @Override\n      public String resolvePropertyValue(String s) {\n        if (null != s && s.startsWith(ENCODED_PASSWORD_HINT)) {\n          return new String(Base64Utils.decode(s.substring(ENCODED_PASSWORD_HINT.length()).getBytes()));\n        }\n        return s;\n      }\n    };\n  }\n  ```\n\n## 方案三\n\n根据方案二的实现原理，使用`BeanFactoryPostProcessor`实现一个自动解密配置文件的处理器\n\n```yml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/app\n    username: root\n    password: \"{cipher}cm9vdA\"\n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\n```java\n @Bean\n  public static EncryptationAwarePropertyPlaceholderConfigurer enableEncryptablePropertySourcesPostProcessor(ConfigurableEnvironment environment) {\n    return new DecodeBeanFactoryPostProcessor(environment);\n  }\n```\n\n```java\npublic class DecodeBeanFactoryPostProcessor implements BeanFactoryPostProcessor {\n  \n  \n  private ConfigurableEnvironment environment;\n  \n  public DecodeBeanFactoryPostProcessor(ConfigurableEnvironment environment) {\n    this.environment = environment;\n  }\n  \n  \n  @Override\n  public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n    MutablePropertySources propertySources = environment.getPropertySources();\n    StreamSupport.stream(propertySources.spliterator(), false).forEach(ps -> {\n      //示例代码，仅仅处理application.yml相关的解码操作\n      if (ps.getName().equals(\"applicationConfig: [classpath:/application.yml]\")) {\n        Map<Object, Object> source = (Map) ps.getSource();\n        source.keySet().forEach(k -> {\n          Object value = source.computeIfPresent(k, (key, v) -> {\n            String cipher = v.toString();\n            if (cipher.startsWith(\"{cipher}\")) {\n              return new String(Base64Utils.decode(cipher.substring(\"{cipher}\".length()).getBytes()));\n            }\n            return v;\n          });\n        });\n      }\n    });\n  }\n\n```\n\n其中需要注意的是，`DecodeBeanFactoryPostProcessor`的实例化需要在`ApplicationContext`加载成功后再去实例化，确保`ConfigurableEnvironment`已被正确初始化\n","tags":["加密"],"categories":["springboot"]},{"title":"maven入门","url":"%2F2019%2F07%2F15%2Fmaven%E5%85%A5%E9%97%A8%2F","content":"\n省略下载安装过程\n\n## 配置\n\nmaven 默认目录在`${user.home}/.m2/`\n`settings.xml`配置文件为 maven 的全局配置\n\n### 镜像\n\nmaven 默认中央仓库访问速度较慢，可通过配置阿里云的镜像加速访问。当需要禁止访问中央仓库时，也可通过配置镜像将中央仓库指定为远程仓库\n\n阿里云镜像地址：\n\n> `http://maven.aliyun.com/nexus/content/groups/public/`\n\n在`${user.home}/.m2/settings.xml`中新增如下配置\n\n```xml\n<settings>\n  ...\n  <mirrors>\n    <mirror>\n      <id>UK</id>\n      <name>UK Central</name>\n      <url>http://uk.maven.org/maven2</url>\n      <mirrorOf>central</mirrorOf>\n    </mirror>\n  </mirrors>\n  ...\n</settings>\n```\n\n1. `<mirrorOf>central</mirrorOf>`\n   里是要替代的仓库的 id。\n2. `<mirrorOf>*</mirrorOf>`\n   匹配所有仓库\n3. `<mirrorOf>external:*</mirrorOf>`\n   匹配所有远程仓库，使用`localhost`的除外，使用`file://`协议的除外。也就是说，匹配所有不在本机上的远程仓库。\n4. `<mirrorOf>repo1,repo2</mirrorOf>`\n   匹配仓库 repo1 和 repo2，使用逗号分隔多个远程仓库。\n5. `<mirrorOf>*,!repo1</miiroOf>`\n   匹配所有远程仓库，repo1 除外，使用感叹号将仓库从匹配中排除。\n\n## POM\n\npom 是最基础的组件，是 maven 用来构建项目的基础配置文件，其中包括许多默认属性。\n\n### Super POM\n\n所有的 pom 文件都继承自`Super POM`，除非你设置了不继承。\n\n下面是 Maven 3.5.4 版本的`Super POM`摘要\n\n```xml\n<project>\n  <modelVersion>4.0.0</modelVersion>\n  <repositories>\n    <repository>\n      <id>central</id>\n      <name>Central Repository</name>\n      <url>https://repo.maven.apache.org/maven2</url>\n      <layout>default</layout>\n      <snapshots>\n        <enabled>false</enabled>\n      </snapshots>\n    </repository>\n  </repositories>\n  <pluginRepositories>\n    <pluginRepository>\n      <id>central</id>\n      <name>Central Repository</name>\n      <url>https://repo.maven.apache.org/maven2</url>\n      <layout>default</layout>\n      <snapshots>\n        <enabled>false</enabled>\n      </snapshots>\n      <releases>\n        <updatePolicy>never</updatePolicy>\n      </releases>\n    </pluginRepository>\n  </pluginRepositories>\n  <build>\n    <directory>${project.basedir}/target</directory>\n    <outputDirectory>${project.build.directory}/classes</outputDirectory>\n    <finalName>${project.artifactId}-${project.version}</finalName>\n    <testOutputDirectory>${project.build.directory}/test-classes</testOutputDirectory>\n    <sourceDirectory>${project.basedir}/src/main/java</sourceDirectory>\n    <scriptSourceDirectory>${project.basedir}/src/main/scripts</scriptSourceDirectory>\n    <testSourceDirectory>${project.basedir}/src/test/java</testSourceDirectory>\n    <resources>\n      <resource>\n        <directory>${project.basedir}/src/main/resources</directory>\n      </resource>\n    </resources>\n    <testResources>\n      <testResource>\n        <directory>${project.basedir}/src/test/resources</directory>\n      </testResource>\n    </testResources>\n    <pluginManagement>\n      <!-- NOTE: These plugins will be removed from future versions of the super POM -->\n      <!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) -->\n      <plugins>\n        <plugin>\n          <artifactId>maven-antrun-plugin</artifactId>\n          <version>1.3</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-assembly-plugin</artifactId>\n          <version>2.2-beta-5</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-dependency-plugin</artifactId>\n          <version>2.8</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-release-plugin</artifactId>\n          <version>2.5.3</version>\n        </plugin>\n      </plugins>\n    </pluginManagement>\n  </build>\n  <reporting>\n    <outputDirectory>${project.build.directory}/site</outputDirectory>\n  </reporting>\n  <profiles>\n    <!-- NOTE: The release profile will be removed from future versions of the super POM -->\n    <profile>\n      <id>release-profile</id>\n      <activation>\n        <property>\n          <name>performRelease</name>\n          <value>true</value>\n        </property>\n      </activation>\n      <build>\n        <plugins>\n          <plugin>\n            <inherited>true</inherited>\n            <artifactId>maven-source-plugin</artifactId>\n            <executions>\n              <execution>\n                <id>attach-sources</id>\n                <goals>\n                  <goal>jar-no-fork</goal>\n                </goals>\n              </execution>\n            </executions>\n          </plugin>\n          <plugin>\n            <inherited>true</inherited>\n            <artifactId>maven-javadoc-plugin</artifactId>\n            <executions>\n              <execution>\n                <id>attach-javadocs</id>\n                <goals>\n                  <goal>jar</goal>\n                </goals>\n              </execution>\n            </executions>\n          </plugin>\n          <plugin>\n            <inherited>true</inherited>\n            <artifactId>maven-deploy-plugin</artifactId>\n            <configuration>\n              <updateReleaseInfo>true</updateReleaseInfo>\n            </configuration>\n          </plugin>\n        </plugins>\n      </build>\n    </profile>\n  </profiles>\n</project>\n```\n\n## 属性\n\n### 内置属性\n\n- `${basedir}`表示项目根目录，即包含`pom.xml`文件的目录;\n\n- `${version}`表示项目版本。\n\n- `${project.basedir}`同`${basedir}`;\n\n### pom 属性\n\n使用 pom 属性可以引用到 pom.xml 文件对应元素的值,继承自`Super POM`\n\n- `${project.build.sourceDirectory}`:项目的主源码目录，默认为`src/main/java/`\n- `${project.build.testSourceDirectory}`:项目的测试源码目录，默认为`/src/test/java/`\n- `${project.build.directory}`:项目构建输出目录，默认为`target/`\n- `${project.outputDirectory}`:项目主代码编译输出目录，默认为`target/classes/`\n- `${project.testOutputDirectory}`:项目测试代码编译输出目录，默认为`target/testclasses/`\n- `${project.groupId}`:项目的`groupId`\n- `${project.artifactId}`:项目的`artifactId`\n- `${project.version}`:项目的`version`,于`${version}`等价\n- `${project.build.finalName}`:项目打包输出文件的名称，默认 为`${project.artifactId}${project.version}`\n\n### 自定义属性\n\n在`pom.xml`文件的`<properties>`标签下定义的 Maven 属性,在其他地方使用`${property}`使用该属性值。\n\n### 文件属性\n\n与 pom 属性同理,用户使用以`settings`开头的属性引用`settings.xml`文件中的 XML 元素值`${settings.localRepository}`表示本地仓库的地址;\n\n### Java 系统属性\n\n所有的 Java 系统属性都可以使用 Maven 属性引用,使用`mvn help:system`命令可查看所有的 Java 系统属性;`System.getProperties()`可得到所有的 Java 属性;`${user.home}`表示用户目录;\n\n### 环境变量属性\n\n所有的环境变量都可以用以`env.`开头的 Maven 属性引用使用`mvn help:system`命令可查看所有环境变量;\\${env.JAVA_HOME}表示 JAVA_HOME 环境变量的值;\n\n## 编译资源文件\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <build>\n    ...\n    <resources>\n      <resource>\n        <targetPath>META-INF/plexus</targetPath>\n        <filtering>false</filtering>\n        <directory>${basedir}/src/main/plexus</directory>\n        <includes>\n          <include>configuration.xml</include>\n        </includes>\n        <excludes>\n          <exclude>**/*.properties</exclude>\n        </excludes>\n      </resource>\n    </resources>\n    <testResources>\n      ...\n    </testResources>\n    ...\n  </build>\n</project>\n```\n\n- `targetPath` 编译目录,默认位置为`classes`目录\n- `directory` 项目资源目录\n\n### 生命周期和阶段\n\nclean\n\n> pre-clean, clean, post-clean\n\ndefault\n\n> validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy\n\nsite\n\n> pre-site, site, post-site, site-deploy\n\n### phase\n\n执行指定阶段及该阶段的所有前置阶段的插件。\n\n### goal\n\n`mvn tomcat7:deploy`这时 goal 为`deploy`  \n`mvn clean:clean`这时 goal 为`clean`  \n`goal`可只运行指定`goal`的插件，而不会调用前置\n\n### 调试默认\n\n`mvn compile -X`  \n可以查看`compile`插件的所有细节，包括默认配置，比如日志如下\n![详细日志](/images/maven入门_1.jpg)\n\n### 插件介绍\n\n插件的`pom`会指定默认`phase`，`goal`:[插件的官方文档](https://maven.apache.org/plugins/index.html)\n\n#### clean\n\n```xml\n<build>\n    ...\n    <plugin>\n      <artifactId>maven-clean-plugin</artifactId>\n      <version>3.1.0</version>\n    </plugin>\n    ...\n</build>\n```\n\nclean 插件主要清理编译生成的文件，默认的编译目录配置在以下属性中\n\n> `project.build.directory` > `project.build.outputDirectory` > `project.build.testOutputDirectory` > `project.reporting.outputDirectory`\n\n#### compiler\n\n```xml\n <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <version>3.8.1</version>\n        <configuration>\n          <compilerVersion>1.8</compilerVersion>\n          <source>1.8</source>\n          <target>1.8</target>\n           <compilerArgs>\n            <arg>-verbose</arg>\n            <arg>-Xlint:all,-options,-path</arg>\n          </compilerArgs>\n        </configuration>\n</plugin>\n```\n\n`compilerArgs` javac 参数  \n`source` 源码 jdk 版本  \n`target` 编译 jdk 版本  \n其他详细参数介绍请查看 :[compiler:compile 参数介绍](https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html)\n\n通过 debug 模式运行 compile，可以看到 compile 编译的源目录以及目标目录\n\n```xml\n  <buildDirectory default-value=\"${project.build.directory}\"/>\n  <classpathElements default-value=\"${project.compileClasspathElements}\"/>\n  <compileSourceRoots default-value=\"${project.compileSourceRoots}\"/>\n```\n\n`${project.build.directory}` 在`Super POM`中有定义，默认值为`${project.basedir}/target`  \n`${project.compileSourceRoots}` 默认值为`${project.basedir}/${project.build.sourceDirectory}`通过查看 maven 源码:\n\n```java\npackage org.apache.maven.project;\npublic class MavenProject implements Cloneable {\n    ...\n    private List<String> compileSourceRoots = new ArrayList<>();\n    ...\n    public void addCompileSourceRoot( String path )\n    {\n        addPath( getCompileSourceRoots(), path );\n    }\n    ...\n}\n```\n\n```java\npackage org.apache.maven.project;\n@Component( role = ProjectBuilder.class )\npublic class DefaultProjectBuilder\n    implements ProjectBuilder\n{\n    ...\n        if ( project.getFile() != null )\n        {\n            Build build = project.getBuild();\n            project.addScriptSourceRoot( build.getScriptSourceDirectory() );\n            project.addCompileSourceRoot( build.getSourceDirectory() );\n            project.addTestCompileSourceRoot( build.getTestSourceDirectory() );\n        }\n    ...\n}\n```\n\n```java\npackage org.apache.maven.project;\n@Deprecated\n@Component( role = PathTranslator.class )\npublic class DefaultPathTranslator implements PathTranslator {\n    ...\n    if ( build != null )\n      {\n          build.setDirectory( alignToBaseDirectory( build.getDirectory(), basedir ) );\n          build.setSourceDirectory( alignToBaseDirectory( build.getSourceDirectory(), basedir ) );\n    ...\n}\n```\n\n```java\npackage org.apache.maven.model.interpolation;\n\npublic abstract class AbstractStringBasedModelInterpolator\n    implements ModelInterpolator\n{\n static\n    {\n        List<String> translatedPrefixes = new ArrayList<>();\n\n        // MNG-1927, MNG-2124, MNG-3355:\n        // If the build section is present and the project directory is non-null, we should make\n        // sure interpolation of the directories below uses translated paths.\n        // Afterward, we'll double back and translate any paths that weren't covered during interpolation via the\n        // code below...\n        translatedPrefixes.add( \"build.directory\" );\n        translatedPrefixes.add( \"build.outputDirectory\" );\n        translatedPrefixes.add( \"build.testOutputDirectory\" );\n        translatedPrefixes.add( \"build.sourceDirectory\" );\n        translatedPrefixes.add( \"build.testSourceDirectory\" );\n        translatedPrefixes.add( \"build.scriptSourceDirectory\" );\n        translatedPrefixes.add( \"reporting.outputDirectory\" );\n\n        TRANSLATED_PATH_EXPRESSIONS = translatedPrefixes;\n    }\n}\n...\n\nprotected List<? extends InterpolationPostProcessor> createPostProcessors( final Model model, final File projectDir, final ModelBuildingRequest config )\n    {\n        List<InterpolationPostProcessor> processors = new ArrayList<>( 2 );\n        if ( projectDir != null ){\n            processors.add( new PathTranslatingPostProcessor( PROJECT_PREFIXES, TRANSLATED_PATH_EXPRESSIONS,projectDir, pathTranslator ) );\n        }\n        processors.add( new UrlNormalizingPostProcessor( urlNormalizer ) );\n        return processors;\n    }\n...\n```\n\n#### resources\n\n编译时拷贝资源文件,不需要显式的调用插件\n\n```xml\n<build>\n  <finalName>${project.artifactId}</finalName>\n  <resources>\n    <resource>\n      <targetPath>${project.build.directory}/META-INF</targetPath>\n      <directory>${basedir}/resources</directory>\n    </resource>\n  </resources>\n</build>\n```\n\n`targetPath`编译后目录,默认是以`${project.build.outputDirectory}`为前缀的  \n`directory` 源资源目录,默认是以`${basedir}`为前缀的  \n`finalName` 打包后的项目名,默认为`${project.artifactId}-${project.version}`\n\n#### dependency\n\n解决打包依赖的 jar 包\n\n```xml\n  <plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-dependency-plugin</artifactId>\n    <version>2.10</version>\n    <executions>\n        <execution>\n            <id>copy-dependencies</id>\n            <phase>package</phase>\n            <goals>\n                <goal>copy-dependencies</goal>\n            </goals>\n            <configuration>\n                <outputDirectory>${project.build.directory}/lib</outputDirectory>\n            </configuration>\n        </execution>\n    </executions>\n</plugin>\n```\n\n`outputDirectory`表示依赖 jar 默认输出目录，默认是`${basedir}`  \n`goal`:`copy-dependencies` [相关配置详细](https://maven.apache.org/plugins/maven-dependency-plugin/copy-dependencies-mojo.html)\n\n#### antrun\n\n执行脚本\n\n```xml\n <plugin>\n        <artifactId>maven-antrun-plugin</artifactId> <!-- 拷贝插件 -->\n        <executions>\n          <execution>\n            <id>copy</id>\n            <phase>package</phase> <!-- maven生命周期 -->\n            <configuration>\n              <tasks> <!-- 其他语法自行百度maven-antrun-plugin插件的相关用法-->\n                <echo message=\"${project.build.directory}\"/>\n                <echo message=\"${output.jar.director}\"/>\n              </tasks>\n            </configuration>\n            <goals>\n              <goal>run</goal>\n            </goals>\n          </execution>\n        </executions>\n</plugin>\n```\n\n`tasks`具体语法[参考 ant 官方文档](https://ant.apache.org/manual/index.html)\n\n### 依赖冲突\n\nMaven 采用“最近获胜策略（nearest wins strategy）”的方式处理依赖冲突，即如果一个项目最终依赖于相同 artifact 的多个版本，在依赖树中离项目最近的那个版本将被使用\n\n1.当前模块直接引入合适版本的依赖\n\n2.使用 `dependency:tree -Dverbose\"`查看是否有冲突的依赖,根据输出的依赖关系图查看是否包含`conflict`，然后根据需要排除不需要引入的版本\n通过依赖排除\n\n```xml\n<dependency>\n      <groupId>jaxen</groupId>\n      <artifactId>jaxen</artifactId>\n      <version>1.2.0</version>\n      <exclusions>\n        <exclusion>\n          <groupId>xml-apis</groupId>\n          <artifactId>xml-apis</artifactId>\n        </exclusion>\n      </exclusions>\n</dependency>\n```\n\n### dependencyManagement\n\n示例说明，\n\n在父模块中：\n\n```xml\n<dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>mysql</groupId>\n                <artifactId>mysql-connector-java</artifactId>\n                <version>5.1.44</version>\n            </dependency>\n        </dependencies>\n</dependencyManagement>\n```\n\n那么在子模块中只需要`<groupId>`和`<artifactId>`即可，如：\n\n```xml\n <dependencies>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n </dependencies>\n```\n\n说明：\n使用 dependencyManagement 可以统一管理项目的版本号，确保应用的各个项目的依赖和版本一致，不用每个模块项目都弄一个版本号，不利于管理，当需要变更版本号的时候只需要在父类容器里更新，不需要任何一个子项目的修改；如果某个子项目需要另外一个特殊的版本号时，只需要在自己的模块 dependencies 中声明一个版本号即可。子类就会使用子类声明的版本号，不继承于父类版本号。\n\n#### 与 dependencies 区别\n\n1. Dependencies 相对于 dependencyManagement，所有生命在 dependencies 里的依赖都会自动引入，并默认被所有的子项目继承。\n2. dependencyManagement 里只是声明依赖，并不自动实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且 version 和 scope 都读取自父 pom;另外如果子项目中指定了版本号，那么会使用子项目中指定的 jar 版本。\n\n## `SpringBoot`打包\n\n`SpringBoot`打包会生成两个文件\n\n> MyApplication-0.0.1-SNAPSHOT.war (可运行行文件)\n> MyApplication-0.0.1-SNAPSHOT.war.original(不可运行文件，用以发布在容器下)\n","tags":["入门教程"],"categories":["maven"]},{"title":"linux相关问题","url":"%2F2019%2F07%2F14%2Flinux%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F","content":"\n## root用户无法加载bash_profile\n\n在尝试通过使用`su root`登录到root用户，`/var/root/.bash_profile`的环境变量始终无法加载。\n通过查看`su`的文档\n`su`会以当前登录用户的session去切换用户，而`su -`会重新登录\n\n    The su command is used to become another user during a login session. Invoked without a username, su defaults to becoming the superuser. The optional argument - may be used to provide an environment similar to what the user would expect had the user logged in directly.\n\n同时\n\n    -, -l, --login\n    Provide an environment similar to what the user would expect had the user logged in directly.\n\n使用`su - root`则可正常加载环境配置\n","tags":["problem"],"categories":["linux"]},{"title":"spring tips","url":"%2F2019%2F07%2F10%2Fspring-tips%2F","content":"\n## spring bean 多个id\n\n```java\n@Service(\"Service-A\")\npublic class SampleService {\n    public String doSomething() { return \"Foo\"; }\n}\n\n@Configuration\npublic class SampleConfig {\n\n    @Bean(name = {\"Service-B\", \"Service-C\"})\n    public SampleService createMirroredService(@Autowired SampleService service) {\n        return service;\n    }\n}\n```\n\n## 作用域代理——proxyMode属性\n\n将一个短生命周期作用域bean注入给长生命周期作用域bean，我们期望长生命周期bean的属性保持与短生命周期bean同样。例如\n\n```java\n@Component\n@Scope(value = BeanDefinition.SCOPE_PROTOTYPE,proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class Prototype {\n}\n\n@Component\n@Scope(BeanDefinition.SCOPE_SINGLETON)\npublic class Singleton {\n  @Autowired\n  private Prototype prototype;\n}\n```\n\n保证每次`prototype`都是最新的，需要在`Prototype`类上定义`proxyMode`\n\n## 延迟加载bean\n\n```java\n//...  \nimport javax.inject.Inject;\nimport javax.inject.Provider;\n\npublic class InjectTest{\n\n    @Inject\n    Provider<InjectBean> provider;\n\n    public void test() {\n      InjectBean bean =  provider.get();\n    }\n\n}\n```\n\n使用`@Autowire`也是可以的，重要是使用了`Provider`\n\n## 基于注解的切面\n\n```java\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@Component\npublic class AnnotationAspect {\n  \n  @Around(\"@annotation(Log)\")\n  public void log1(ProceedingJoinPoint point){\n    MethodSignature  s = (MethodSignature) point.getSignature();\n    Log annotation = s.getMethod().getAnnotation(Log.class);\n  }\n}\n```\n\n所有注解了`@Log`的方法都会被切\n","tags":["tips"],"categories":["spring"]},{"title":"maven相关","url":"%2F2019%2F07%2F09%2Fmaven%E7%9B%B8%E5%85%B3%2F","content":"\n### idea中无法直接下载源代码\n\n可在项目目录下手动执行命令下载\n\n```bash\nmvn dependency:resolve -Dclassifier=sources\n```\n\n### maven父类pom\n\n定义父类`pom`\n\n```xml\n<groupId>com.li</groupId>\n  <artifactId>springboot</artifactId>\n  <version>1.0</version>\n  <name>springboot</name>\n  <packaging>pom</packaging>\n```\n\n执行`install`或`depoly`发布到仓库中\n\n其他项目引用\n\n```xml\n <parent>\n    <groupId>com.li</groupId>\n    <artifactId>springboot</artifactId>\n    <version>1.0</version>\n    <relativePath/>\n  </parent>\n```\n\n### eclipse中maven项目不自动编译\n\n执行`clean`，再`compile`即可。\n","tags":["maven"],"categories":["maven"]},{"title":"english","url":"%2F2019%2F07%2F09%2Fenglish%2F","content":"\n## 前缀\n\n`mis`   坏，错误，否定\n\n## 后缀\n\n`less`  表示无...的、不...的\n\n`ness`  加载形容词之后，构成抽共享名词，表示性质，情况，状态\n\n## 英文标点符号\n\n句点：英国英语（BrE）：Full Stop；美国英语（AmE）：Period，“ . ”\n问号：Question Mark，“ ? ”\n感叹号：Exclamation Mark，“ ! ”\n逗号：Comma，“ , ”\n冒号：Colon，“  : ”\n省略号：Ellipsis (众数：Ellipses)，“ ... ”\n分号：Semicolon，“ ; ”\n连字符：Hyphen，“ - ”\n连接号：En Dash，“ – ”\n破折号：Em Dash，“ — ”\n括号：Parentheses，\n　　　小括号（圆括号）“ ( ) ”（parenthesis; round brackets）；\n　　　中括号“ [ ] ”（square brackets）；\n　　　大括号“ { } ”（brackets; braces）\n引号：Quotation Marks，\n　　　双引号“ \" ”（quote）；\n　　　单引号“ ' ”（single quotation marks）\n缩写及所有格符号：Apostrophe，“ ' ”\n","tags":["english prefix subfix"],"categories":["english"]},{"title":"markdown和KaTex","url":"%2F2019%2F07%2F08%2Fmarkdown%E5%92%8CKaTex%2F","content":"\n## markdown\n\n- 空白行 `&emsp;`\n\n- 首行缩进，通过两个空白行来实现 `&emsp;&emsp;`\n\n- 有序列表\n\n```markdown\n1. ol\n2. ol\n```\n\n- 文本引用\n\n```markdown\n> 这个是区块引用\n>\n> > 这个也是区块引用\n> >\n> > > 这个还是是区块引用\n```\n\n- 插入图片\n  md 文件同级目录会生成一个同名文件夹，图片放入其中，然后通过如下方式引入\n  `![详细日志](/images/图片名.jpg)`\n  该目录在`hexo`项目目录的`source`目录下，将图片放入其中即可，为了避免冲突\n- 链接&emsp;`[title](urls)`\n\n- 表格基本模板，其中`:`表示对齐，表格上方需要空一行，否则无法正常显示\n\n  | Table Header 1 | Table Header 2 | Table Header 3 |\n  | :------------- | :------------: | -------------: |\n  | Division 1     |   Division 2   |     Division 3 |\n  | Division 1     |   Division 2   |     Division 3 |\n  | Division 1     |   Division 2   |     Division 3 |\n\n- 文本换行可在上一段文本后追加至少两个空格\n\n## KaTex\n\n[参考文档](https://katex.org/docs/supported.html)\n\n基本 KaTex 首尾需要`$`包含,例如`$X_y$`表示$X_y$\n\n| 表达式 |  示例  |\n| :----: | :----: |\n| `\\{\\}` | $\\{\\}$ |\n| `\\ge`  | $\\ge$  |\n| `\\le`  | $\\le$  |\n| `X_y`  | $X_y$  |\n\n## hexo\n\n站内引用，引用自己的博客\n{% post_link 文章文件名（不要后缀） %}\n\n使用`F8`快速定位`markdown`语法错误的地方。\n","tags":["markdown katex"],"categories":["markdown"]},{"title":"背包问题","url":"%2F2019%2F07%2F08%2F%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F","content":"## 动态规划\n\n&emsp;&emsp;通过把原问题分解为相对简单的子问题的方式来解决复杂问题的方法，动态规划常常适用于有重叠子问题和最优子结构的问题。动态规划背后的基本思想非常简单，大致上，若要解决一个给定问题，我们需要解决不同部分(子问题)，再根据子问题的解得出原问题的解。\n\n&emsp;&emsp;通常许多子问题非常相似，为此动态规划试图仅仅解决一次子问题，从而减少计算量，一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下一次需要同一个子问题解之时直接查表。\n\n## 最大子序列和\n\n对于给定序列$\\{A_1,A_2,...,A_i\\}$,求解最大子序列和\n\n状态转移方程：\n\n- $dp(1) = A1$\n- $dp(i) = max\\{A_i,A_i+dp(i-1)\\}$\n\n```java\npublic int maxSubArray(int... nums) {\n    int ans = nums[0];\n    if (nums.length == 1) {\n      return ans;\n    }\n    for (int i = 1; i < nums.length; i++) {\n      ans = Math.max(nums[i], ans + nums[i]);\n    }\n    return ans;\n  }\n```\n\n## 简单背包问题\n\n一个容量为V的背包，N种不同质量$N_v$的物品，为求解将哪些物品装入背包可使总和最大，不同质量的物品不限数量\n\n状态转移方程：\n\n- $F(0) = 0$\n- $F(V) = max\\{F(V-1),N_v+F(V-N_v)|N_v \\le V\\}$\n\n总重量为0，那么物品数量也为0\n\n总重量为V时有两种情况，\n\n- 第一种是该重量无法填满，这对应表达式$F(V-1)$的解。\n\n- 第二种情况是刚好填满，这对应一系列刚好填满的可能性的集合，其中的可能性是指最后放入包中的物品恰好是重量为$N_v$的物品，而这时候我们只需要解出$F(V-N_v)$的值即可。\n\n```java\n\n  public static int max(int[] nums, int V, Integer[] map) {\n    if (map == null) {\n      map = new Integer[V + 1];\n    }\n    if (map[V] != null) {\n      return map[V];\n    }\n    int max = V == 0 ? 0 : max(nums, V - 1, map);\n    for (int Nv : nums) {\n      if (Nv <= V) {\n        max = Math.max(Nv + max(nums, V - Nv, map), max);\n      }\n    }\n    map[V] = max;\n    return max;\n  }\n```\n\n## 参考链接\n\n[维基百科-背包问题](https://zh.wikipedia.org/wiki/背包问题)  \n[维基百科-动态规划](https://zh.wikipedia.org/wiki/动态规划)\n","tags":["状态转移方程"],"categories":["算法"]},{"title":"正则表达式.md","url":"%2F2019%2F07%2F06%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F","content":"\n## 占有字符和零宽度\n\n正则表达式匹配过程中，如果子表达式匹配到东西，儿并非一个位置，并保存到匹配结果中，这样的就称为占有字符，而只匹配到一个位置，或者匹配的内容并不保存到最终匹配结果中，这样的就称为零宽度。占有字符是互斥的，而零宽度不是互斥的。\n\n## 控制权和传动\n\n正则表达式从左到右依次进行匹配，通常情况下有一个表达式取得控制权，从字符串的摸个位置开始匹配，一个表达式开始匹配的位置是由前一个子表达匹配成功的结束位置开始的。如果表达式是零宽度，那后一个表达式的匹配位置就是零宽度匹配的位置。\n\n## 分组\n\n使用小括号包含的子表达式，可以使用回溯引用`\\n`来引用某个子表达式\n\n``` javascript\n<(h[1-6])>\\w*?<\\/\\1>\n```\n\n匹配结果:   `<h1>xxx</h1>`\n\n## 零宽度断言\n\n`(?=exp)`\n匹配exp前面的位置，但不匹配exp。表达式前面要加其它表达式配合使用\n>ab(?=123)     `ab`123ab234\n\n`(?!exp)**`\n匹配不是exp前面的位置，但不匹配exp。表达式前面要加其它表达式配合使用\n>ab(?=123)     ab123`ab`234\n\n`(?<=exp)`\n匹配exp后面的位置，但不匹配exp。表达式后面加其它表达式配合使用\n>(?<=123)ab     ab123`ab`234\n\n`(?<!exp)`\n匹配不是exp后面的位置，但不匹配exp。表达式前面要加其它表达式配合使用\n>ab(?<!123)     ab123`ab`234`ab`\n\n## 贪婪与非贪婪\n\n限定符 `*` `+` `？` `{n}` `{n,}` `{n,m}`\n非贪婪 限定符后加 `?`\n","tags":["regex"],"categories":["regex"]},{"title":"oracle练习","url":"%2F2019%2F07%2F04%2Foracle%E7%BB%83%E4%B9%A0%2F","content":"\n### 建表语句和数据插入\n\n```sql\ncreate table STUDENT\n(\nSNO VARCHAR2(20) not null\nprimary key,\nSNAME VARCHAR2(20) not null,\nSSEX VARCHAR2(20) not null,\nSBIRTHDAY DATE,\nCLASS VARCHAR2(20)\n);\n\ncreate table TEACHER\n(\nTNO VARCHAR2(20) not null\nprimary key,\nTNAME VARCHAR2(20) not null,\nTSEX VARCHAR2(20) not null,\nTBIRTHDAY DATE,\nPROF VARCHAR2(20),\nDEPART VARCHAR2(20) not null\n);\n\ncreate table COURSE\n(\nCNO VARCHAR2(20) not null\nprimary key,\nCNAME VARCHAR2(20) not null,\nTNO VARCHAR2(20) not null\nreferences TEACHER\n);\n\ncreate table SCORE\n(\nSNO VARCHAR2(20) not null\nreferences STUDENT,\nCNO VARCHAR2(20) not null\nreferences COURSE,\nDEGREE NUMBER\n);\n\n--添加学生信息\nINSERT INTO student VALUES ('108', '曾华', '男', to_date('1977-09-01','yyyy-mm-dd'), '95033');\nINSERT INTO student VALUES ('105', '匡明', '男', to_date('1975-10-02','yyyy-mm-dd'), '95031');\nINSERT INTO student VALUES ('107', '王丽', '女', to_date('1976-01-23','yyyy-mm-dd'), '95033');\nINSERT INTO student VALUES ('101', '李军', '男', to_date('1976-02-20','yyyy-mm-dd'), '95033');\nINSERT INTO student VALUES ('109', '王芳', '女', to_date('1975-02-10','yyyy-mm-dd'), '95031');\nINSERT INTO student VALUES ('103', '陆君', '男', to_date('1974-06-03','yyyy-mm-dd'), '95031');\n\n--添加教师表\nINSERT INTO teacher VALUES ('804', '李诚', '男', to_date('1958-12-02','yyyy-mm-dd'), '副教授', '计算机系');\nINSERT INTO teacher VALUES ('856', '张旭', '男', to_date('1969-03-12','yyyy-mm-dd'), '讲师', '电子工程系');\nINSERT INTO teacher VALUES ('825', '王萍', '女', to_date('1972-05-05','yyyy-mm-dd'), '助教', '计算机系');\nINSERT INTO teacher VALUES ('831', '刘冰', '女', to_date('1977-08-14','yyyy-mm-dd'), '助教', '电子工程系');\n\n--添加课程表\nINSERT INTO course VALUES ('3-105', '计算机导论', '825');\nINSERT INTO course VALUES ('3-245', '操作系统', '804');\nINSERT INTO course VALUES ('6-166', '数字电路', '856');\nINSERT INTO course VALUES ('9-888', '高等数学', '831');\n\n--添加成绩表\nINSERT INTO score VALUES ('103', '3-245', '86');\nINSERT INTO score VALUES ('105', '3-245', '75');\nINSERT INTO score VALUES ('109', '3-245', '68');\nINSERT INTO score VALUES ('103', '3-105', '92');\nINSERT INTO score VALUES ('105', '3-105', '88');\nINSERT INTO score VALUES ('109', '3-105', '76');\nINSERT INTO score VALUES ('103', '3-105', '64');\nINSERT INTO score VALUES ('105', '3-105', '91');\nINSERT INTO score VALUES ('109', '3-105', '78');\nINSERT INTO score VALUES ('103', '6-166', '85');\nINSERT INTO score VALUES ('105', '6-166', '79');\nINSERT INTO score VALUES ('109', '6-166', '81');\n```\n\n## 习题\n\n```sql\n--查询教师所有的单位即不重复的Depart列。\n--查询Score表中成绩在60到80之间的所有记录。\n--查询Score表中成绩为85，86或88的记录。\n--查询Student表中“95031”班或性别为“女”的同学记录。\n--以Class降序查询Student表的所有记录。\n--以Cno升序、Degree降序查询Score表的所有记录\n--查询“95031”班的学生人数\n--查询Score表中的最高分的学生学号和课程号\n--查询每门课的平均成绩\n--查询Score表中至少有5名学生选修的并以3开头的课程的平均分数。\n--查询所有学生的Sname、Cno和Degree列\n--查询“张旭“教师任课的学生成绩。\n--查询选修某课程的同学人数多于5人的教师姓名\n--查询存在有85分以上成绩的课程Cno.\n--查询出“计算机系“教师所教课程的成绩表\n--查询“计算 机系”与“电子工程系“不同职称的教师的Tname和Prof\n--查询选修编号为“3-105“课程且成绩至少高于选修编号为“3-245”的同学的Cno、Sno和Degree,并按Degree从高到低次序排序。\n--查询选修编号为“3-105”且成绩高于选修编号为“3-245”课程的同学的Cno、Sno和Degree.all:代表括号中的所有成绩\n--查询所有“女”教师和“女”同学的name、sex和birthday\n--查询成绩比该课程平均成绩低的同学的成绩表\n--查询所有未讲课的教师的Tname和Depart.\n--查询至少有2名男生的班号\n--查询Student表中不姓“王”的同学记录\n--查询Student表中每个学生的姓名和年龄\n```\n\n## 答案\n\n```sql\n--查询教师所有的单位即不重复的Depart列。\nSELECT DISTINCT depart\nFROM teacher;\n--查询Score表中成绩在60到80之间的所有记录。\nSELECT *\nFROM SCORE\nWHERE DEGREE >= 60 AND DEGREE <= 80;\nSELECT *\nFROM SCORE\nWHERE DEGREE BETWEEN 60 AND 80;\n--查询Score表中成绩为85，86或88的记录。\nSELECT *\nFROM SCORE\nWHERE DEGREE IN (85, 86, 88);\n--查询Student表中“95031”班或性别为“女”的同学记录。\nSELECT *\nFROM STUDENT\nWHERE CLASS = '95031' AND SSEX = '女';\n--以Class降序查询Student表的所有记录。\nSELECT *\nFROM STUDENT\nORDER BY CLASS DESC;\n--以Cno升序、Degree降序查询Score表的所有记录\nSELECT *\nFROM SCORE\nORDER BY CNO ASC, DEGREE DESC;\n--查询“95031”班的学生人数\nSELECT count(1)\nFROM STUDENT\nWHERE CLASS = '95031';\n-- 查询Score表中的最高分的学生学号和课程号\nSELECT *\nFROM SCORE\nWHERE DEGREE = (SELECT max(DEGREE)\n                FROM SCORE);\n--查询每门课的平均成绩\nSELECT *\nFROM SCORE;\nSELECT\n  CNO,\n  round(avg(DEGREE), 2)\nFROM SCORE\nGROUP BY CNO;\n--查询Score表中至少有5名学生选修的并以3开头的课程的平均分数。\nSELECT\n  CNO,\n  round(avg(DEGREE), 2)\nFROM SCORE\nWHERE CNO IN (SELECT CNO\n              FROM (SELECT\n                      CNO,\n                      count(1) AS ccno\n                    FROM SCORE\n                    GROUP BY CNO) a\n              WHERE a.ccno > 5)\nGROUP BY CNO;\n--查询所有学生的Sname、Cno和Degree列\nSELECT\n  SNAME,\n  CNO,\n  DEGREE\nFROM STUDENT st, SCORE sc\nWHERE st.SNO = sc.SNO;\n--查询“张旭“教师任课的学生成绩。\nSELECT *\nFROM TEACHER;\nSELECT *\nFROM COURSE c, TEACHER t\nWHERE c.TNO = t.TNO;\nSELECT *\nFROM SCORE\nWHERE CNO IN (SELECT CNO\n              FROM COURSE\n              WHERE TNO IN (SELECT TNO\n                            FROM TEACHER\n                            WHERE TNAME = '张旭'));\n\n--查询选修某课程的同学人数多于5人的教师姓名\nSELECT *\nFROM TEACHER\nWHERE TNO IN (SELECT TNO\n              FROM COURSE\n              WHERE CNO IN (SELECT CNO\n                            FROM (SELECT\n                                    CNO,\n                                    count(1) AS CCNO\n                                  FROM SCORE\n                                  GROUP BY CNO) t\n                            WHERE t.CCNO > 5));\n--查询存在有85分以上成绩的课程Cno.\nSELECT DISTINCT CNO\nFROM SCORE\nWHERE DEGREE > 85;\n--查询出“计算机系“教师所教课程的成绩表\nSELECT *\nFROM SCORE\nWHERE CNO IN (SELECT CNO\n              FROM COURSE\n              WHERE TNO IN (SELECT TNO\n                            FROM TEACHER\n                            WHERE DEPART = '计算机系'));\n--查询“计算 机系”与“电子工程系“不同职称的教师的Tname和Prof\nSELECT\n  TNAME,\n  PROF\nFROM TEACHER\nWHERE PROF NOT IN (\n\n  SELECT PROF\n  FROM TEACHER\n  WHERE DEPART = '计算机系' INTERSECT\n  SELECT PROF\n  FROM TEACHER\n  WHERE DEPART = '电子工程系');\n--查询选修编号为“3-105“课程且成绩至少高于选修编号为“3-245”的同学的Cno、Sno和Degree,并按Degree从高到低次序排序。\nSELECT *\nFROM SCORE\nWHERE CNO = '3-105' AND DEGREE > (SELECT max(DEGREE)\n                                  FROM SCORE\n                                  WHERE CNO = '3-245')\nORDER BY DEGREE DESC;\n--查询选修编号为“3-105”且成绩高于选修编号为“3-245”课程的同学的Cno、Sno和Degree.all:代表括号中的所有成绩\nSELECT sum(DEGREE)\nFROM SCORE\nWHERE CNO = '3-105' AND DEGREE > (SELECT max(DEGREE)\n                                  FROM SCORE\n                                  WHERE CNO = '3-245')\nORDER BY DEGREE DESC;\n--查询所有“女”教师和“女”同学的name、sex和birthday\nSELECT\n  TNAME,\n  TSEX,\n  TBIRTHDAY\nFROM TEACHER\nWHERE TSEX = '女'\nUNION SELECT\n        SNAME,\n        SSEX,\n        SBIRTHDAY\n      FROM STUDENT\n      WHERE SSEX = '女';\n--查询成绩比该课程平均成绩低的同学的成绩表\nSELECT *\nFROM SCORE\nWHERE DEGREE < (SELECT avg(DEGREE)\n                FROM SCORE);\n-- 查询所有未讲课的教师的Tname和Depart.\nSELECT\n  TNAME,\n  DEPART\nFROM TEACHER\nWHERE TNO IN (SELECT TNO\n              FROM COURSE\n              WHERE CNO NOT IN (SELECT CNO\n                                FROM SCORE));\n--查询至少有2名男生的班号\nSELECT CLASS\nFROM (SELECT\n        CLASS,\n        count(1) c\n      FROM STUDENT\n      GROUP BY CLASS) t\nWHERE t.c >= 2;\n--查询Student表中不姓“王”的同学记录\nSELECT *\nFROM STUDENT\nWHERE SNAME NOT LIKE '王%';\n\n--查询Student表中每个学生的姓名和年龄\nSELECT\n  SNAME,\n  TRUNC(months_between(sysdate, SBIRTHDAY) / 12)\nFROM STUDENT;\n\nSELECT\n  SNAME,\n  trunc((to_char(sysdate, 'yyyymmdd') - to_char(SBIRTHDAY, 'yyyymmdd')) / 10000)\nFROM STUDENT;\n\n\n```\n\n## 行列转换\n\n```sql\nCREATE TABLE kecheng\n(\n  id     NUMBER,\n  name   VARCHAR2(20),\n  course VARCHAR2(20),\n  score  NUMBER\n);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (1, '张三', '语文', 67);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (1, '张三', '数学', 76);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (1, '张三', '英语', 43);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (1, '张三', '历史', 56);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (1, '张三', '化学', 11);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (2, '李四', '语文', 54);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (2, '李四', '数学', 81);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (2, '李四', '英语', 64);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (2, '李四', '历史', 93);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (2, '李四', '化学', 27);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (3, '王五', '语文', 24);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (3, '王五', '数学', 25);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (3, '王五', '英语', 8);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (3, '王五', '历史', 45);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (3, '王五', '化学', 1);\nCOMMIT;\n```\n\n## 行列转换答案\n\n```sql\nSELECT\n  ID,\n  NAME,\n  SUM(DECODE(course, '语文', score, 0)) 语文,\n  --这里使用max,min都可以\n  SUM(DECODE(course, '数学', score, 0)) 数学,\n  SUM(DECODE(course, '英语', score, 0)) 英语,\n  SUM(DECODE(course, '历史', score, 0)) 历史,\n  SUM(DECODE(course, '化学', score, 0)) 化学\nFROM kecheng\nGROUP BY ID, NAME;\n\n\nSELECT\n  ID,\n  NAME ,\n  SUM(CASE WHEN course  = '语文' THEN score ELSE 0 END ) 语文,\n  SUM(CASE WHEN course  = '数学' THEN score ELSE 0 END ) 数学,\n  SUM(CASE WHEN course  = '英语' THEN score ELSE 0 END ) 英语,\n  SUM(CASE WHEN course  = '历史' THEN score ELSE 0 END ) 历史,\n  SUM(CASE WHEN course  = '化学' THEN score ELSE 0 END ) 化学\nFROM kecheng\nGROUP BY ID,NAME;\n```\n","tags":["oracle"],"categories":["oracle"]},{"title":"linux常用命令","url":"%2F2019%2F07%2F04%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F","content":"\n### 快速杀进程\n\n```shell\nps -ef|grep java|grep -v grep|awk '{print \"kill -9 \"$2}'|sh\n```\n\n### 获取当前日期\n\n```shell\ndt=`date +'%Y-%m-%d'`\n```\n\n### 命令可以作为参数传入shell脚本中\n\n```shell\necho $1\necho $2\n$1 $2 #直接执行\n```\n\n### 命令查看当前目录下所有文件夹的大小 -d 指深度，后面加一个数值\n\n```shell\ndu -d 1 -h  \n```\n\n### 递归查找指定文件的制定内容，显示文件名行号内容\n\n```shell\ngrep -rn 'stream' . --include='*.cpp'\n```\n\n### 快速删除大文件\n\n```shell\ncat /dev/null > access.log\n```\n\n### 快速备份\n\n```shell\ncp httpd.conf{,.bak}\n```\n\n### xargs引用参数\n\n```shell\nls *.jar|xargs -I {} echo {}\n\n```\n\n## awk\n\n`awk`可以用来快速切割文本，默认使用空格分隔符。`'{}'`中对每行都进行操作\n`$0`表示当前行，`$1`表示切割的数组的第一个元素，`'{print $1}'`表示打印第一个元素\n\n`-F ’-‘` 增加切割符\n","tags":["linux"],"categories":["linux"]}]